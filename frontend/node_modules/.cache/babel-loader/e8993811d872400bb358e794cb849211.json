{"ast":null,"code":"/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\nvar fs = require('fs');\n\nvar Url = require('url');\n\nvar spawn = require('child_process').spawn;\n/**\n * Module exports.\n */\n\n\nmodule.exports = XMLHttpRequest; // backwards-compat\n\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n/**\n * `XMLHttpRequest` constructor.\n *\n * Supported options for the `opts` object are:\n *\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\n *\n * @param {Object} opts optional \"options\" object\n */\n\nfunction XMLHttpRequest(opts) {\n  \"use strict\";\n\n  opts = opts || {};\n  /**\n   * Private variables\n   */\n\n  var self = this;\n\n  var http = require('http');\n\n  var https = require('https'); // Holds http.js objects\n\n\n  var request;\n  var response; // Request settings\n\n  var settings = {}; // Disable header blacklist.\n  // Not part of XHR specs.\n\n  var disableHeaderCheck = false; // Set some default headers\n\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n  var headers = Object.assign({}, defaultHeaders); // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n\n  var forbiddenRequestHeaders = [\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"content-transfer-encoding\", \"cookie\", \"cookie2\", \"date\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]; // These request methods are not allowed\n\n  var forbiddenRequestMethods = [\"TRACE\", \"TRACK\", \"CONNECT\"]; // Send flag\n\n  var sendFlag = false; // Error flag, used when errors occur or abort is called\n\n  var errorFlag = false;\n  var abortedFlag = false; // Event listeners\n\n  var listeners = {};\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n  /**\n   * Public vars\n   */\n  // Current state\n\n  this.readyState = this.UNSENT; // default ready state change handler in case one is not set or is set late\n\n  this.onreadystatechange = null; // Result & response\n\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n  var isAllowedHttpHeader = function (header) {\n    return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;\n  };\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n\n\n  var isAllowedHttpMethod = function (method) {\n    return method && forbiddenRequestMethods.indexOf(method) === -1;\n  };\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n\n\n  this.open = function (method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n    abortedFlag = false; // Check for valid request method\n\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": typeof async !== \"boolean\" ? true : async,\n      \"user\": user || null,\n      \"password\": password || null\n    };\n    setState(this.OPENED);\n  };\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n\n\n  this.setDisableHeaderCheck = function (state) {\n    disableHeaderCheck = state;\n  };\n  /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   * @return boolean Header added\n   */\n\n\n  this.setRequestHeader = function (header, value) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"');\n      return false;\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n\n    headers[header] = value;\n    return true;\n  };\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n\n\n  this.getResponseHeader = function (header) {\n    if (typeof header === \"string\" && this.readyState > this.OPENED && response.headers[header.toLowerCase()] && !errorFlag) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n\n\n  this.getAllResponseHeaders = function () {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n\n    return result.substr(0, result.length - 2);\n  };\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n\n\n  this.getRequestHeader = function (name) {\n    // @TODO Make this case insensitive\n    if (typeof name === \"string\" && headers[name]) {\n      return headers[name];\n    }\n\n    return \"\";\n  };\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n\n\n  this.send = function (data) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var ssl = false,\n        local = false;\n    var url = Url.parse(settings.url);\n    var host; // Determine the server\n\n    switch (url.protocol) {\n      case 'https:':\n        ssl = true;\n      // SSL & non-SSL both need host, no break here.\n\n      case 'http:':\n        host = url.hostname;\n        break;\n\n      case 'file:':\n        local = true;\n        break;\n\n      case undefined:\n      case '':\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    } // Load files off the local filesystem (file://)\n\n\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(unescape(url.pathname), 'utf8', function (error, data) {\n          if (error) {\n            self.handleError(error, error.errno || -1);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(unescape(url.pathname), 'utf8');\n          this.status = 200;\n          setState(self.DONE);\n        } catch (e) {\n          this.handleError(e, e.errno || -1);\n        }\n      }\n\n      return;\n    } // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n\n\n    var port = url.port || (ssl ? 443 : 80); // Add query string if one is used\n\n    var uri = url.pathname + (url.search ? url.search : ''); // Set the Host header or the server may reject the request\n\n    headers[\"Host\"] = host;\n\n    if (!(ssl && port === 443 || port === 80)) {\n      headers[\"Host\"] += ':' + url.port;\n    } // Set Basic Auth if necessary\n\n\n    if (settings.user) {\n      if (typeof settings.password == \"undefined\") {\n        settings.password = \"\";\n      }\n\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n    } // Set content length header\n\n\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var agent = opts.agent || false;\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: agent\n    };\n\n    if (ssl) {\n      options.pfx = opts.pfx;\n      options.key = opts.key;\n      options.passphrase = opts.passphrase;\n      options.cert = opts.cert;\n      options.ca = opts.ca;\n      options.ciphers = opts.ciphers;\n      options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n    } // Reset error flag\n\n\n    errorFlag = false; // Handle async requests\n\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request; // Request is being sent, set send flag\n\n      sendFlag = true; // As per spec, this is called here for historical reasons.\n\n      self.dispatchEvent(\"readystatechange\"); // Handler for the response\n\n      var responseHandler = function (resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp; // Check for redirect\n        // @TODO Prevent looped redirects\n\n        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url); // Set host var in case it's used later\n\n          host = url.hostname; // Options for the new request\n\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? 'GET' : settings.method,\n            headers: headers\n          };\n\n          if (ssl) {\n            newOptions.pfx = opts.pfx;\n            newOptions.key = opts.key;\n            newOptions.passphrase = opts.passphrase;\n            newOptions.cert = opts.cert;\n            newOptions.ca = opts.ca;\n            newOptions.ciphers = opts.ciphers;\n            newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n          } // Issue the new request\n\n\n          request = doRequest(newOptions, responseHandler).on('error', errorHandler);\n          request.end(); // @TODO Check if an XHR event needs to be fired here\n\n          return;\n        }\n\n        if (response && response.setEncoding) {\n          response.setEncoding(\"utf8\");\n        }\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n        response.on('data', function (chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          } // Don't emit state changes if the connection has been aborted.\n\n\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n        response.on('end', function () {\n          if (sendFlag) {\n            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\n            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\n            sendFlag = false; // Discard the 'end' event if the connection has been aborted\n\n            setState(self.DONE);\n          }\n        });\n        response.on('error', function (error) {\n          self.handleError(error);\n        });\n      }; // Error handler for the request\n\n\n      var errorHandler = function (error) {\n        self.handleError(error);\n      }; // Create the request\n\n\n      request = doRequest(options, responseHandler).on('error', errorHandler);\n\n      if (opts.autoUnref) {\n        request.on('socket', socket => {\n          socket.unref();\n        });\n      } // Node 0.4 and later won't accept empty data. Make sure it's needed.\n\n\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n      self.dispatchEvent(\"loadstart\");\n    } else {\n      // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\"); // The async request the other Node process executes\n\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\" + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\" + \"var options = \" + JSON.stringify(options) + \";\" + \"var responseText = '';\" + \"var req = doRequest(options, function(response) {\" + \"response.setEncoding('utf8');\" + \"response.on('data', function(chunk) {\" + \"  responseText += chunk;\" + \"});\" + \"response.on('end', function() {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"response.on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + \"}).on('error', function(error) {\" + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\" + \"fs.unlinkSync('\" + syncFile + \"');\" + \"});\" + (data ? \"req.write('\" + JSON.stringify(data).slice(1, -1).replace(/'/g, \"\\\\'\") + \"');\" : \"\") + \"req.end();\"; // Start the other Node Process, executing this string\n\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      var statusText;\n\n      while (fs.existsSync(syncFile)) {// Wait while the sync file is empty\n      }\n\n      self.responseText = fs.readFileSync(contentFile, 'utf8'); // Kill the child process once the file has data\n\n      syncProc.stdin.end(); // Remove the temporary file\n\n      fs.unlinkSync(contentFile);\n\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n        // If the file returned an error, handle it\n        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\n        self.handleError(errorObj, 503);\n      } else {\n        // If the file returned okay, parse its data and move to the DONE state\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\n        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\n        setState(self.DONE);\n      }\n    }\n  };\n  /**\n   * Called when an error is encountered to deal with it.\n   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.\n   */\n\n\n  this.handleError = function (error, status) {\n    this.status = status || 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n  };\n  /**\n   * Aborts a request.\n   */\n\n\n  this.abort = function () {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = Object.assign({}, defaultHeaders);\n    this.responseText = \"\";\n    this.responseXML = \"\";\n    errorFlag = abortedFlag = true;\n\n    if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n\n    this.readyState = this.UNSENT;\n  };\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n\n\n  this.addEventListener = function (event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    } // Currently allows duplicate callbacks. Should it?\n\n\n    listeners[event].push(callback);\n  };\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n\n\n  this.removeEventListener = function (event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function (ev) {\n        return ev !== callback;\n      });\n    }\n  };\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n\n\n  this.dispatchEvent = function (event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      if (this.readyState === this.DONE) setImmediate(function () {\n        self[\"on\" + event]();\n      });else self[\"on\" + event]();\n    }\n\n    if (event in listeners) {\n      for (let i = 0, len = listeners[event].length; i < len; i++) {\n        if (this.readyState === this.DONE) setImmediate(function () {\n          listeners[event][i].call(self);\n        });else listeners[event][i].call(self);\n      }\n    }\n  };\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n\n\n  var setState = function (state) {\n    if (self.readyState === state || self.readyState === self.UNSENT && abortedFlag) return;\n    self.readyState = state;\n\n    if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n      self.dispatchEvent(\"readystatechange\");\n    }\n\n    if (self.readyState === self.DONE) {\n      let fire;\n      if (abortedFlag) fire = \"abort\";else if (errorFlag) fire = \"error\";else fire = \"load\";\n      self.dispatchEvent(fire); // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n\n      self.dispatchEvent(\"loadend\");\n    }\n  };\n}\n\n;","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js"],"names":["fs","require","Url","spawn","module","exports","XMLHttpRequest","opts","self","http","https","request","response","settings","disableHeaderCheck","defaultHeaders","headers","Object","assign","forbiddenRequestHeaders","forbiddenRequestMethods","sendFlag","errorFlag","abortedFlag","listeners","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","readyState","onreadystatechange","responseText","responseXML","status","statusText","isAllowedHttpHeader","header","indexOf","toLowerCase","isAllowedHttpMethod","method","open","url","async","user","password","abort","Error","toString","setState","setDisableHeaderCheck","state","setRequestHeader","value","console","warn","getResponseHeader","getAllResponseHeaders","result","i","substr","length","getRequestHeader","name","send","data","ssl","local","parse","host","protocol","hostname","undefined","readFile","unescape","pathname","error","handleError","errno","readFileSync","e","port","uri","search","authBuf","Buffer","isBuffer","byteLength","agent","options","path","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","doRequest","dispatchEvent","responseHandler","resp","statusCode","location","newOptions","on","errorHandler","end","setEncoding","chunk","autoUnref","socket","unref","write","contentFile","process","pid","syncFile","writeFileSync","execString","JSON","stringify","slice","replace","syncProc","argv","existsSync","stdin","unlinkSync","match","errorObj","stack","addEventListener","event","callback","push","removeEventListener","filter","ev","setImmediate","len","call","fire"],"mappings":"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","sourcesContent":["/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar fs = require('fs');\nvar Url = require('url');\nvar spawn = require('child_process').spawn;\n\n/**\n * Module exports.\n */\n\nmodule.exports = XMLHttpRequest;\n\n// backwards-compat\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n\n/**\n * `XMLHttpRequest` constructor.\n *\n * Supported options for the `opts` object are:\n *\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\n *\n * @param {Object} opts optional \"options\" object\n */\n\nfunction XMLHttpRequest(opts) {\n  \"use strict\";\n\n  opts = opts || {};\n\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = require('http');\n  var https = require('https');\n\n  // Holds http.js objects\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  var disableHeaderCheck = false;\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n\n  var headers = Object.assign({}, defaultHeaders);\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"content-transfer-encoding\",\n    \"cookie\",\n    \"cookie2\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"via\"\n  ];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\n    \"TRACE\",\n    \"TRACK\",\n    \"CONNECT\"\n  ];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n  var abortedFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function(header) {\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function(method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\n  };\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function(method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n    abortedFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw new Error(\"SecurityError: Request method not allowed\");\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": (typeof async !== \"boolean\" ? true : async),\n      \"user\": user || null,\n      \"password\": password || null\n    };\n\n    setState(this.OPENED);\n  };\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function(state) {\n    disableHeaderCheck = state;\n  };\n\n  /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   * @return boolean Header added\n   */\n  this.setRequestHeader = function(header, value) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\");\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"');\n      return false;\n    }\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send flag is true\");\n    }\n    headers[header] = value;\n    return true;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function(header) {\n    if (typeof header === \"string\"\n      && this.readyState > this.OPENED\n      && response.headers[header.toLowerCase()]\n      && !errorFlag\n    ) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function() {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.substr(0, result.length - 2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function(name) {\n    // @TODO Make this case insensitive\n    if (typeof name === \"string\" && headers[name]) {\n      return headers[name];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function(data) {\n    if (this.readyState != this.OPENED) {\n      throw new Error(\"INVALID_STATE_ERR: connection must be opened before send() is called\");\n    }\n\n    if (sendFlag) {\n      throw new Error(\"INVALID_STATE_ERR: send has already been called\");\n    }\n\n    var ssl = false, local = false;\n    var url = Url.parse(settings.url);\n    var host;\n    // Determine the server\n    switch (url.protocol) {\n      case 'https:':\n        ssl = true;\n        // SSL & non-SSL both need host, no break here.\n      case 'http:':\n        host = url.hostname;\n        break;\n\n      case 'file:':\n        local = true;\n        break;\n\n      case undefined:\n      case '':\n        host = \"localhost\";\n        break;\n\n      default:\n        throw new Error(\"Protocol not supported.\");\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw new Error(\"XMLHttpRequest: Only GET method is supported\");\n      }\n\n      if (settings.async) {\n        fs.readFile(unescape(url.pathname), 'utf8', function(error, data) {\n          if (error) {\n            self.handleError(error, error.errno || -1);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(unescape(url.pathname), 'utf8');\n          this.status = 200;\n          setState(self.DONE);\n        } catch(e) {\n          this.handleError(e, e.errno || -1);\n        }\n      }\n\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (ssl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search ? url.search : '');\n\n    // Set the Host header or the server may reject the request\n    headers[\"Host\"] = host;\n    if (!((ssl && port === 443) || port === 80)) {\n      headers[\"Host\"] += ':' + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password == \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var agent = opts.agent || false;\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: agent\n    };\n\n    if (ssl) {\n      options.pfx = opts.pfx;\n      options.key = opts.key;\n      options.passphrase = opts.passphrase;\n      options.cert = opts.cert;\n      options.ca = opts.ca;\n      options.ciphers = opts.ciphers;\n      options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n    }\n\n    // Reset error flag\n    errorFlag = false;\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Handler for the response\n      var responseHandler = function(resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp;\n        // Check for redirect\n        // @TODO Prevent looped redirects\n        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url);\n          // Set host var in case it's used later\n          host = url.hostname;\n          // Options for the new request\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? 'GET' : settings.method,\n            headers: headers\n          };\n\n          if (ssl) {\n            newOptions.pfx = opts.pfx;\n            newOptions.key = opts.key;\n            newOptions.passphrase = opts.passphrase;\n            newOptions.cert = opts.cert;\n            newOptions.ca = opts.ca;\n            newOptions.ciphers = opts.ciphers;\n            newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;\n          }\n\n          // Issue the new request\n          request = doRequest(newOptions, responseHandler).on('error', errorHandler);\n          request.end();\n          // @TODO Check if an XHR event needs to be fired here\n          return;\n        }\n\n        if (response && response.setEncoding) {\n          response.setEncoding(\"utf8\");\n        }\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n\n        response.on('data', function(chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n\n        response.on('end', function() {\n          if (sendFlag) {\n            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\n            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\n            sendFlag = false;\n            // Discard the 'end' event if the connection has been aborted\n            setState(self.DONE);\n          }\n        });\n\n        response.on('error', function(error) {\n          self.handleError(error);\n        });\n      }\n\n      // Error handler for the request\n      var errorHandler = function(error) {\n        self.handleError(error);\n      }\n\n      // Create the request\n      request = doRequest(options, responseHandler).on('error', errorHandler);\n\n      if (opts.autoUnref) {\n        request.on('socket', (socket) => {\n          socket.unref();\n        });\n      }\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n\n      self.dispatchEvent(\"loadstart\");\n    } else { // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\n        + \"var options = \" + JSON.stringify(options) + \";\"\n        + \"var responseText = '';\"\n        + \"var req = doRequest(options, function(response) {\"\n        + \"response.setEncoding('utf8');\"\n        + \"response.on('data', function(chunk) {\"\n        + \"  responseText += chunk;\"\n        + \"});\"\n        + \"response.on('end', function() {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"response.on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"}).on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + (data ? \"req.write('\" + JSON.stringify(data).slice(1,-1).replace(/'/g, \"\\\\'\") + \"');\":\"\")\n        + \"req.end();\";\n      // Start the other Node Process, executing this string\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      var statusText;\n      while(fs.existsSync(syncFile)) {\n        // Wait while the sync file is empty\n      }\n      self.responseText = fs.readFileSync(contentFile, 'utf8');\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(contentFile);\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n        // If the file returned an error, handle it\n        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\n        self.handleError(errorObj, 503);\n      } else {\n        // If the file returned okay, parse its data and move to the DONE state\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\n        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   * @param  status  {number}    HTTP status code to use rather than the default (0) for XHR errors.\n   */\n  this.handleError = function(error, status) {\n    this.status = status || 0;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function() {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = Object.assign({}, defaultHeaders);\n    this.responseText = \"\";\n    this.responseXML = \"\";\n\n    errorFlag = abortedFlag = true\n    if (this.readyState !== this.UNSENT\n        && (this.readyState !== this.OPENED || sendFlag)\n        && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function(event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function(event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function(ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function(event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      if (this.readyState === this.DONE)\n        setImmediate(function() { self[\"on\" + event]() })\n      else\n        self[\"on\" + event]()\n    }\n    if (event in listeners) {\n      for (let i = 0, len = listeners[event].length; i < len; i++) {\n        if (this.readyState === this.DONE)\n          setImmediate(function() { listeners[event][i].call(self) })\n        else\n          listeners[event][i].call(self)\n      }\n    }\n  };\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function(state) {\n    if ((self.readyState === state) || (self.readyState === self.UNSENT && abortedFlag))\n      return\n\n    self.readyState = state;\n\n    if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n      self.dispatchEvent(\"readystatechange\");\n    }\n\n    if (self.readyState === self.DONE) {\n      let fire\n\n      if (abortedFlag)\n        fire = \"abort\"\n      else if (errorFlag)\n        fire = \"error\"\n      else\n        fire = \"load\"\n\n      self.dispatchEvent(fire)\n\n      // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n      self.dispatchEvent(\"loadend\");\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}