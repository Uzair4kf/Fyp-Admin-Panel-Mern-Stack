{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.rangeRequests = function (t, e, n) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:range-requests:5.1.4\"] && _();\n  } catch (t) {}\n\n  async function r(t, n) {\n    try {\n      if (206 === n.status) return n;\n      const r = t.headers.get(\"range\");\n      if (!r) throw new e.WorkboxError(\"no-range-header\");\n\n      const s = function (t) {\n        const n = t.trim().toLowerCase();\n        if (!n.startsWith(\"bytes=\")) throw new e.WorkboxError(\"unit-must-be-bytes\", {\n          normalizedRangeHeader: n\n        });\n        if (n.includes(\",\")) throw new e.WorkboxError(\"single-range-only\", {\n          normalizedRangeHeader: n\n        });\n        const r = /(\\d*)-(\\d*)/.exec(n);\n        if (!r || !r[1] && !r[2]) throw new e.WorkboxError(\"invalid-range-values\", {\n          normalizedRangeHeader: n\n        });\n        return {\n          start: \"\" === r[1] ? void 0 : Number(r[1]),\n          end: \"\" === r[2] ? void 0 : Number(r[2])\n        };\n      }(r),\n            a = await n.blob(),\n            o = function (t, n, r) {\n        const s = t.size;\n        if (r && r > s || n && n < 0) throw new e.WorkboxError(\"range-not-satisfiable\", {\n          size: s,\n          end: r,\n          start: n\n        });\n        let a, o;\n        return void 0 !== n && void 0 !== r ? (a = n, o = r + 1) : void 0 !== n && void 0 === r ? (a = n, o = s) : void 0 !== r && void 0 === n && (a = s - r, o = s), {\n          start: a,\n          end: o\n        };\n      }(a, s.start, s.end),\n            i = a.slice(o.start, o.end),\n            d = i.size,\n            u = new Response(i, {\n        status: 206,\n        statusText: \"Partial Content\",\n        headers: n.headers\n      });\n\n      return u.headers.set(\"Content-Length\", String(d)), u.headers.set(\"Content-Range\", `bytes ${o.start}-${o.end - 1}/` + a.size), u;\n    } catch (t) {\n      return new Response(\"\", {\n        status: 416,\n        statusText: \"Range Not Satisfiable\"\n      });\n    }\n  }\n\n  return t.RangeRequestsPlugin = class {\n    constructor() {\n      this.cachedResponseWillBeUsed = async ({\n        request: t,\n        cachedResponse: e\n      }) => e && t.headers.has(\"range\") ? await r(t, e) : e;\n    }\n\n  }, t.createPartialResponse = r, t;\n}({}, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.js","../createPartialResponse.js","../utils/parseRangeHeader.js","../utils/calculateEffectiveBoundaries.js","../RangeRequestsPlugin.js"],"names":["self","_","e","async","createPartialResponse","request","originalResponse","status","rangeHeader","headers","get","WorkboxError","boundaries","parseRangeHeader","originalBlob","blob","effectiveBoundaries","calculateEffectiveBoundaries","start","end","slicedBlob","slice","slicedBlobSize","size","slicedResponse","Response","statusText","set","String","error","normalizedRangeHeader","trim","toLowerCase","startsWith","includes","rangeParts","exec","undefined","Number","blobSize","effectiveStart","effectiveEnd","constructor","cachedResponseWillBeUsed","cachedResponse","has"],"mappings":"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","sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:range-requests:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { calculateEffectiveBoundaries } from './utils/calculateEffectiveBoundaries.js';\nimport { parseRangeHeader } from './utils/parseRangeHeader.js';\nimport './_version.js';\n/**\n * Given a `Request` and `Response` objects as input, this will return a\n * promise for a new `Response`.\n *\n * If the original `Response` already contains partial content (i.e. it has\n * a status of 206), then this assumes it already fulfills the `Range:`\n * requirements, and will return it as-is.\n *\n * @param {Request} request A request, which should contain a Range:\n * header.\n * @param {Response} originalResponse A response.\n * @return {Promise<Response>} Either a `206 Partial Content` response, with\n * the response body set to the slice of content specified by the request's\n * `Range:` header, or a `416 Range Not Satisfiable` response if the\n * conditions of the `Range:` header can't be met.\n *\n * @memberof module:workbox-range-requests\n */\nasync function createPartialResponse(request, originalResponse) {\n    try {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-range-requests',\n                funcName: 'createPartialResponse',\n                paramName: 'request',\n            });\n            assert.isInstance(originalResponse, Response, {\n                moduleName: 'workbox-range-requests',\n                funcName: 'createPartialResponse',\n                paramName: 'originalResponse',\n            });\n        }\n        if (originalResponse.status === 206) {\n            // If we already have a 206, then just pass it through as-is;\n            // see https://github.com/GoogleChrome/workbox/issues/1720\n            return originalResponse;\n        }\n        const rangeHeader = request.headers.get('range');\n        if (!rangeHeader) {\n            throw new WorkboxError('no-range-header');\n        }\n        const boundaries = parseRangeHeader(rangeHeader);\n        const originalBlob = await originalResponse.blob();\n        const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n        const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n        const slicedBlobSize = slicedBlob.size;\n        const slicedResponse = new Response(slicedBlob, {\n            // Status code 206 is for a Partial Content response.\n            // See https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\n            status: 206,\n            statusText: 'Partial Content',\n            headers: originalResponse.headers,\n        });\n        slicedResponse.headers.set('Content-Length', String(slicedBlobSize));\n        slicedResponse.headers.set('Content-Range', `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` +\n            originalBlob.size);\n        return slicedResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.warn(`Unable to construct a partial response; returning a ` +\n                `416 Range Not Satisfiable response instead.`);\n            logger.groupCollapsed(`View details here.`);\n            logger.log(error);\n            logger.log(request);\n            logger.log(originalResponse);\n            logger.groupEnd();\n        }\n        return new Response('', {\n            status: 416,\n            statusText: 'Range Not Satisfiable',\n        });\n    }\n}\nexport { createPartialResponse };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {string} rangeHeader A Range: header value.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the parsed value of the Range: header. If either the `start` or `end` are\n * omitted, then `null` will be returned.\n *\n * @private\n */\nfunction parseRangeHeader(rangeHeader) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isType(rangeHeader, 'string', {\n            moduleName: 'workbox-range-requests',\n            funcName: 'parseRangeHeader',\n            paramName: 'rangeHeader',\n        });\n    }\n    const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n    if (!normalizedRangeHeader.startsWith('bytes=')) {\n        throw new WorkboxError('unit-must-be-bytes', { normalizedRangeHeader });\n    }\n    // Specifying multiple ranges separate by commas is valid syntax, but this\n    // library only attempts to handle a single, contiguous sequence of bytes.\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range#Syntax\n    if (normalizedRangeHeader.includes(',')) {\n        throw new WorkboxError('single-range-only', { normalizedRangeHeader });\n    }\n    const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n    // We need either at least one of the start or end values.\n    if (!rangeParts || !(rangeParts[1] || rangeParts[2])) {\n        throw new WorkboxError('invalid-range-values', { normalizedRangeHeader });\n    }\n    return {\n        start: rangeParts[1] === '' ? undefined : Number(rangeParts[1]),\n        end: rangeParts[2] === '' ? undefined : Number(rangeParts[2]),\n    };\n}\nexport { parseRangeHeader };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport '../_version.js';\n/**\n * @param {Blob} blob A source blob.\n * @param {number} [start] The offset to use as the start of the\n * slice.\n * @param {number} [end] The offset to use as the end of the slice.\n * @return {Object} An object with `start` and `end` properties, reflecting\n * the effective boundaries to use given the size of the blob.\n *\n * @private\n */\nfunction calculateEffectiveBoundaries(blob, start, end) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(blob, Blob, {\n            moduleName: 'workbox-range-requests',\n            funcName: 'calculateEffectiveBoundaries',\n            paramName: 'blob',\n        });\n    }\n    const blobSize = blob.size;\n    if ((end && end > blobSize) || (start && start < 0)) {\n        throw new WorkboxError('range-not-satisfiable', {\n            size: blobSize,\n            end,\n            start,\n        });\n    }\n    let effectiveStart;\n    let effectiveEnd;\n    if (start !== undefined && end !== undefined) {\n        effectiveStart = start;\n        // Range values are inclusive, so add 1 to the value.\n        effectiveEnd = end + 1;\n    }\n    else if (start !== undefined && end === undefined) {\n        effectiveStart = start;\n        effectiveEnd = blobSize;\n    }\n    else if (end !== undefined && start === undefined) {\n        effectiveStart = blobSize - end;\n        effectiveEnd = blobSize;\n    }\n    return {\n        start: effectiveStart,\n        end: effectiveEnd,\n    };\n}\nexport { calculateEffectiveBoundaries };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createPartialResponse } from './createPartialResponse.js';\nimport './_version.js';\n/**\n * The range request plugin makes it easy for a request with a 'Range' header to\n * be fulfilled by a cached response.\n *\n * It does this by intercepting the `cachedResponseWillBeUsed` plugin callback\n * and returning the appropriate subset of the cached response body.\n *\n * @memberof module:workbox-range-requests\n */\nclass RangeRequestsPlugin {\n    constructor() {\n        /**\n         * @param {Object} options\n         * @param {Request} options.request The original request, which may or may not\n         * contain a Range: header.\n         * @param {Response} options.cachedResponse The complete cached response.\n         * @return {Promise<Response>} If request contains a 'Range' header, then a\n         * new response with status 206 whose body is a subset of `cachedResponse` is\n         * returned. Otherwise, `cachedResponse` is returned as-is.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ request, cachedResponse }) => {\n            // Only return a sliced response if there's something valid in the cache,\n            // and there's a Range: header in the request.\n            if (cachedResponse && request.headers.has('range')) {\n                return await createPartialResponse(request, cachedResponse);\n            }\n            // If there was no Range: header, or if cachedResponse wasn't valid, just\n            // pass it through as-is.\n            return cachedResponse;\n        };\n    }\n}\nexport { RangeRequestsPlugin };\n"]},"metadata":{},"sourceType":"script"}