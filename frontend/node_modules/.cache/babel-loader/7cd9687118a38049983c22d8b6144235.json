{"ast":null,"code":"try {\n  self[\"workbox:window:5.1.4\"] && _();\n} catch (n) {}\n\nfunction n(n, t) {\n  return new Promise(function (r) {\n    var e = new MessageChannel();\n    e.port1.onmessage = function (n) {\n      r(n.data);\n    }, n.postMessage(t, [e.port2]);\n  });\n}\n\nfunction t(n, t) {\n  for (var r = 0; r < t.length; r++) {\n    var e = t[r];\n    e.enumerable = e.enumerable || !1, e.configurable = !0, \"value\" in e && (e.writable = !0), Object.defineProperty(n, e.key, e);\n  }\n}\n\nfunction r(n, t) {\n  (null == t || t > n.length) && (t = n.length);\n\n  for (var r = 0, e = new Array(t); r < t; r++) e[r] = n[r];\n\n  return e;\n}\n\nfunction e(n, t) {\n  var e;\n\n  if (\"undefined\" == typeof Symbol || null == n[Symbol.iterator]) {\n    if (Array.isArray(n) || (e = function (n, t) {\n      if (n) {\n        if (\"string\" == typeof n) return r(n, t);\n        var e = Object.prototype.toString.call(n).slice(8, -1);\n        return \"Object\" === e && n.constructor && (e = n.constructor.name), \"Map\" === e || \"Set\" === e ? Array.from(n) : \"Arguments\" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? r(n, t) : void 0;\n      }\n    }(n)) || t && n && \"number\" == typeof n.length) {\n      e && (n = e);\n      var i = 0;\n      return function () {\n        return i >= n.length ? {\n          done: !0\n        } : {\n          done: !1,\n          value: n[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  return (e = n[Symbol.iterator]()).next.bind(e);\n}\n\ntry {\n  self[\"workbox:core:5.1.4\"] && _();\n} catch (n) {}\n\nvar i = function () {\n  var n = this;\n  this.promise = new Promise(function (t, r) {\n    n.resolve = t, n.reject = r;\n  });\n};\n\nfunction o(n, t) {\n  var r = location.href;\n  return new URL(n, r).href === new URL(t, r).href;\n}\n\nvar u = function (n, t) {\n  this.type = n, Object.assign(this, t);\n};\n\nfunction a(n, t, r) {\n  return r ? t ? t(n) : n : (n && n.then || (n = Promise.resolve(n)), t ? n.then(t) : n);\n}\n\nfunction c() {}\n\nvar f = function (r) {\n  var e, c;\n\n  function f(n, t) {\n    var e, c;\n    return void 0 === t && (t = {}), (e = r.call(this) || this).t = {}, e.i = 0, e.o = new i(), e.u = new i(), e.s = new i(), e.v = 0, e.h = new Set(), e.l = function () {\n      var n = e.m,\n          t = n.installing;\n      e.i > 0 || !o(t.scriptURL, e.g) || performance.now() > e.v + 6e4 ? (e.p = t, n.removeEventListener(\"updatefound\", e.l)) : (e.P = t, e.h.add(t), e.o.resolve(t)), ++e.i, t.addEventListener(\"statechange\", e.S);\n    }, e.S = function (n) {\n      var t = e.m,\n          r = n.target,\n          i = r.state,\n          o = r === e.p,\n          a = o ? \"external\" : \"\",\n          c = {\n        sw: r,\n        originalEvent: n\n      };\n      !o && e.j && (c.isUpdate = !0), e.dispatchEvent(new u(a + i, c)), \"installed\" === i ? e.A = self.setTimeout(function () {\n        \"installed\" === i && t.waiting === r && e.dispatchEvent(new u(a + \"waiting\", c));\n      }, 200) : \"activating\" === i && (clearTimeout(e.A), o || e.u.resolve(r));\n    }, e.O = function (n) {\n      var t = e.P;\n      t === navigator.serviceWorker.controller && (e.dispatchEvent(new u(\"controlling\", {\n        sw: t,\n        originalEvent: n,\n        isUpdate: e.j\n      })), e.s.resolve(t));\n    }, e.U = (c = function (n) {\n      var t = n.data,\n          r = n.source;\n      return a(e.getSW(), function () {\n        e.h.has(r) && e.dispatchEvent(new u(\"message\", {\n          data: t,\n          sw: r,\n          originalEvent: n\n        }));\n      });\n    }, function () {\n      for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];\n\n      try {\n        return Promise.resolve(c.apply(this, n));\n      } catch (n) {\n        return Promise.reject(n);\n      }\n    }), e.g = n, e.t = t, navigator.serviceWorker.addEventListener(\"message\", e.U), e;\n  }\n\n  c = r, (e = f).prototype = Object.create(c.prototype), e.prototype.constructor = e, e.__proto__ = c;\n  var v,\n      h,\n      l,\n      m = f.prototype;\n  return m.register = function (n) {\n    var t = (void 0 === n ? {} : n).immediate,\n        r = void 0 !== t && t;\n\n    try {\n      var e = this;\n      return function (n, t) {\n        var r = n();\n        if (r && r.then) return r.then(t);\n        return t(r);\n      }(function () {\n        if (!r && \"complete\" !== document.readyState) return s(new Promise(function (n) {\n          return window.addEventListener(\"load\", n);\n        }));\n      }, function () {\n        return e.j = Boolean(navigator.serviceWorker.controller), e.I = e.M(), a(e.R(), function (n) {\n          e.m = n, e.I && (e.P = e.I, e.u.resolve(e.I), e.s.resolve(e.I), e.I.addEventListener(\"statechange\", e.S, {\n            once: !0\n          }));\n          var t = e.m.waiting;\n          return t && o(t.scriptURL, e.g) && (e.P = t, Promise.resolve().then(function () {\n            e.dispatchEvent(new u(\"waiting\", {\n              sw: t,\n              wasWaitingBeforeRegister: !0\n            }));\n          }).then(function () {})), e.P && (e.o.resolve(e.P), e.h.add(e.P)), e.m.addEventListener(\"updatefound\", e.l), navigator.serviceWorker.addEventListener(\"controllerchange\", e.O, {\n            once: !0\n          }), e.m;\n        });\n      });\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, m.update = function () {\n    try {\n      return this.m ? s(this.m.update()) : void 0;\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, m.getSW = function () {\n    try {\n      return void 0 !== this.P ? this.P : this.o.promise;\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, m.messageSW = function (t) {\n    try {\n      return a(this.getSW(), function (r) {\n        return n(r, t);\n      });\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, m.M = function () {\n    var n = navigator.serviceWorker.controller;\n    return n && o(n.scriptURL, this.g) ? n : void 0;\n  }, m.R = function () {\n    try {\n      var n = this;\n      return function (n, t) {\n        try {\n          var r = n();\n        } catch (n) {\n          return t(n);\n        }\n\n        if (r && r.then) return r.then(void 0, t);\n        return r;\n      }(function () {\n        return a(navigator.serviceWorker.register(n.g, n.t), function (t) {\n          return n.v = performance.now(), t;\n        });\n      }, function (n) {\n        throw n;\n      });\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, v = f, (h = [{\n    key: \"active\",\n    get: function () {\n      return this.u.promise;\n    }\n  }, {\n    key: \"controlling\",\n    get: function () {\n      return this.s.promise;\n    }\n  }]) && t(v.prototype, h), l && t(v, l), f;\n}(function () {\n  function n() {\n    this.k = new Map();\n  }\n\n  var t = n.prototype;\n  return t.addEventListener = function (n, t) {\n    this.B(n).add(t);\n  }, t.removeEventListener = function (n, t) {\n    this.B(n).delete(t);\n  }, t.dispatchEvent = function (n) {\n    n.target = this;\n\n    for (var t, r = e(this.B(n.type)); !(t = r()).done;) {\n      (0, t.value)(n);\n    }\n  }, t.B = function (n) {\n    return this.k.has(n) || this.k.set(n, new Set()), this.k.get(n);\n  }, n;\n}());\n\nfunction s(n, t) {\n  if (!t) return n && n.then ? n.then(c) : Promise.resolve();\n}\n\nexport { f as Workbox, n as messageSW };","map":{"version":3,"sources":["../_version.js","../messageSW.js","../../workbox-core/_version.js","../../workbox-core/_private/Deferred.js","../utils/urlsMatch.js","../utils/WorkboxEvent.js","../Workbox.js","../../workbox-core/_private/dontWaitFor.js","../utils/WorkboxEventTarget.js"],"names":["self","_","e","messageSW","sw","data","Promise","resolve","messageChannel","MessageChannel","port1","onmessage","event","postMessage","port2","Deferred","promise","reject","_this","urlsMatch","url1","url2","href","location","URL","WorkboxEvent","type","props","Object","assign","this","Workbox","scriptURL","registerOptions","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_registrationTime","_ownSWs","Set","_onUpdateFound","registration","_registration","installingSW","installing","f","args","i","arguments","length","apply","_await","value","then","direct","_scriptURL","performance","now","_externalSW","removeEventListener","_sw","add","addEventListener","_onStateChange","originalEvent","target","state","isExternal","eventPrefix","eventProps","_isUpdate","isUpdate","dispatchEvent","_waitingTimeout","setTimeout","waiting","clearTimeout","_onControllerChange","navigator","serviceWorker","controller","_onMessage","source","getSW","has","register","immediate","document","readyState","res","window","Boolean","_compatibleControllingSW","_this3","_getControllingSWIfCompatible","_registerScript","once","waitingSW","wasWaitingBeforeRegister","update","undefined","reg","_this11","error","body","result","recover","_empty","_eventListenerRegistry","Map","listener","_getEventListenersByType","delete","set","get"],"mappings":"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","sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:window:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n * @memberof module:workbox-window\n */\nfunction messageSW(sw, data) {\n    return new Promise((resolve) => {\n        const messageChannel = new MessageChannel();\n        messageChannel.port1.onmessage = (event) => {\n            resolve(event.data);\n        };\n        sw.postMessage(data, [messageChannel.port2]);\n    });\n}\nexport { messageSW };\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nexport { Deferred };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nexport function urlsMatch(url1, url2) {\n    const { href } = location;\n    return new URL(url1, href).href === new URL(url2, href).href;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nexport class WorkboxEvent {\n    constructor(type, props) {\n        this.type = type;\n        Object.assign(this, props);\n    }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { messageSW } from './messageSW.js';\nimport { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';\nimport { urlsMatch } from './utils/urlsMatch.js';\nimport { WorkboxEvent } from './utils/WorkboxEvent.js';\nimport './_version.js';\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n * @memberof module:workbox-window\n */\nclass Workbox extends WorkboxEventTarget {\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n     *\n     * @param {string} scriptURL The service worker script associated with this\n     *     instance.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n    constructor(scriptURL, registerOptions = {}) {\n        super();\n        this._registerOptions = {};\n        this._updateFoundCount = 0;\n        // Deferreds we can resolve later.\n        this._swDeferred = new Deferred();\n        this._activeDeferred = new Deferred();\n        this._controllingDeferred = new Deferred();\n        this._registrationTime = 0;\n        this._ownSWs = new Set();\n        /**\n         * @private\n         */\n        this._onUpdateFound = () => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const installingSW = registration.installing;\n            // If the script URL passed to `navigator.serviceWorker.register()` is\n            // different from the current controlling SW's script URL, we know any\n            // successful registration calls will trigger an `updatefound` event.\n            // But if the registered script URL is the same as the current controlling\n            // SW's script URL, we'll only get an `updatefound` event if the file\n            // changed since it was last registered. This can be a problem if the user\n            // opens up the same page in a different tab, and that page registers\n            // a SW that triggers an update. It's a problem because this page has no\n            // good way of knowing whether the `updatefound` event came from the SW\n            // script it registered or from a registration attempt made by a newer\n            // version of the page running in another tab.\n            // To minimize the possibility of a false positive, we use the logic here:\n            const updateLikelyTriggeredExternally = \n            // Since we enforce only calling `register()` once, and since we don't\n            // add the `updatefound` event listener until the `register()` call, if\n            // `_updateFoundCount` is > 0 then it means this method has already\n            // been called, thus this SW must be external\n            this._updateFoundCount > 0 ||\n                // If the script URL of the installing SW is different from this\n                // instance's script URL, we know it's definitely not from our\n                // registration.\n                !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n                // If all of the above are false, then we use a time-based heuristic:\n                // Any `updatefound` event that occurs long after our registration is\n                // assumed to be external.\n                (performance.now() >\n                    this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n            if (updateLikelyTriggeredExternally) {\n                this._externalSW = installingSW;\n                registration.removeEventListener('updatefound', this._onUpdateFound);\n            }\n            else {\n                // If the update was not triggered externally we know the installing\n                // SW is the one we registered, so we set it.\n                this._sw = installingSW;\n                this._ownSWs.add(installingSW);\n                this._swDeferred.resolve(installingSW);\n                // The `installing` state isn't something we have a dedicated\n                // callback for, but we do log messages for it in development.\n                if (process.env.NODE_ENV !== 'production') {\n                    if (navigator.serviceWorker.controller) {\n                        logger.log('Updated service worker found. Installing now...');\n                    }\n                    else {\n                        logger.log('Service worker is installing...');\n                    }\n                }\n            }\n            // Increment the `updatefound` count, so future invocations of this\n            // method can be sure they were triggered externally.\n            ++this._updateFoundCount;\n            // Add a `statechange` listener regardless of whether this update was\n            // triggered externally, since we have callbacks for both.\n            installingSW.addEventListener('statechange', this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onStateChange = (originalEvent) => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const sw = originalEvent.target;\n            const { state } = sw;\n            const isExternal = sw === this._externalSW;\n            const eventPrefix = isExternal ? 'external' : '';\n            const eventProps = {\n                sw,\n                originalEvent\n            };\n            if (!isExternal && this._isUpdate) {\n                eventProps.isUpdate = true;\n            }\n            this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n            if (state === 'installed') {\n                // This timeout is used to ignore cases where the service worker calls\n                // `skipWaiting()` in the install event, thus moving it directly in the\n                // activating state. (Since all service workers *must* go through the\n                // waiting phase, the only way to detect `skipWaiting()` called in the\n                // install event is to observe that the time spent in the waiting phase\n                // is very short.)\n                // NOTE: we don't need separate timeouts for the own and external SWs\n                // since they can't go through these phases at the same time.\n                this._waitingTimeout = self.setTimeout(() => {\n                    // Ensure the SW is still waiting (it may now be redundant).\n                    if (state === 'installed' && registration.waiting === sw) {\n                        this.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n                        if (process.env.NODE_ENV !== 'production') {\n                            if (isExternal) {\n                                logger.warn('An external service worker has installed but is ' +\n                                    'waiting for this client to close before activating...');\n                            }\n                            else {\n                                logger.warn('The service worker has installed but is waiting ' +\n                                    'for existing clients to close before activating...');\n                            }\n                        }\n                    }\n                }, WAITING_TIMEOUT_DURATION);\n            }\n            else if (state === 'activating') {\n                clearTimeout(this._waitingTimeout);\n                if (!isExternal) {\n                    this._activeDeferred.resolve(sw);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                switch (state) {\n                    case 'installed':\n                        if (isExternal) {\n                            logger.warn('An external service worker has installed. ' +\n                                'You may want to suggest users reload this page.');\n                        }\n                        else {\n                            logger.log('Registered service worker installed.');\n                        }\n                        break;\n                    case 'activated':\n                        if (isExternal) {\n                            logger.warn('An external service worker has activated.');\n                        }\n                        else {\n                            logger.log('Registered service worker activated.');\n                            if (sw !== navigator.serviceWorker.controller) {\n                                logger.warn('The registered service worker is active but ' +\n                                    'not yet controlling the page. Reload or run ' +\n                                    '`clients.claim()` in the service worker.');\n                            }\n                        }\n                        break;\n                    case 'redundant':\n                        if (sw === this._compatibleControllingSW) {\n                            logger.log('Previously controlling service worker now redundant!');\n                        }\n                        else if (!isExternal) {\n                            logger.log('Registered service worker now redundant!');\n                        }\n                        break;\n                }\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onControllerChange = (originalEvent) => {\n            const sw = this._sw;\n            if (sw === navigator.serviceWorker.controller) {\n                this.dispatchEvent(new WorkboxEvent('controlling', {\n                    sw,\n                    originalEvent,\n                    isUpdate: this._isUpdate,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log('Registered service worker now controlling this page.');\n                }\n                this._controllingDeferred.resolve(sw);\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onMessage = async (originalEvent) => {\n            const { data, source } = originalEvent;\n            // Wait until there's an \"own\" service worker. This is used to buffer\n            // `message` events that may be received prior to calling `register()`.\n            await this.getSW();\n            // If the service worker that sent the message is in the list of own\n            // service workers for this instance, dispatch a `message` event.\n            // NOTE: we check for all previously owned service workers rather than\n            // just the current one because some messages (e.g. cache updates) use\n            // a timeout when sent and may be delayed long enough for a service worker\n            // update to be found.\n            if (this._ownSWs.has(source)) {\n                this.dispatchEvent(new WorkboxEvent('message', {\n                    data,\n                    sw: source,\n                    originalEvent,\n                }));\n            }\n        };\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n        navigator.serviceWorker.addEventListener('message', this._onMessage);\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n    async register({ immediate = false } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._registrationTime) {\n                logger.error('Cannot re-register a Workbox instance after it has ' +\n                    'been registered. Create a new instance instead.');\n                return;\n            }\n        }\n        if (!immediate && document.readyState !== 'complete') {\n            await new Promise((res) => window.addEventListener('load', res));\n        }\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        // If we have a compatible controller, store the controller as the \"own\"\n        // SW, resolve active/controlling deferreds and add necessary listeners.\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });\n        }\n        // If there's a waiting service worker with a matching URL before the\n        // `updatefound` event fires, it likely means that this site is open\n        // in another tab, or the user refreshed the page (and thus the previous\n        // page wasn't fully unloaded before this page started loading).\n        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n        const waitingSW = this._registration.waiting;\n        if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            this._sw = waitingSW;\n            // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n            dontWaitFor(Promise.resolve().then(() => {\n                this.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn('A service worker was already waiting to activate ' +\n                        'before this script was registered...');\n                }\n            }));\n        }\n        // If an \"own\" SW is already set, resolve the deferred.\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log('Successfully registered service worker.', this._scriptURL);\n            if (navigator.serviceWorker.controller) {\n                if (this._compatibleControllingSW) {\n                    logger.debug('A service worker with the same script URL ' +\n                        'is already controlling this page.');\n                }\n                else {\n                    logger.debug('A service worker with a different script URL is ' +\n                        'currently controlling the page. The browser is now fetching ' +\n                        'the new script now...');\n                }\n            }\n            const currentPageIsOutOfScope = () => {\n                const scopeURL = new URL(this._registerOptions.scope || this._scriptURL, document.baseURI);\n                const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n                return !location.pathname.startsWith(scopeURLBasePath);\n            };\n            if (currentPageIsOutOfScope()) {\n                logger.warn('The current page is not in scope for the registered ' +\n                    'service worker. Was this a mistake?');\n            }\n        }\n        this._registration.addEventListener('updatefound', this._onUpdateFound);\n        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange, { once: true });\n        return this._registration;\n    }\n    /**\n     * Checks for updates of the registered service worker.\n     */\n    async update() {\n        if (!this._registration) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error('Cannot update a Workbox instance without ' +\n                    'being registered. Register the Workbox instance first.');\n            }\n            return;\n        }\n        // Try to update registration\n        await this._registration.update();\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    async getSW() {\n        // If `this._sw` is set, resolve with that as we want `getSW()` to\n        // return the correct (new) service worker if an update is found.\n        return this._sw !== undefined ? this._sw : this._swDeferred.promise;\n    }\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matches.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n            return controller;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n    async _registerScript() {\n        try {\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            // Keep track of when registration happened, so it can be used in the\n            // `this._onUpdateFound` heuristic. Also use the presence of this\n            // property as a way to see if `.register()` has been called.\n            this._registrationTime = performance.now();\n            return reg;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(error);\n            }\n            // Re-throw the error.\n            throw error;\n        }\n    }\n}\nexport { Workbox };\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    promise.then(() => { });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nexport class WorkboxEventTarget {\n    constructor() {\n        this._eventListenerRegistry = new Map();\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    addEventListener(type, listener) {\n        const foo = this._getEventListenersByType(type);\n        foo.add(listener);\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n    }\n    /**\n     * @param {Object} event\n     * @private\n     */\n    dispatchEvent(event) {\n        event.target = this;\n        const listeners = this._getEventListenersByType(event.type);\n        for (const listener of listeners) {\n            listener(event);\n        }\n    }\n    /**\n     * Returns a Set of listeners associated with the passed event type.\n     * If no handlers have been registered, an empty Set is returned.\n     *\n     * @param {string} type The event type.\n     * @return {Set<ListenerCallback>} An array of handler functions.\n     * @private\n     */\n    _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n            this._eventListenerRegistry.set(type, new Set());\n        }\n        return this._eventListenerRegistry.get(type);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}