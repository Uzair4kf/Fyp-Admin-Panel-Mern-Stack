{"ast":null,"code":"'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\n\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      const a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      const o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\n\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      const value = toJSON(this.value, stringKey, ctx);\n      if (stringKey in map) Object.defineProperty(map, stringKey, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });else map[stringKey] = value;\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (!explicitKey && str.length > 1024) {\n      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n      explicitKey = true;\n    }\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow && !explicitKey ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    } else if (valueStr[0] === '\\n') ws = '';\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\n\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\n\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n          Object.defineProperty(map, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n  let escStart = -1;\n  let escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (fold === 0) res = `\\n${indent}${text.slice(0, end)}`;else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n      res += `\\n${indent}${text.slice(fold + 1, end)}`;\n    }\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  const limit = lineWidth - indentLength;\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\n\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\n\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\n\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n} // on error, will return { str: string, errors: Error[] }\n\n\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/yaml/dist/resolveSeq-d03cb037.js"],"names":["PlainValue","require","addCommentBefore","str","indent","comment","cc","replace","addComment","indexOf","Node","toJSON","value","arg","ctx","Array","isArray","map","v","i","String","anchor","anchors","get","onCreate","res","keep","Number","Scalar","constructor","toString","collectionFromPath","schema","path","length","k","isInteger","a","o","Object","defineProperty","writable","enumerable","configurable","createNode","isEmptyPath","Symbol","iterator","next","done","Collection","_defineProperty","addIn","add","key","rest","node","undefined","set","Error","deleteIn","delete","getIn","keepScalar","hasAllNullValues","items","every","type","n","commentBefore","tag","hasIn","has","setIn","blockItem","flowChars","isMap","itemIndent","onComment","onChompKeep","indentStep","stringify","inFlow","Type","FLOW_MAP","FLOW_SEQ","allNullValues","assign","chompKeep","hasItemWithNewLine","nodes","reduce","item","spaceBefore","push","match","forEach","line","includes","start","end","strings","sum","maxFlowStringSingleLineLength","s","join","shift","asItemIndex","idx","YAMLSeq","del","splice","it","_","seq","JSON","stringifyKey","jsKey","doc","create","inStringifyKey","Pair","PAIR","cb","msg","addToJSMap","Map","Set","stringKey","pair","mapAsMap","indentSize","indentSeq","simpleKeys","options","keyComment","explicitKey","BLOCK_FOLDED","BLOCK_LITERAL","implicitKey","vcb","valueComment","cs","indentAtStart","getName","substr","valueStr","ws","flow","MERGE_PAIR","getAliasCount","Alias","source","count","aliasCount","c","kc","vc","Math","max","range","keys","find","newName","ALIAS","t","maxAliasCount","cstNode","YAMLReferenceError","ReferenceError","findPair","YAMLMap","overwrite","prev","sortEntries","sortMapEntries","findIndex","MERGE_KEY","Merge","srcMap","prototype","hasOwnProperty","call","binaryOptions","defaultType","lineWidth","boolOptions","trueStr","falseStr","intOptions","asBigInt","nullOptions","nullStr","strOptions","PLAIN","doubleQuoted","jsonEncoding","minMultiLineLength","fold","minContentWidth","resolveScalar","tags","scalarFallback","format","test","resolve","apply","FOLD_FLOW","FOLD_BLOCK","FOLD_QUOTED","consumeMoreIndentedLines","text","ch","foldFlowLines","mode","onFold","onOverflow","endStep","folds","escapedFolds","split","overflow","escStart","escEnd","j","slice","getFoldOptions","containsDocumentMarker","lineLengthOverLimit","indentLength","limit","strLen","doubleQuotedString","json","code","singleQuotedString","blockString","forceBlockIndent","literal","header","wsStart","wsEnd","m","body","plainString","actualString","resolved","stringifyString","_stringify","_type","QUOTE_DOUBLE","QUOTE_SINGLE","stringifyNumber","minFractionDigits","isFinite","isNaN","d","checkFlowCollectionEnd","errors","cst","char","name","YAMLSemanticError","lastItem","COMMENT","err","offset","checkFlowCommentSpace","context","src","getLongKeyError","sk","resolveComments","collection","comments","afterKey","before","resolveString","strValue","error","resolveTagHandle","handle","suffix","prefix","tagPrefixes","p","dtp","getDefaults","version","warnings","YAMLWarning","vocab","decodeURIComponent","resolveTagName","nonSpecific","verbatim","defaultTags","STR","MAP","SEQ","resolveByTagName","tagName","matchWithTest","getFallbackTagName","resolveTag","fallback","refError","message","stack","isCollectionItem","MAP_KEY","MAP_VALUE","SEQ_ITEM","resolveNodeProps","after","hasAnchor","hasTag","props","parent","concat","Char","commentHasRequiredWhitespace","valueRange","ANCHOR","TAG","resolveNodeValue","rawValue","getNode","_cstAliases","YAMLSyntaxError","resolveNode","keepCstNodes","keepNodeTypes","ca","resolveMap","resolveFlowMapItems","resolveBlockMapItems","hasCollectionKey","iKey","merge","sources","some","jKey","warn","valueHasPairComment","lineStart","resolvePairComment","getPropValue","found","startsWith","keyStart","BLANK_LINE","atLineStart","valueNode","pos","origStart","origPos","origEnd","nextItem","valueRangeContainsNewline","resolveSeq","resolveFlowSeqItems","resolveBlockSeqItems","hasProps","prevItem","pop","keyEnd","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nfunction addCommentBefore(str, indent, comment) {\n  if (!comment) return str;\n  const cc = comment.replace(/[\\s\\S]^/gm, `$&${indent}#`);\n  return `#${cc}\\n${indent}${str}`;\n}\nfunction addComment(str, indent, comment) {\n  return !comment ? str : comment.indexOf('\\n') === -1 ? `${str} #${comment}` : `${str}\\n` + comment.replace(/^/gm, `${indent || ''}#`);\n}\n\nclass Node {}\n\nfunction toJSON(value, arg, ctx) {\n  if (Array.isArray(value)) return value.map((v, i) => toJSON(v, String(i), ctx));\n\n  if (value && typeof value.toJSON === 'function') {\n    const anchor = ctx && ctx.anchors && ctx.anchors.get(value);\n    if (anchor) ctx.onCreate = res => {\n      anchor.res = res;\n      delete ctx.onCreate;\n    };\n    const res = value.toJSON(arg, ctx);\n    if (anchor && ctx.onCreate) ctx.onCreate(res);\n    return res;\n  }\n\n  if ((!ctx || !ctx.keep) && typeof value === 'bigint') return Number(value);\n  return value;\n}\n\nclass Scalar extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  toJSON(arg, ctx) {\n    return ctx && ctx.keep ? this.value : toJSON(this.value, arg, ctx);\n  }\n\n  toString() {\n    return String(this.value);\n  }\n\n}\n\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n\n    if (Number.isInteger(k) && k >= 0) {\n      const a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      const o = {};\n      Object.defineProperty(o, k, {\n        value: v,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n      v = o;\n    }\n  }\n\n  return schema.createNode(v, false);\n} // null, undefined, or an empty non-string iterable (e.g. [])\n\n\nconst isEmptyPath = path => path == null || typeof path === 'object' && path[Symbol.iterator]().next().done;\nclass Collection extends Node {\n  constructor(schema) {\n    super();\n\n    PlainValue._defineProperty(this, \"items\", []);\n\n    this.schema = schema;\n  }\n\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n\n  deleteIn([key, ...rest]) {\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (node instanceof Collection) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n\n  getIn([key, ...rest], keepScalar) {\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && node instanceof Scalar ? node.value : node;else return node instanceof Collection ? node.getIn(rest, keepScalar) : undefined;\n  }\n\n  hasAllNullValues() {\n    return this.items.every(node => {\n      if (!node || node.type !== 'PAIR') return false;\n      const n = node.value;\n      return n == null || n instanceof Scalar && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n\n  hasIn([key, ...rest]) {\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return node instanceof Collection ? node.hasIn(rest) : false;\n  }\n\n  setIn([key, ...rest], value) {\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (node instanceof Collection) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  } // overridden in implementations\n\n  /* istanbul ignore next */\n\n\n  toJSON() {\n    return null;\n  }\n\n  toString(ctx, {\n    blockItem,\n    flowChars,\n    isMap,\n    itemIndent\n  }, onComment, onChompKeep) {\n    const {\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    const inFlow = this.type === PlainValue.Type.FLOW_MAP || this.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow;\n    if (inFlow) itemIndent += indentStep;\n    const allNullValues = isMap && this.hasAllNullValues();\n    ctx = Object.assign({}, ctx, {\n      allNullValues,\n      indent: itemIndent,\n      inFlow,\n      type: null\n    });\n    let chompKeep = false;\n    let hasItemWithNewLine = false;\n    const nodes = this.items.reduce((nodes, item, i) => {\n      let comment;\n\n      if (item) {\n        if (!chompKeep && item.spaceBefore) nodes.push({\n          type: 'comment',\n          str: ''\n        });\n        if (item.commentBefore) item.commentBefore.match(/^.*$/gm).forEach(line => {\n          nodes.push({\n            type: 'comment',\n            str: `#${line}`\n          });\n        });\n        if (item.comment) comment = item.comment;\n        if (inFlow && (!chompKeep && item.spaceBefore || item.commentBefore || item.comment || item.key && (item.key.commentBefore || item.key.comment) || item.value && (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = true;\n      }\n\n      chompKeep = false;\n      let str = stringify(item, ctx, () => comment = null, () => chompKeep = true);\n      if (inFlow && !hasItemWithNewLine && str.includes('\\n')) hasItemWithNewLine = true;\n      if (inFlow && i < this.items.length - 1) str += ',';\n      str = addComment(str, itemIndent, comment);\n      if (chompKeep && (comment || inFlow)) chompKeep = false;\n      nodes.push({\n        type: 'item',\n        str\n      });\n      return nodes;\n    }, []);\n    let str;\n\n    if (nodes.length === 0) {\n      str = flowChars.start + flowChars.end;\n    } else if (inFlow) {\n      const {\n        start,\n        end\n      } = flowChars;\n      const strings = nodes.map(n => n.str);\n\n      if (hasItemWithNewLine || strings.reduce((sum, str) => sum + str.length + 2, 2) > Collection.maxFlowStringSingleLineLength) {\n        str = start;\n\n        for (const s of strings) {\n          str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\n        }\n\n        str += `\\n${indent}${end}`;\n      } else {\n        str = `${start} ${strings.join(' ')} ${end}`;\n      }\n    } else {\n      const strings = nodes.map(blockItem);\n      str = strings.shift();\n\n      for (const s of strings) str += s ? `\\n${indent}${s}` : '\\n';\n    }\n\n    if (this.comment) {\n      str += '\\n' + this.comment.replace(/^/gm, `${indent}#`);\n      if (onComment) onComment();\n    } else if (chompKeep && onChompKeep) onChompKeep();\n\n    return str;\n  }\n\n}\n\nPlainValue._defineProperty(Collection, \"maxFlowStringSingleLineLength\", 60);\n\nfunction asItemIndex(key) {\n  let idx = key instanceof Scalar ? key.value : key;\n  if (idx && typeof idx === 'string') idx = Number(idx);\n  return Number.isInteger(idx) && idx >= 0 ? idx : null;\n}\n\nclass YAMLSeq extends Collection {\n  add(value) {\n    this.items.push(value);\n  }\n\n  delete(key) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return false;\n    const del = this.items.splice(idx, 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') return undefined;\n    const it = this.items[idx];\n    return !keepScalar && it instanceof Scalar ? it.value : it;\n  }\n\n  has(key) {\n    const idx = asItemIndex(key);\n    return typeof idx === 'number' && idx < this.items.length;\n  }\n\n  set(key, value) {\n    const idx = asItemIndex(key);\n    if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);\n    this.items[idx] = value;\n  }\n\n  toJSON(_, ctx) {\n    const seq = [];\n    if (ctx && ctx.onCreate) ctx.onCreate(seq);\n    let i = 0;\n\n    for (const item of this.items) seq.push(toJSON(item, String(i++), ctx));\n\n    return seq;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    return super.toString(ctx, {\n      blockItem: n => n.type === 'comment' ? n.str : `- ${n.str}`,\n      flowChars: {\n        start: '[',\n        end: ']'\n      },\n      isMap: false,\n      itemIndent: (ctx.indent || '') + '  '\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst stringifyKey = (key, jsKey, ctx) => {\n  if (jsKey === null) return '';\n  if (typeof jsKey !== 'object') return String(jsKey);\n  if (key instanceof Node && ctx && ctx.doc) return key.toString({\n    anchors: Object.create(null),\n    doc: ctx.doc,\n    indent: '',\n    indentStep: ctx.indentStep,\n    inFlow: true,\n    inStringifyKey: true,\n    stringify: ctx.stringify\n  });\n  return JSON.stringify(jsKey);\n};\n\nclass Pair extends Node {\n  constructor(key, value = null) {\n    super();\n    this.key = key;\n    this.value = value;\n    this.type = Pair.Type.PAIR;\n  }\n\n  get commentBefore() {\n    return this.key instanceof Node ? this.key.commentBefore : undefined;\n  }\n\n  set commentBefore(cb) {\n    if (this.key == null) this.key = new Scalar(null);\n    if (this.key instanceof Node) this.key.commentBefore = cb;else {\n      const msg = 'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.';\n      throw new Error(msg);\n    }\n  }\n\n  addToJSMap(ctx, map) {\n    const key = toJSON(this.key, '', ctx);\n\n    if (map instanceof Map) {\n      const value = toJSON(this.value, key, ctx);\n      map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else {\n      const stringKey = stringifyKey(this.key, key, ctx);\n      const value = toJSON(this.value, stringKey, ctx);\n      if (stringKey in map) Object.defineProperty(map, stringKey, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });else map[stringKey] = value;\n    }\n\n    return map;\n  }\n\n  toJSON(_, ctx) {\n    const pair = ctx && ctx.mapAsMap ? new Map() : {};\n    return this.addToJSMap(ctx, pair);\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx || !ctx.doc) return JSON.stringify(this);\n    const {\n      indent: indentSize,\n      indentSeq,\n      simpleKeys\n    } = ctx.doc.options;\n    let {\n      key,\n      value\n    } = this;\n    let keyComment = key instanceof Node && key.comment;\n\n    if (simpleKeys) {\n      if (keyComment) {\n        throw new Error('With simple keys, key nodes cannot have comments');\n      }\n\n      if (key instanceof Collection) {\n        const msg = 'With simple keys, collection cannot be used as a key value';\n        throw new Error(msg);\n      }\n    }\n\n    let explicitKey = !simpleKeys && (!key || keyComment || (key instanceof Node ? key instanceof Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : typeof key === 'object'));\n    const {\n      doc,\n      indent,\n      indentStep,\n      stringify\n    } = ctx;\n    ctx = Object.assign({}, ctx, {\n      implicitKey: !explicitKey,\n      indent: indent + indentStep\n    });\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => keyComment = null, () => chompKeep = true);\n    str = addComment(str, ctx.indent, keyComment);\n\n    if (!explicitKey && str.length > 1024) {\n      if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n      explicitKey = true;\n    }\n\n    if (ctx.allNullValues && !simpleKeys) {\n      if (this.comment) {\n        str = addComment(str, ctx.indent, this.comment);\n        if (onComment) onComment();\n      } else if (chompKeep && !keyComment && onChompKeep) onChompKeep();\n\n      return ctx.inFlow && !explicitKey ? str : `? ${str}`;\n    }\n\n    str = explicitKey ? `? ${str}\\n${indent}:` : `${str}:`;\n\n    if (this.comment) {\n      // expected (but not strictly required) to be a single-line comment\n      str = addComment(str, ctx.indent, this.comment);\n      if (onComment) onComment();\n    }\n\n    let vcb = '';\n    let valueComment = null;\n\n    if (value instanceof Node) {\n      if (value.spaceBefore) vcb = '\\n';\n\n      if (value.commentBefore) {\n        const cs = value.commentBefore.replace(/^/gm, `${ctx.indent}#`);\n        vcb += `\\n${cs}`;\n      }\n\n      valueComment = value.comment;\n    } else if (value && typeof value === 'object') {\n      value = doc.schema.createNode(value, true);\n    }\n\n    ctx.implicitKey = false;\n    if (!explicitKey && !this.comment && value instanceof Scalar) ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n\n    if (!indentSeq && indentSize >= 2 && !ctx.inFlow && !explicitKey && value instanceof YAMLSeq && value.type !== PlainValue.Type.FLOW_SEQ && !value.tag && !doc.anchors.getName(value)) {\n      // If indentSeq === false, consider '- ' as part of indentation where possible\n      ctx.indent = ctx.indent.substr(2);\n    }\n\n    const valueStr = stringify(value, ctx, () => valueComment = null, () => chompKeep = true);\n    let ws = ' ';\n\n    if (vcb || this.comment) {\n      ws = `${vcb}\\n${ctx.indent}`;\n    } else if (!explicitKey && value instanceof Collection) {\n      const flow = valueStr[0] === '[' || valueStr[0] === '{';\n      if (!flow || valueStr.includes('\\n')) ws = `\\n${ctx.indent}`;\n    } else if (valueStr[0] === '\\n') ws = '';\n\n    if (chompKeep && !valueComment && onChompKeep) onChompKeep();\n    return addComment(str + ws + valueStr, ctx.indent, valueComment);\n  }\n\n}\n\nPlainValue._defineProperty(Pair, \"Type\", {\n  PAIR: 'PAIR',\n  MERGE_PAIR: 'MERGE_PAIR'\n});\n\nconst getAliasCount = (node, anchors) => {\n  if (node instanceof Alias) {\n    const anchor = anchors.get(node.source);\n    return anchor.count * anchor.aliasCount;\n  } else if (node instanceof Collection) {\n    let count = 0;\n\n    for (const item of node.items) {\n      const c = getAliasCount(item, anchors);\n      if (c > count) count = c;\n    }\n\n    return count;\n  } else if (node instanceof Pair) {\n    const kc = getAliasCount(node.key, anchors);\n    const vc = getAliasCount(node.value, anchors);\n    return Math.max(kc, vc);\n  }\n\n  return 1;\n};\n\nclass Alias extends Node {\n  static stringify({\n    range,\n    source\n  }, {\n    anchors,\n    doc,\n    implicitKey,\n    inStringifyKey\n  }) {\n    let anchor = Object.keys(anchors).find(a => anchors[a] === source);\n    if (!anchor && inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName();\n    if (anchor) return `*${anchor}${implicitKey ? ' ' : ''}`;\n    const msg = doc.anchors.getName(source) ? 'Alias node must be after source node' : 'Source node not found for alias node';\n    throw new Error(`${msg} [${range}]`);\n  }\n\n  constructor(source) {\n    super();\n    this.source = source;\n    this.type = PlainValue.Type.ALIAS;\n  }\n\n  set tag(t) {\n    throw new Error('Alias nodes cannot have tags');\n  }\n\n  toJSON(arg, ctx) {\n    if (!ctx) return toJSON(this.source, arg, ctx);\n    const {\n      anchors,\n      maxAliasCount\n    } = ctx;\n    const anchor = anchors.get(this.source);\n    /* istanbul ignore if */\n\n    if (!anchor || anchor.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n    }\n\n    if (maxAliasCount >= 0) {\n      anchor.count += 1;\n      if (anchor.aliasCount === 0) anchor.aliasCount = getAliasCount(this.source, anchors);\n\n      if (anchor.count * anchor.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        if (this.cstNode) throw new PlainValue.YAMLReferenceError(this.cstNode, msg);else throw new ReferenceError(msg);\n      }\n    }\n\n    return anchor.res;\n  } // Only called when stringifying an alias mapping key while constructing\n  // Object output.\n\n\n  toString(ctx) {\n    return Alias.stringify(this, ctx);\n  }\n\n}\n\nPlainValue._defineProperty(Alias, \"default\", true);\n\nfunction findPair(items, key) {\n  const k = key instanceof Scalar ? key.value : key;\n\n  for (const it of items) {\n    if (it instanceof Pair) {\n      if (it.key === key || it.key === k) return it;\n      if (it.key && it.key.value === k) return it;\n    }\n  }\n\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  add(pair, overwrite) {\n    if (!pair) pair = new Pair(pair);else if (!(pair instanceof Pair)) pair = new Pair(pair.key || pair, pair.value);\n    const prev = findPair(this.items, pair.key);\n    const sortEntries = this.schema && this.schema.sortMapEntries;\n\n    if (prev) {\n      if (overwrite) prev.value = pair.value;else throw new Error(`Key ${pair.key} already set`);\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(pair, item) < 0);\n      if (i === -1) this.items.push(pair);else this.items.splice(i, 0, pair);\n    } else {\n      this.items.push(pair);\n    }\n  }\n\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it && it.value;\n    return !keepScalar && node instanceof Scalar ? node.value : node;\n  }\n\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param {*} arg ignored\n   * @param {*} ctx Conversion context, originally set in Document#toJSON()\n   * @param {Class} Type If set, forces the returned collection type\n   * @returns {*} Instance of Type, Map, or Object\n   */\n\n\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\n    if (ctx && ctx.onCreate) ctx.onCreate(map);\n\n    for (const item of this.items) item.addToJSMap(ctx, map);\n\n    return map;\n  }\n\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n\n    for (const item of this.items) {\n      if (!(item instanceof Pair)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n    }\n\n    return super.toString(ctx, {\n      blockItem: n => n.str,\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      isMap: true,\n      itemIndent: ctx.indent || ''\n    }, onComment, onChompKeep);\n  }\n\n}\n\nconst MERGE_KEY = '<<';\nclass Merge extends Pair {\n  constructor(pair) {\n    if (pair instanceof Pair) {\n      let seq = pair.value;\n\n      if (!(seq instanceof YAMLSeq)) {\n        seq = new YAMLSeq();\n        seq.items.push(pair.value);\n        seq.range = pair.value.range;\n      }\n\n      super(pair.key, seq);\n      this.range = pair.range;\n    } else {\n      super(new Scalar(MERGE_KEY), new YAMLSeq());\n    }\n\n    this.type = Pair.Type.MERGE_PAIR;\n  } // If the value associated with a merge key is a single mapping node, each of\n  // its key/value pairs is inserted into the current mapping, unless the key\n  // already exists in it. If the value associated with the merge key is a\n  // sequence, then this sequence is expected to contain mapping nodes and each\n  // of these nodes is merged in turn according to its order in the sequence.\n  // Keys in mapping nodes earlier in the sequence override keys specified in\n  // later mapping nodes. -- http://yaml.org/type/merge.html\n\n\n  addToJSMap(ctx, map) {\n    for (const {\n      source\n    } of this.value.items) {\n      if (!(source instanceof YAMLMap)) throw new Error('Merge sources must be maps');\n      const srcMap = source.toJSON(null, ctx, Map);\n\n      for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n          if (!map.has(key)) map.set(key, value);\n        } else if (map instanceof Set) {\n          map.add(key);\n        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n          Object.defineProperty(map, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n\n    return map;\n  }\n\n  toString(ctx, onComment) {\n    const seq = this.value;\n    if (seq.items.length > 1) return super.toString(ctx, onComment);\n    this.value = seq.items[0];\n    const str = super.toString(ctx, onComment);\n    this.value = seq;\n    return str;\n  }\n\n}\n\nconst binaryOptions = {\n  defaultType: PlainValue.Type.BLOCK_LITERAL,\n  lineWidth: 76\n};\nconst boolOptions = {\n  trueStr: 'true',\n  falseStr: 'false'\n};\nconst intOptions = {\n  asBigInt: false\n};\nconst nullOptions = {\n  nullStr: 'null'\n};\nconst strOptions = {\n  defaultType: PlainValue.Type.PLAIN,\n  doubleQuoted: {\n    jsonEncoding: false,\n    minMultiLineLength: 40\n  },\n  fold: {\n    lineWidth: 80,\n    minContentWidth: 20\n  }\n};\n\nfunction resolveScalar(str, tags, scalarFallback) {\n  for (const {\n    format,\n    test,\n    resolve\n  } of tags) {\n    if (test) {\n      const match = str.match(test);\n\n      if (match) {\n        let res = resolve.apply(null, match);\n        if (!(res instanceof Scalar)) res = new Scalar(res);\n        if (format) res.format = format;\n        return res;\n      }\n    }\n  }\n\n  if (scalarFallback) str = scalarFallback(str);\n  return new Scalar(str);\n}\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted'; // presumes i+1 is at the start of a line\n// returns index of last newline in more-indented block\n\nconst consumeMoreIndentedLines = (text, i) => {\n  let ch = text[i + 1];\n\n  while (ch === ' ' || ch === '\\t') {\n    do {\n      ch = text[i += 1];\n    } while (ch && ch !== '\\n');\n\n    ch = text[i + 1];\n  }\n\n  return i;\n};\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n *\n * @param {string} text\n * @param {string} indent\n * @param {string} [mode='flow'] `'block'` prevents more-indented lines\n *   from being folded; `'quoted'` allows for `\\` escapes, including escaped\n *   newlines\n * @param {Object} options\n * @param {number} [options.indentAtStart] Accounts for leading contents on\n *   the first line, defaulting to `indent.length`\n * @param {number} [options.lineWidth=80]\n * @param {number} [options.minContentWidth=20] Allow highly indented lines to\n *   stretch the line width or indent content from the start\n * @param {function} options.onFold Called once if the text is folded\n * @param {function} options.onFold Called once if any line of text exceeds\n *   lineWidth characters\n */\n\n\nfunction foldFlowLines(text, indent, mode, {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - indent.length;\n\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n  let escStart = -1;\n  let escEnd = -1;\n\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i);\n    if (i !== -1) end = i + endStep;\n  }\n\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n\n        case 'u':\n          i += 5;\n          break;\n\n        case 'U':\n          i += 9;\n          break;\n\n        default:\n          i += 1;\n      }\n\n      escEnd = i;\n    }\n\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i);\n      end = i + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          } // Account for newline escape, but don't break preceding escape\n\n\n          const j = i > escEnd + 1 ? i - 2 : escStart - 1; // Bail out if lineWidth & minContentWidth are shorter than an escape string\n\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n\n    prev = ch;\n  }\n\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (fold === 0) res = `\\n${indent}${text.slice(0, end)}`;else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n      res += `\\n${indent}${text.slice(fold + 1, end)}`;\n    }\n  }\n\n  return res;\n}\n\nconst getFoldOptions = ({\n  indentAtStart\n}) => indentAtStart ? Object.assign({\n  indentAtStart\n}, strOptions.fold) : strOptions.fold; // Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\n\n\nconst containsDocumentMarker = str => /^(%|---|\\.\\.\\.)/m.test(str);\n\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n  if (!lineWidth || lineWidth < 0) return false;\n  const limit = lineWidth - indentLength;\n  const strLen = str.length;\n  if (strLen <= limit) return false;\n\n  for (let i = 0, start = 0; i < strLen; ++i) {\n    if (str[i] === '\\n') {\n      if (i - start > limit) return true;\n      start = i + 1;\n      if (strLen - start <= limit) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction doubleQuotedString(value, ctx) {\n  const {\n    implicitKey\n  } = ctx;\n  const {\n    jsonEncoding,\n    minMultiLineLength\n  } = strOptions.doubleQuoted;\n  const json = JSON.stringify(value);\n  if (jsonEncoding) return json;\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  let str = '';\n  let start = 0;\n\n  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n    if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n      // space before newline needs to be escaped to not be folded\n      str += json.slice(start, i) + '\\\\ ';\n      i += 1;\n      start = i;\n      ch = '\\\\';\n    }\n\n    if (ch === '\\\\') switch (json[i + 1]) {\n      case 'u':\n        {\n          str += json.slice(start, i);\n          const code = json.substr(i + 2, 4);\n\n          switch (code) {\n            case '0000':\n              str += '\\\\0';\n              break;\n\n            case '0007':\n              str += '\\\\a';\n              break;\n\n            case '000b':\n              str += '\\\\v';\n              break;\n\n            case '001b':\n              str += '\\\\e';\n              break;\n\n            case '0085':\n              str += '\\\\N';\n              break;\n\n            case '00a0':\n              str += '\\\\_';\n              break;\n\n            case '2028':\n              str += '\\\\L';\n              break;\n\n            case '2029':\n              str += '\\\\P';\n              break;\n\n            default:\n              if (code.substr(0, 2) === '00') str += '\\\\x' + code.substr(2);else str += json.substr(i, 6);\n          }\n\n          i += 5;\n          start = i + 1;\n        }\n        break;\n\n      case 'n':\n        if (implicitKey || json[i + 2] === '\"' || json.length < minMultiLineLength) {\n          i += 1;\n        } else {\n          // folding will eat first newline\n          str += json.slice(start, i) + '\\n\\n';\n\n          while (json[i + 2] === '\\\\' && json[i + 3] === 'n' && json[i + 4] !== '\"') {\n            str += '\\n';\n            i += 2;\n          }\n\n          str += indent; // space after newline needs to be escaped to not be folded\n\n          if (json[i + 2] === ' ') str += '\\\\';\n          i += 1;\n          start = i + 1;\n        }\n\n        break;\n\n      default:\n        i += 1;\n    }\n  }\n\n  str = start ? str + json.slice(start) : json;\n  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\n\nfunction singleQuotedString(value, ctx) {\n  if (ctx.implicitKey) {\n    if (/\\n/.test(value)) return doubleQuotedString(value, ctx);\n  } else {\n    // single quoted string can't have leading or trailing whitespace around newline\n    if (/[ \\t]\\n|\\n[ \\t]/.test(value)) return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n  const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\n\nfunction blockString({\n  comment,\n  type,\n  value\n}, ctx, onComment, onChompKeep) {\n  // 1. Block can't end in whitespace unless the last line is non-empty.\n  // 2. Strings consisting of only whitespace are best rendered explicitly.\n  if (/\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n  const indentSize = indent ? '2' : '1'; // root is at -1\n\n  const literal = type === PlainValue.Type.BLOCK_FOLDED ? false : type === PlainValue.Type.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, strOptions.fold.lineWidth, indent.length);\n  let header = literal ? '|' : '>';\n  if (!value) return header + '\\n';\n  let wsStart = '';\n  let wsEnd = '';\n  value = value.replace(/[\\n\\t ]*$/, ws => {\n    const n = ws.indexOf('\\n');\n\n    if (n === -1) {\n      header += '-'; // strip\n    } else if (value === ws || n !== ws.length - 1) {\n      header += '+'; // keep\n\n      if (onChompKeep) onChompKeep();\n    }\n\n    wsEnd = ws.replace(/\\n$/, '');\n    return '';\n  }).replace(/^[\\n ]*/, ws => {\n    if (ws.indexOf(' ') !== -1) header += indentSize;\n    const m = ws.match(/ +$/);\n\n    if (m) {\n      wsStart = ws.slice(0, -m[0].length);\n      return m[0];\n    } else {\n      wsStart = ws;\n      return '';\n    }\n  });\n  if (wsEnd) wsEnd = wsEnd.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n  if (wsStart) wsStart = wsStart.replace(/\\n+/g, `$&${indent}`);\n\n  if (comment) {\n    header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\n    if (onComment) onComment();\n  }\n\n  if (!value) return `${header}${indentSize}\\n${indent}${wsEnd}`;\n\n  if (literal) {\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `${header}\\n${indent}${wsStart}${value}${wsEnd}`;\n  }\n\n  value = value.replace(/\\n+/g, '\\n$&').replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n  //         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent\n  .replace(/\\n+/g, `$&${indent}`);\n  const body = foldFlowLines(`${wsStart}${value}${wsEnd}`, indent, FOLD_BLOCK, strOptions.fold);\n  return `${header}\\n${indent}${body}`;\n}\n\nfunction plainString(item, ctx, onComment, onChompKeep) {\n  const {\n    comment,\n    type,\n    value\n  } = item;\n  const {\n    actualString,\n    implicitKey,\n    indent,\n    inFlow\n  } = ctx;\n\n  if (implicitKey && /[\\n[\\]{},]/.test(value) || inFlow && /[[\\]{},]/.test(value)) {\n    return doubleQuotedString(value, ctx);\n  }\n\n  if (!value || /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n    // not allowed:\n    // - empty string, '-' or '?'\n    // - start with an indicator character (except [?:-]) or /[?-] /\n    // - '\\n ', ': ' or ' \\n' anywhere\n    // - '#' not preceded by a non-space char\n    // - end with ' ' or ':'\n    return implicitKey || inFlow || value.indexOf('\\n') === -1 ? value.indexOf('\"') !== -1 && value.indexOf(\"'\") === -1 ? singleQuotedString(value, ctx) : doubleQuotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (!implicitKey && !inFlow && type !== PlainValue.Type.PLAIN && value.indexOf('\\n') !== -1) {\n    // Where allowed & type not set explicitly, prefer block style for multiline strings\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  if (indent === '' && containsDocumentMarker(value)) {\n    ctx.forceBlockIndent = true;\n    return blockString(item, ctx, onComment, onChompKeep);\n  }\n\n  const str = value.replace(/\\n+/g, `$&\\n${indent}`); // Verify that output will be parsed as a string, as e.g. plain numbers and\n  // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n  // and others in v1.1.\n\n  if (actualString) {\n    const {\n      tags\n    } = ctx.doc.schema;\n    const resolved = resolveScalar(str, tags, tags.scalarFallback).value;\n    if (typeof resolved !== 'string') return doubleQuotedString(value, ctx);\n  }\n\n  const body = implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n\n  if (comment && !inFlow && (body.indexOf('\\n') !== -1 || comment.indexOf('\\n') !== -1)) {\n    if (onComment) onComment();\n    return addCommentBefore(body, indent, comment);\n  }\n\n  return body;\n}\n\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n  const {\n    defaultType\n  } = strOptions;\n  const {\n    implicitKey,\n    inFlow\n  } = ctx;\n  let {\n    type,\n    value\n  } = item;\n\n  if (typeof value !== 'string') {\n    value = String(value);\n    item = Object.assign({}, item, {\n      value\n    });\n  }\n\n  const _stringify = _type => {\n    switch (_type) {\n      case PlainValue.Type.BLOCK_FOLDED:\n      case PlainValue.Type.BLOCK_LITERAL:\n        return blockString(item, ctx, onComment, onChompKeep);\n\n      case PlainValue.Type.QUOTE_DOUBLE:\n        return doubleQuotedString(value, ctx);\n\n      case PlainValue.Type.QUOTE_SINGLE:\n        return singleQuotedString(value, ctx);\n\n      case PlainValue.Type.PLAIN:\n        return plainString(item, ctx, onComment, onChompKeep);\n\n      default:\n        return null;\n    }\n  };\n\n  if (type !== PlainValue.Type.QUOTE_DOUBLE && /[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(value)) {\n    // force double quotes on control characters\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  } else if ((implicitKey || inFlow) && (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {\n    // should not happen; blocks are not valid inside flow containers\n    type = PlainValue.Type.QUOTE_DOUBLE;\n  }\n\n  let res = _stringify(type);\n\n  if (res === null) {\n    res = _stringify(defaultType);\n    if (res === null) throw new Error(`Unsupported default string type ${defaultType}`);\n  }\n\n  return res;\n}\n\nfunction stringifyNumber({\n  format,\n  minFractionDigits,\n  tag,\n  value\n}) {\n  if (typeof value === 'bigint') return String(value);\n  if (!isFinite(value)) return isNaN(value) ? '.nan' : value < 0 ? '-.inf' : '.inf';\n  let n = JSON.stringify(value);\n\n  if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\\d/.test(n)) {\n    let i = n.indexOf('.');\n\n    if (i < 0) {\n      i = n.length;\n      n += '.';\n    }\n\n    let d = minFractionDigits - (n.length - i - 1);\n\n    while (d-- > 0) n += '0';\n  }\n\n  return n;\n}\n\nfunction checkFlowCollectionEnd(errors, cst) {\n  let char, name;\n\n  switch (cst.type) {\n    case PlainValue.Type.FLOW_MAP:\n      char = '}';\n      name = 'flow map';\n      break;\n\n    case PlainValue.Type.FLOW_SEQ:\n      char = ']';\n      name = 'flow sequence';\n      break;\n\n    default:\n      errors.push(new PlainValue.YAMLSemanticError(cst, 'Not a flow collection!?'));\n      return;\n  }\n\n  let lastItem;\n\n  for (let i = cst.items.length - 1; i >= 0; --i) {\n    const item = cst.items[i];\n\n    if (!item || item.type !== PlainValue.Type.COMMENT) {\n      lastItem = item;\n      break;\n    }\n  }\n\n  if (lastItem && lastItem.char !== char) {\n    const msg = `Expected ${name} to end with ${char}`;\n    let err;\n\n    if (typeof lastItem.offset === 'number') {\n      err = new PlainValue.YAMLSemanticError(cst, msg);\n      err.offset = lastItem.offset + 1;\n    } else {\n      err = new PlainValue.YAMLSemanticError(lastItem, msg);\n      if (lastItem.range && lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start;\n    }\n\n    errors.push(err);\n  }\n}\nfunction checkFlowCommentSpace(errors, comment) {\n  const prev = comment.context.src[comment.range.start - 1];\n\n  if (prev !== '\\n' && prev !== '\\t' && prev !== ' ') {\n    const msg = 'Comments must be separated from other tokens by white space characters';\n    errors.push(new PlainValue.YAMLSemanticError(comment, msg));\n  }\n}\nfunction getLongKeyError(source, key) {\n  const sk = String(key);\n  const k = sk.substr(0, 8) + '...' + sk.substr(-8);\n  return new PlainValue.YAMLSemanticError(source, `The \"${k}\" key is too long`);\n}\nfunction resolveComments(collection, comments) {\n  for (const {\n    afterKey,\n    before,\n    comment\n  } of comments) {\n    let item = collection.items[before];\n\n    if (!item) {\n      if (comment !== undefined) {\n        if (collection.comment) collection.comment += '\\n' + comment;else collection.comment = comment;\n      }\n    } else {\n      if (afterKey && item.value) item = item.value;\n\n      if (comment === undefined) {\n        if (afterKey || !item.commentBefore) item.spaceBefore = true;\n      } else {\n        if (item.commentBefore) item.commentBefore += '\\n' + comment;else item.commentBefore = comment;\n      }\n    }\n  }\n}\n\n// on error, will return { str: string, errors: Error[] }\nfunction resolveString(doc, node) {\n  const res = node.strValue;\n  if (!res) return '';\n  if (typeof res === 'string') return res;\n  res.errors.forEach(error => {\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n  });\n  return res.str;\n}\n\nfunction resolveTagHandle(doc, node) {\n  const {\n    handle,\n    suffix\n  } = node.tag;\n  let prefix = doc.tagPrefixes.find(p => p.handle === handle);\n\n  if (!prefix) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    if (dtp) prefix = dtp.find(p => p.handle === handle);\n    if (!prefix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag handle is non-default and was not declared.`);\n  }\n\n  if (!suffix) throw new PlainValue.YAMLSemanticError(node, `The ${handle} tag has no suffix.`);\n\n  if (handle === '!' && (doc.version || doc.options.version) === '1.0') {\n    if (suffix[0] === '^') {\n      doc.warnings.push(new PlainValue.YAMLWarning(node, 'YAML 1.0 ^ tag expansion is not supported'));\n      return suffix;\n    }\n\n    if (/[:/]/.test(suffix)) {\n      // word/foo -> tag:word.yaml.org,2002:foo\n      const vocab = suffix.match(/^([a-z0-9-]+)\\/(.*)/i);\n      return vocab ? `tag:${vocab[1]}.yaml.org,2002:${vocab[2]}` : `tag:${suffix}`;\n    }\n  }\n\n  return prefix.prefix + decodeURIComponent(suffix);\n}\n\nfunction resolveTagName(doc, node) {\n  const {\n    tag,\n    type\n  } = node;\n  let nonSpecific = false;\n\n  if (tag) {\n    const {\n      handle,\n      suffix,\n      verbatim\n    } = tag;\n\n    if (verbatim) {\n      if (verbatim !== '!' && verbatim !== '!!') return verbatim;\n      const msg = `Verbatim tags aren't resolved, so ${verbatim} is invalid.`;\n      doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n    } else if (handle === '!' && !suffix) {\n      nonSpecific = true;\n    } else {\n      try {\n        return resolveTagHandle(doc, node);\n      } catch (error) {\n        doc.errors.push(error);\n      }\n    }\n  }\n\n  switch (type) {\n    case PlainValue.Type.BLOCK_FOLDED:\n    case PlainValue.Type.BLOCK_LITERAL:\n    case PlainValue.Type.QUOTE_DOUBLE:\n    case PlainValue.Type.QUOTE_SINGLE:\n      return PlainValue.defaultTags.STR;\n\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    case PlainValue.Type.PLAIN:\n      return nonSpecific ? PlainValue.defaultTags.STR : null;\n\n    default:\n      return null;\n  }\n}\n\nfunction resolveByTagName(doc, node, tagName) {\n  const {\n    tags\n  } = doc.schema;\n  const matchWithTest = [];\n\n  for (const tag of tags) {\n    if (tag.tag === tagName) {\n      if (tag.test) matchWithTest.push(tag);else {\n        const res = tag.resolve(doc, node);\n        return res instanceof Collection ? res : new Scalar(res);\n      }\n    }\n  }\n\n  const str = resolveString(doc, node);\n  if (typeof str === 'string' && matchWithTest.length > 0) return resolveScalar(str, matchWithTest, tags.scalarFallback);\n  return null;\n}\n\nfunction getFallbackTagName({\n  type\n}) {\n  switch (type) {\n    case PlainValue.Type.FLOW_MAP:\n    case PlainValue.Type.MAP:\n      return PlainValue.defaultTags.MAP;\n\n    case PlainValue.Type.FLOW_SEQ:\n    case PlainValue.Type.SEQ:\n      return PlainValue.defaultTags.SEQ;\n\n    default:\n      return PlainValue.defaultTags.STR;\n  }\n}\n\nfunction resolveTag(doc, node, tagName) {\n  try {\n    const res = resolveByTagName(doc, node, tagName);\n\n    if (res) {\n      if (tagName && node.tag) res.tag = tagName;\n      return res;\n    }\n  } catch (error) {\n    /* istanbul ignore if */\n    if (!error.source) error.source = node;\n    doc.errors.push(error);\n    return null;\n  }\n\n  try {\n    const fallback = getFallbackTagName(node);\n    if (!fallback) throw new Error(`The tag ${tagName} is unavailable`);\n    const msg = `The tag ${tagName} is unavailable, falling back to ${fallback}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(node, msg));\n    const res = resolveByTagName(doc, node, fallback);\n    res.tag = tagName;\n    return res;\n  } catch (error) {\n    const refError = new PlainValue.YAMLReferenceError(node, error.message);\n    refError.stack = error.stack;\n    doc.errors.push(refError);\n    return null;\n  }\n}\n\nconst isCollectionItem = node => {\n  if (!node) return false;\n  const {\n    type\n  } = node;\n  return type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM;\n};\n\nfunction resolveNodeProps(errors, node) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let hasAnchor = false;\n  let hasTag = false;\n  const props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props;\n\n  for (const {\n    start,\n    end\n  } of props) {\n    switch (node.context.src[start]) {\n      case PlainValue.Char.COMMENT:\n        {\n          if (!node.commentHasRequiredWhitespace(start)) {\n            const msg = 'Comments must be separated from other tokens by white space characters';\n            errors.push(new PlainValue.YAMLSemanticError(node, msg));\n          }\n\n          const {\n            header,\n            valueRange\n          } = node;\n          const cc = valueRange && (start > valueRange.start || header && start > header.start) ? comments.after : comments.before;\n          cc.push(node.context.src.slice(start + 1, end));\n          break;\n        }\n      // Actual anchor & tag resolution is handled by schema, here we just complain\n\n      case PlainValue.Char.ANCHOR:\n        if (hasAnchor) {\n          const msg = 'A node can have at most one anchor';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasAnchor = true;\n        break;\n\n      case PlainValue.Char.TAG:\n        if (hasTag) {\n          const msg = 'A node can have at most one tag';\n          errors.push(new PlainValue.YAMLSemanticError(node, msg));\n        }\n\n        hasTag = true;\n        break;\n    }\n  }\n\n  return {\n    comments,\n    hasAnchor,\n    hasTag\n  };\n}\n\nfunction resolveNodeValue(doc, node) {\n  const {\n    anchors,\n    errors,\n    schema\n  } = doc;\n\n  if (node.type === PlainValue.Type.ALIAS) {\n    const name = node.rawValue;\n    const src = anchors.getNode(name);\n\n    if (!src) {\n      const msg = `Aliased anchor not found: ${name}`;\n      errors.push(new PlainValue.YAMLReferenceError(node, msg));\n      return null;\n    } // Lazy resolution for circular references\n\n\n    const res = new Alias(src);\n\n    anchors._cstAliases.push(res);\n\n    return res;\n  }\n\n  const tagName = resolveTagName(doc, node);\n  if (tagName) return resolveTag(doc, node, tagName);\n\n  if (node.type !== PlainValue.Type.PLAIN) {\n    const msg = `Failed to resolve ${node.type} node here`;\n    errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n    return null;\n  }\n\n  try {\n    const str = resolveString(doc, node);\n    return resolveScalar(str, schema.tags, schema.tags.scalarFallback);\n  } catch (error) {\n    if (!error.source) error.source = node;\n    errors.push(error);\n    return null;\n  }\n} // sets node.resolved on success\n\n\nfunction resolveNode(doc, node) {\n  if (!node) return null;\n  if (node.error) doc.errors.push(node.error);\n  const {\n    comments,\n    hasAnchor,\n    hasTag\n  } = resolveNodeProps(doc.errors, node);\n\n  if (hasAnchor) {\n    const {\n      anchors\n    } = doc;\n    const name = node.anchor;\n    const prev = anchors.getNode(name); // At this point, aliases for any preceding node with the same anchor\n    // name have already been resolved, so it may safely be renamed.\n\n    if (prev) anchors.map[anchors.newName(name)] = prev; // During parsing, we need to store the CST node in anchors.map as\n    // anchors need to be available during resolution to allow for\n    // circular references.\n\n    anchors.map[name] = node;\n  }\n\n  if (node.type === PlainValue.Type.ALIAS && (hasAnchor || hasTag)) {\n    const msg = 'An alias node must not specify any properties';\n    doc.errors.push(new PlainValue.YAMLSemanticError(node, msg));\n  }\n\n  const res = resolveNodeValue(doc, node);\n\n  if (res) {\n    res.range = [node.range.start, node.range.end];\n    if (doc.options.keepCstNodes) res.cstNode = node;\n    if (doc.options.keepNodeTypes) res.type = node.type;\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      res.commentBefore = res.commentBefore ? `${res.commentBefore}\\n${cb}` : cb;\n    }\n\n    const ca = comments.after.join('\\n');\n    if (ca) res.comment = res.comment ? `${res.comment}\\n${ca}` : ca;\n  }\n\n  return node.resolved = res;\n}\n\nfunction resolveMap(doc, cst) {\n  if (cst.type !== PlainValue.Type.MAP && cst.type !== PlainValue.Type.FLOW_MAP) {\n    const msg = `A ${cst.type} node cannot be resolved as a mapping`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc, cst) : resolveBlockMapItems(doc, cst);\n  const map = new YAMLMap();\n  map.items = items;\n  resolveComments(map, comments);\n  let hasCollectionKey = false;\n\n  for (let i = 0; i < items.length; ++i) {\n    const {\n      key: iKey\n    } = items[i];\n    if (iKey instanceof Collection) hasCollectionKey = true;\n\n    if (doc.schema.merge && iKey && iKey.value === MERGE_KEY) {\n      items[i] = new Merge(items[i]);\n      const sources = items[i].value.items;\n      let error = null;\n      sources.some(node => {\n        if (node instanceof Alias) {\n          // During parsing, alias sources are CST nodes; to account for\n          // circular references their resolved values can't be used here.\n          const {\n            type\n          } = node.source;\n          if (type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) return false;\n          return error = 'Merge nodes aliases can only point to maps';\n        }\n\n        return error = 'Merge nodes can only have Alias nodes as values';\n      });\n      if (error) doc.errors.push(new PlainValue.YAMLSemanticError(cst, error));\n    } else {\n      for (let j = i + 1; j < items.length; ++j) {\n        const {\n          key: jKey\n        } = items[j];\n\n        if (iKey === jKey || iKey && jKey && Object.prototype.hasOwnProperty.call(iKey, 'value') && iKey.value === jKey.value) {\n          const msg = `Map keys must be unique; \"${iKey}\" is repeated`;\n          doc.errors.push(new PlainValue.YAMLSemanticError(cst, msg));\n          break;\n        }\n      }\n    }\n  }\n\n  if (hasCollectionKey && !doc.options.mapAsMap) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = map;\n  return map;\n}\n\nconst valueHasPairComment = ({\n  context: {\n    lineStart,\n    node,\n    src\n  },\n  props\n}) => {\n  if (props.length === 0) return false;\n  const {\n    start\n  } = props[0];\n  if (node && start > node.valueRange.start) return false;\n  if (src[start] !== PlainValue.Char.COMMENT) return false;\n\n  for (let i = lineStart; i < start; ++i) if (src[i] === '\\n') return false;\n\n  return true;\n};\n\nfunction resolvePairComment(item, pair) {\n  if (!valueHasPairComment(item)) return;\n  const comment = item.getPropValue(0, PlainValue.Char.COMMENT, true);\n  let found = false;\n  const cb = pair.value.commentBefore;\n\n  if (cb && cb.startsWith(comment)) {\n    pair.value.commentBefore = cb.substr(comment.length + 1);\n    found = true;\n  } else {\n    const cc = pair.value.comment;\n\n    if (!item.node && cc && cc.startsWith(comment)) {\n      pair.value.comment = cc.substr(comment.length + 1);\n      found = true;\n    }\n  }\n\n  if (found) pair.comment = comment;\n}\n\nfunction resolveBlockMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let keyStart = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          afterKey: !!key,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          afterKey: !!key,\n          before: items.length,\n          comment: item.comment\n        });\n        break;\n\n      case PlainValue.Type.MAP_KEY:\n        if (key !== undefined) items.push(new Pair(key));\n        if (item.error) doc.errors.push(item.error);\n        key = resolveNode(doc, item.node);\n        keyStart = null;\n        break;\n\n      case PlainValue.Type.MAP_VALUE:\n        {\n          if (key === undefined) key = null;\n          if (item.error) doc.errors.push(item.error);\n\n          if (!item.context.atLineStart && item.node && item.node.type === PlainValue.Type.MAP && !item.node.context.atLineStart) {\n            const msg = 'Nested mappings are not allowed in compact mappings';\n            doc.errors.push(new PlainValue.YAMLSemanticError(item.node, msg));\n          }\n\n          let valueNode = item.node;\n\n          if (!valueNode && item.props.length > 0) {\n            // Comments on an empty mapping value need to be preserved, so we\n            // need to construct a minimal empty node here to use instead of the\n            // missing `item.node`. -- eemeli/yaml#19\n            valueNode = new PlainValue.PlainValue(PlainValue.Type.PLAIN, []);\n            valueNode.context = {\n              parent: item,\n              src: item.context.src\n            };\n            const pos = item.range.start + 1;\n            valueNode.range = {\n              start: pos,\n              end: pos\n            };\n            valueNode.valueRange = {\n              start: pos,\n              end: pos\n            };\n\n            if (typeof item.range.origStart === 'number') {\n              const origPos = item.range.origStart + 1;\n              valueNode.range.origStart = valueNode.range.origEnd = origPos;\n              valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos;\n            }\n          }\n\n          const pair = new Pair(key, resolveNode(doc, valueNode));\n          resolvePairComment(item, pair);\n          items.push(pair);\n\n          if (key && typeof keyStart === 'number') {\n            if (item.range.start > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n          }\n\n          key = undefined;\n          keyStart = null;\n        }\n        break;\n\n      default:\n        if (key !== undefined) items.push(new Pair(key));\n        key = resolveNode(doc, item);\n        keyStart = item.range.start;\n        if (item.error) doc.errors.push(item.error);\n\n        next: for (let j = i + 1;; ++j) {\n          const nextItem = cst.items[j];\n\n          switch (nextItem && nextItem.type) {\n            case PlainValue.Type.BLANK_LINE:\n            case PlainValue.Type.COMMENT:\n              continue next;\n\n            case PlainValue.Type.MAP_VALUE:\n              break next;\n\n            default:\n              {\n                const msg = 'Implicit map keys need to be followed by map values';\n                doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n                break next;\n              }\n          }\n        }\n\n        if (item.valueRangeContainsNewline) {\n          const msg = 'Implicit map keys need to be on a single line';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n    }\n  }\n\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowMapItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let key = undefined;\n  let explicitKey = false;\n  let next = '{';\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char === '?' && key === undefined && !explicitKey) {\n        explicitKey = true;\n        next = ':';\n        continue;\n      }\n\n      if (char === ':') {\n        if (key === undefined) key = null;\n\n        if (next === ':') {\n          next = ',';\n          continue;\n        }\n      } else {\n        if (explicitKey) {\n          if (key === undefined && char !== ',') key = null;\n          explicitKey = false;\n        }\n\n        if (key !== undefined) {\n          items.push(new Pair(key));\n          key = undefined;\n\n          if (char === ',') {\n            next = ':';\n            continue;\n          }\n        }\n      }\n\n      if (char === '}') {\n        if (i === cst.items.length - 1) continue;\n      } else if (char === next) {\n        next = ':';\n        continue;\n      }\n\n      const msg = `Flow map contains an unexpected ${char}`;\n      const err = new PlainValue.YAMLSyntaxError(cst, msg);\n      err.offset = offset;\n      doc.errors.push(err);\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        afterKey: !!key,\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        afterKey: !!key,\n        before: items.length,\n        comment: item.comment\n      });\n    } else if (key === undefined) {\n      if (next === ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Separator , missing in flow map'));\n      key = resolveNode(doc, item);\n    } else {\n      if (next !== ',') doc.errors.push(new PlainValue.YAMLSemanticError(item, 'Indicator : missing in flow map entry'));\n      items.push(new Pair(key, resolveNode(doc, item)));\n      key = undefined;\n      explicitKey = false;\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveSeq(doc, cst) {\n  if (cst.type !== PlainValue.Type.SEQ && cst.type !== PlainValue.Type.FLOW_SEQ) {\n    const msg = `A ${cst.type} node cannot be resolved as a sequence`;\n    doc.errors.push(new PlainValue.YAMLSyntaxError(cst, msg));\n    return null;\n  }\n\n  const {\n    comments,\n    items\n  } = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc, cst) : resolveBlockSeqItems(doc, cst);\n  const seq = new YAMLSeq();\n  seq.items = items;\n  resolveComments(seq, comments);\n\n  if (!doc.options.mapAsMap && items.some(it => it instanceof Pair && it.key instanceof Collection)) {\n    const warn = 'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.';\n    doc.warnings.push(new PlainValue.YAMLWarning(cst, warn));\n  }\n\n  cst.resolved = seq;\n  return seq;\n}\n\nfunction resolveBlockSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    switch (item.type) {\n      case PlainValue.Type.BLANK_LINE:\n        comments.push({\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.COMMENT:\n        comments.push({\n          comment: item.comment,\n          before: items.length\n        });\n        break;\n\n      case PlainValue.Type.SEQ_ITEM:\n        if (item.error) doc.errors.push(item.error);\n        items.push(resolveNode(doc, item.node));\n\n        if (item.hasProps) {\n          const msg = 'Sequence items cannot have tags or anchors before the - indicator';\n          doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n        }\n\n        break;\n\n      default:\n        if (item.error) doc.errors.push(item.error);\n        doc.errors.push(new PlainValue.YAMLSyntaxError(item, `Unexpected ${item.type} node in sequence`));\n    }\n  }\n\n  return {\n    comments,\n    items\n  };\n}\n\nfunction resolveFlowSeqItems(doc, cst) {\n  const comments = [];\n  const items = [];\n  let explicitKey = false;\n  let key = undefined;\n  let keyStart = null;\n  let next = '[';\n  let prevItem = null;\n\n  for (let i = 0; i < cst.items.length; ++i) {\n    const item = cst.items[i];\n\n    if (typeof item.char === 'string') {\n      const {\n        char,\n        offset\n      } = item;\n\n      if (char !== ':' && (explicitKey || key !== undefined)) {\n        if (explicitKey && key === undefined) key = next ? items.pop() : null;\n        items.push(new Pair(key));\n        explicitKey = false;\n        key = undefined;\n        keyStart = null;\n      }\n\n      if (char === next) {\n        next = null;\n      } else if (!next && char === '?') {\n        explicitKey = true;\n      } else if (next !== '[' && char === ':' && key === undefined) {\n        if (next === ',') {\n          key = items.pop();\n\n          if (key instanceof Pair) {\n            const msg = 'Chaining flow sequence pairs is invalid';\n            const err = new PlainValue.YAMLSemanticError(cst, msg);\n            err.offset = offset;\n            doc.errors.push(err);\n          }\n\n          if (!explicitKey && typeof keyStart === 'number') {\n            const keyEnd = item.range ? item.range.start : item.offset;\n            if (keyEnd > keyStart + 1024) doc.errors.push(getLongKeyError(cst, key));\n            const {\n              src\n            } = prevItem.context;\n\n            for (let i = keyStart; i < keyEnd; ++i) if (src[i] === '\\n') {\n              const msg = 'Implicit keys of flow sequence pairs need to be on a single line';\n              doc.errors.push(new PlainValue.YAMLSemanticError(prevItem, msg));\n              break;\n            }\n          }\n        } else {\n          key = null;\n        }\n\n        keyStart = null;\n        explicitKey = false;\n        next = null;\n      } else if (next === '[' || char !== ']' || i < cst.items.length - 1) {\n        const msg = `Flow sequence contains an unexpected ${char}`;\n        const err = new PlainValue.YAMLSyntaxError(cst, msg);\n        err.offset = offset;\n        doc.errors.push(err);\n      }\n    } else if (item.type === PlainValue.Type.BLANK_LINE) {\n      comments.push({\n        before: items.length\n      });\n    } else if (item.type === PlainValue.Type.COMMENT) {\n      checkFlowCommentSpace(doc.errors, item);\n      comments.push({\n        comment: item.comment,\n        before: items.length\n      });\n    } else {\n      if (next) {\n        const msg = `Expected a ${next} in flow sequence`;\n        doc.errors.push(new PlainValue.YAMLSemanticError(item, msg));\n      }\n\n      const value = resolveNode(doc, item);\n\n      if (key === undefined) {\n        items.push(value);\n        prevItem = item;\n      } else {\n        items.push(new Pair(key, value));\n        key = undefined;\n      }\n\n      keyStart = item.range.start;\n      next = ',';\n    }\n  }\n\n  checkFlowCollectionEnd(doc.errors, cst);\n  if (key !== undefined) items.push(new Pair(key));\n  return {\n    comments,\n    items\n  };\n}\n\nexports.Alias = Alias;\nexports.Collection = Collection;\nexports.Merge = Merge;\nexports.Node = Node;\nexports.Pair = Pair;\nexports.Scalar = Scalar;\nexports.YAMLMap = YAMLMap;\nexports.YAMLSeq = YAMLSeq;\nexports.addComment = addComment;\nexports.binaryOptions = binaryOptions;\nexports.boolOptions = boolOptions;\nexports.findPair = findPair;\nexports.intOptions = intOptions;\nexports.isEmptyPath = isEmptyPath;\nexports.nullOptions = nullOptions;\nexports.resolveMap = resolveMap;\nexports.resolveNode = resolveNode;\nexports.resolveSeq = resolveSeq;\nexports.resolveString = resolveString;\nexports.strOptions = strOptions;\nexports.stringifyNumber = stringifyNumber;\nexports.stringifyString = stringifyString;\nexports.toJSON = toJSON;\n"]},"metadata":{},"sourceType":"script"}