{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n'use strict';\n\nconst EventEmitter = require('events');\n\nconst https = require('https');\n\nconst http = require('http');\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst {\n  randomBytes,\n  createHash\n} = require('crypto');\n\nconst {\n  Readable\n} = require('stream');\n\nconst {\n  URL\n} = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst Receiver = require('./receiver');\n\nconst Sender = require('./sender');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\n\nconst {\n  addEventListener,\n  removeEventListener\n} = require('./event-target');\n\nconst {\n  format,\n  parse\n} = require('./extension');\n\nconst {\n  toBuffer\n} = require('./buffer-util');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\n\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._extensions = {};\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n\n\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type; //\n    // Allow to change `binaryType` on the fly.\n    //\n\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onclose() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onclose(listener) {}\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onerror() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onerror(listener) {}\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onopen() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onopen(listener) {}\n  /**\n   * @type {Function}\n   */\n\n  /* istanbul ignore next */\n\n\n  get onmessage() {\n    return undefined;\n  }\n  /* istanbul ignore next */\n\n\n  set onmessage(listener) {}\n  /**\n   * @type {String}\n   */\n\n\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n\n\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n\n\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} [maxPayload=0] The maximum allowed message size\n   * @private\n   */\n\n\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n\n\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {String} [data] A string explaining why the connection is closing\n   * @public\n   */\n\n\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    }); //\n    // Specify a timeout for the closing handshake to complete.\n    //\n\n\n    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n\n\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n\n      this._socket.destroy();\n    }\n  }\n\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\n\n\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\n\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\n\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n}); //\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n\n    get() {\n      const listeners = this.listeners(method);\n\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n\n    set(listener) {\n      const listeners = this.listeners(method);\n\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n\n      this.addEventListener(method, listener);\n    }\n\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {String} [protocols] The subprotocols\n * @param {Object} [options] Connection options\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @private\n */\n\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket._url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = websocket._req = get(opts);\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', err => {\n    if (req === null || req.aborted) return;\n    req = websocket._req = null;\n    websocket._readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n      const addr = new URL(location, address);\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res); //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (extensionNames.length) {\n        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n          const message = 'Server indicated an extension that was not requested';\n          abortHandshake(websocket, socket, message);\n          return;\n        }\n\n        try {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n        } catch (err) {\n          const message = 'Invalid Sec-WebSocket-Extensions header';\n          abortHandshake(websocket, socket, message);\n          return;\n        }\n\n        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\n\n\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\n\n\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\n\n\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length; //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    cb(err);\n  }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\n\n\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\n\n\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\n\n\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData); //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n\n\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\n\n\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\n\n\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\n\n\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\n\n\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\n\n\nfunction resume(stream) {\n  stream.resume();\n}\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\n\n\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk; //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\n\n\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\n\n\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n\n  websocket._receiver.end();\n\n  this.end();\n}\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\n\n\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/ws/lib/websocket.js"],"names":["EventEmitter","require","https","http","net","tls","randomBytes","createHash","Readable","URL","PerMessageDeflate","Receiver","Sender","BINARY_TYPES","EMPTY_BUFFER","GUID","kStatusCode","kWebSocket","NOOP","addEventListener","removeEventListener","format","parse","toBuffer","readyStates","protocolVersions","closeTimeout","WebSocket","constructor","address","protocols","options","_binaryType","_closeCode","_closeFrameReceived","_closeFrameSent","_closeMessage","_closeTimer","_extensions","_protocol","_readyState","CONNECTING","_receiver","_sender","_socket","_bufferedAmount","_isServer","_redirects","Array","isArray","join","undefined","initAsClient","binaryType","type","includes","bufferedAmount","_writableState","length","_bufferedBytes","extensions","Object","keys","onclose","listener","onerror","onopen","onmessage","protocol","readyState","url","_url","setSocket","socket","head","maxPayload","receiver","on","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError","OPEN","emit","emitClose","CLOSED","extensionName","cleanup","removeAllListeners","close","code","data","msg","abortHandshake","_req","CLOSING","errorEmitted","end","err","destroy","bind","ping","mask","cb","Error","toString","sendAfterClose","pong","send","opts","binary","compress","fin","terminate","defineProperty","enumerable","value","indexOf","prototype","forEach","property","method","get","listeners","i","_listener","set","removeListener","module","exports","websocket","protocolVersion","perMessageDeflate","followRedirects","maxRedirects","createConnection","socketPath","hostname","timeout","host","path","port","RangeError","parsedUrl","href","isUnixSocket","pathname","isSecure","defaultPort","key","tlsConnect","netConnect","startsWith","slice","headers","Connection","Upgrade","search","handshakeTimeout","offer","origin","Origin","username","password","auth","parts","split","req","aborted","res","location","statusCode","abort","addr","digest","update","serverProt","protList","protError","secWebSocketExtensions","message","extensionNames","accept","connect","servername","isIP","stream","captureStackTrace","setHeader","destroyed","once","reason","process","nextTick","resume","receiverOnFinish","chunk","_readableState","endEmitted","read","write","clearTimeout","finished","pause"],"mappings":"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","sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst { addEventListener, removeEventListener } = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._extensions = {};\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return undefined;\n  }\n\n  /* istanbul ignore next */\n  set onclose(listener) {}\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return undefined;\n  }\n\n  /* istanbul ignore next */\n  set onerror(listener) {}\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return undefined;\n  }\n\n  /* istanbul ignore next */\n  set onopen(listener) {}\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return undefined;\n  }\n\n  /* istanbul ignore next */\n  set onmessage(listener) {}\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} [maxPayload=0] The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this.binaryType,\n      this._extensions,\n      this._isServer,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {String} [data] A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {String} [protocols] The subprotocols\n * @param {Object} [options] Connection options\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket._url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req.aborted) return;\n\n    req = websocket._req = null;\n    websocket._readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = new URL(location, address);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (extensionNames.length) {\n        if (\n          extensionNames.length !== 1 ||\n          extensionNames[0] !== PerMessageDeflate.extensionName\n        ) {\n          const message =\n            'Server indicated an extension that was not requested';\n          abortHandshake(websocket, socket, message);\n          return;\n        }\n\n        try {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n        } catch (err) {\n          const message = 'Invalid Sec-WebSocket-Extensions header';\n          abortHandshake(websocket, socket, message);\n          return;\n        }\n\n        websocket._extensions[PerMessageDeflate.extensionName] =\n          perMessageDeflate;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}