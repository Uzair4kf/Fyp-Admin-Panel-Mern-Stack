{"ast":null,"code":"/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { messageSW } from './messageSW.js';\nimport { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';\nimport { urlsMatch } from './utils/urlsMatch.js';\nimport { WorkboxEvent } from './utils/WorkboxEvent.js';\nimport './_version.js'; // The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\n\nconst WAITING_TIMEOUT_DURATION = 200; // The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\n\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n * @memberof module:workbox-window\n */\n\nclass Workbox extends WorkboxEventTarget {\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n  constructor(scriptURL, registerOptions = {}) {\n    super();\n    this._registerOptions = {};\n    this._updateFoundCount = 0; // Deferreds we can resolve later.\n\n    this._swDeferred = new Deferred();\n    this._activeDeferred = new Deferred();\n    this._controllingDeferred = new Deferred();\n    this._registrationTime = 0;\n    this._ownSWs = new Set();\n    /**\n     * @private\n     */\n\n    this._onUpdateFound = () => {\n      // `this._registration` will never be `undefined` after an update is found.\n      const registration = this._registration;\n      const installingSW = registration.installing; // If the script URL passed to `navigator.serviceWorker.register()` is\n      // different from the current controlling SW's script URL, we know any\n      // successful registration calls will trigger an `updatefound` event.\n      // But if the registered script URL is the same as the current controlling\n      // SW's script URL, we'll only get an `updatefound` event if the file\n      // changed since it was last registered. This can be a problem if the user\n      // opens up the same page in a different tab, and that page registers\n      // a SW that triggers an update. It's a problem because this page has no\n      // good way of knowing whether the `updatefound` event came from the SW\n      // script it registered or from a registration attempt made by a newer\n      // version of the page running in another tab.\n      // To minimize the possibility of a false positive, we use the logic here:\n\n      const updateLikelyTriggeredExternally = // Since we enforce only calling `register()` once, and since we don't\n      // add the `updatefound` event listener until the `register()` call, if\n      // `_updateFoundCount` is > 0 then it means this method has already\n      // been called, thus this SW must be external\n      this._updateFoundCount > 0 || // If the script URL of the installing SW is different from this\n      // instance's script URL, we know it's definitely not from our\n      // registration.\n      !urlsMatch(installingSW.scriptURL, this._scriptURL) || performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION ? // If any of the above are not true, we assume the update was\n      // triggered by this instance.\n      true : false;\n\n      if (updateLikelyTriggeredExternally) {\n        this._externalSW = installingSW;\n        registration.removeEventListener('updatefound', this._onUpdateFound);\n      } else {\n        // If the update was not triggered externally we know the installing\n        // SW is the one we registered, so we set it.\n        this._sw = installingSW;\n\n        this._ownSWs.add(installingSW);\n\n        this._swDeferred.resolve(installingSW); // The `installing` state isn't something we have a dedicated\n        // callback for, but we do log messages for it in development.\n\n\n        if (process.env.NODE_ENV !== 'production') {\n          if (navigator.serviceWorker.controller) {\n            logger.log('Updated service worker found. Installing now...');\n          } else {\n            logger.log('Service worker is installing...');\n          }\n        }\n      } // Increment the `updatefound` count, so future invocations of this\n      // method can be sure they were triggered externally.\n\n\n      ++this._updateFoundCount; // Add a `statechange` listener regardless of whether this update was\n      // triggered externally, since we have callbacks for both.\n\n      installingSW.addEventListener('statechange', this._onStateChange);\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    this._onStateChange = originalEvent => {\n      // `this._registration` will never be `undefined` after an update is found.\n      const registration = this._registration;\n      const sw = originalEvent.target;\n      const {\n        state\n      } = sw;\n      const isExternal = sw === this._externalSW;\n      const eventPrefix = isExternal ? 'external' : '';\n      const eventProps = {\n        sw,\n        originalEvent\n      };\n\n      if (!isExternal && this._isUpdate) {\n        eventProps.isUpdate = true;\n      }\n\n      this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n\n      if (state === 'installed') {\n        // This timeout is used to ignore cases where the service worker calls\n        // `skipWaiting()` in the install event, thus moving it directly in the\n        // activating state. (Since all service workers *must* go through the\n        // waiting phase, the only way to detect `skipWaiting()` called in the\n        // install event is to observe that the time spent in the waiting phase\n        // is very short.)\n        // NOTE: we don't need separate timeouts for the own and external SWs\n        // since they can't go through these phases at the same time.\n        this._waitingTimeout = self.setTimeout(() => {\n          // Ensure the SW is still waiting (it may now be redundant).\n          if (state === 'installed' && registration.waiting === sw) {\n            this.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (isExternal) {\n                logger.warn('An external service worker has installed but is ' + 'waiting for this client to close before activating...');\n              } else {\n                logger.warn('The service worker has installed but is waiting ' + 'for existing clients to close before activating...');\n              }\n            }\n          }\n        }, WAITING_TIMEOUT_DURATION);\n      } else if (state === 'activating') {\n        clearTimeout(this._waitingTimeout);\n\n        if (!isExternal) {\n          this._activeDeferred.resolve(sw);\n        }\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        switch (state) {\n          case 'installed':\n            if (isExternal) {\n              logger.warn('An external service worker has installed. ' + 'You may want to suggest users reload this page.');\n            } else {\n              logger.log('Registered service worker installed.');\n            }\n\n            break;\n\n          case 'activated':\n            if (isExternal) {\n              logger.warn('An external service worker has activated.');\n            } else {\n              logger.log('Registered service worker activated.');\n\n              if (sw !== navigator.serviceWorker.controller) {\n                logger.warn('The registered service worker is active but ' + 'not yet controlling the page. Reload or run ' + '`clients.claim()` in the service worker.');\n              }\n            }\n\n            break;\n\n          case 'redundant':\n            if (sw === this._compatibleControllingSW) {\n              logger.log('Previously controlling service worker now redundant!');\n            } else if (!isExternal) {\n              logger.log('Registered service worker now redundant!');\n            }\n\n            break;\n        }\n      }\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    this._onControllerChange = originalEvent => {\n      const sw = this._sw;\n\n      if (sw === navigator.serviceWorker.controller) {\n        this.dispatchEvent(new WorkboxEvent('controlling', {\n          sw,\n          originalEvent,\n          isUpdate: this._isUpdate\n        }));\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log('Registered service worker now controlling this page.');\n        }\n\n        this._controllingDeferred.resolve(sw);\n      }\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    this._onMessage = async originalEvent => {\n      const {\n        data,\n        source\n      } = originalEvent; // Wait until there's an \"own\" service worker. This is used to buffer\n      // `message` events that may be received prior to calling `register()`.\n\n      await this.getSW(); // If the service worker that sent the message is in the list of own\n      // service workers for this instance, dispatch a `message` event.\n      // NOTE: we check for all previously owned service workers rather than\n      // just the current one because some messages (e.g. cache updates) use\n      // a timeout when sent and may be delayed long enough for a service worker\n      // update to be found.\n\n      if (this._ownSWs.has(source)) {\n        this.dispatchEvent(new WorkboxEvent('message', {\n          data,\n          sw: source,\n          originalEvent\n        }));\n      }\n    };\n\n    this._scriptURL = scriptURL;\n    this._registerOptions = registerOptions; // Add a message listener immediately since messages received during\n    // page load are buffered only until the DOMContentLoaded event:\n    // https://github.com/GoogleChrome/workbox/issues/2202\n\n    navigator.serviceWorker.addEventListener('message', this._onMessage);\n  }\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n\n\n  async register({\n    immediate = false\n  } = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this._registrationTime) {\n        logger.error('Cannot re-register a Workbox instance after it has ' + 'been registered. Create a new instance instead.');\n        return;\n      }\n    }\n\n    if (!immediate && document.readyState !== 'complete') {\n      await new Promise(res => window.addEventListener('load', res));\n    } // Set this flag to true if any service worker was controlling the page\n    // at registration time.\n\n\n    this._isUpdate = Boolean(navigator.serviceWorker.controller); // Before registering, attempt to determine if a SW is already controlling\n    // the page, and if that SW script (and version, if specified) matches this\n    // instance's script.\n\n    this._compatibleControllingSW = this._getControllingSWIfCompatible();\n    this._registration = await this._registerScript(); // If we have a compatible controller, store the controller as the \"own\"\n    // SW, resolve active/controlling deferreds and add necessary listeners.\n\n    if (this._compatibleControllingSW) {\n      this._sw = this._compatibleControllingSW;\n\n      this._activeDeferred.resolve(this._compatibleControllingSW);\n\n      this._controllingDeferred.resolve(this._compatibleControllingSW);\n\n      this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, {\n        once: true\n      });\n    } // If there's a waiting service worker with a matching URL before the\n    // `updatefound` event fires, it likely means that this site is open\n    // in another tab, or the user refreshed the page (and thus the previous\n    // page wasn't fully unloaded before this page started loading).\n    // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n\n\n    const waitingSW = this._registration.waiting;\n\n    if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n      // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n      // a compatible controller.\n      this._sw = waitingSW; // Run this in the next microtask, so any code that adds an event\n      // listener after awaiting `register()` will get this event.\n\n      dontWaitFor(Promise.resolve().then(() => {\n        this.dispatchEvent(new WorkboxEvent('waiting', {\n          sw: waitingSW,\n          wasWaitingBeforeRegister: true\n        }));\n\n        if (process.env.NODE_ENV !== 'production') {\n          logger.warn('A service worker was already waiting to activate ' + 'before this script was registered...');\n        }\n      }));\n    } // If an \"own\" SW is already set, resolve the deferred.\n\n\n    if (this._sw) {\n      this._swDeferred.resolve(this._sw);\n\n      this._ownSWs.add(this._sw);\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log('Successfully registered service worker.', this._scriptURL);\n\n      if (navigator.serviceWorker.controller) {\n        if (this._compatibleControllingSW) {\n          logger.debug('A service worker with the same script URL ' + 'is already controlling this page.');\n        } else {\n          logger.debug('A service worker with a different script URL is ' + 'currently controlling the page. The browser is now fetching ' + 'the new script now...');\n        }\n      }\n\n      const currentPageIsOutOfScope = () => {\n        const scopeURL = new URL(this._registerOptions.scope || this._scriptURL, document.baseURI);\n        const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n        return !location.pathname.startsWith(scopeURLBasePath);\n      };\n\n      if (currentPageIsOutOfScope()) {\n        logger.warn('The current page is not in scope for the registered ' + 'service worker. Was this a mistake?');\n      }\n    }\n\n    this._registration.addEventListener('updatefound', this._onUpdateFound);\n\n    navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange, {\n      once: true\n    });\n    return this._registration;\n  }\n  /**\n   * Checks for updates of the registered service worker.\n   */\n\n\n  async update() {\n    if (!this._registration) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error('Cannot update a Workbox instance without ' + 'being registered. Register the Workbox instance first.');\n      }\n\n      return;\n    } // Try to update registration\n\n\n    await this._registration.update();\n  }\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n\n\n  get active() {\n    return this._activeDeferred.promise;\n  }\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is controlling the page. If a service worker was already controlling at\n   * registration time then it will resolve to that if the script URLs (and\n   * optionally script versions) match, otherwise it will wait until an update\n   * is found and starts controlling the page.\n   * Note: the first time a service worker is installed it will active but\n   * not start controlling the page unless `clients.claim()` is called in the\n   * service worker.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n\n\n  get controlling() {\n    return this._controllingDeferred.promise;\n  }\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there's already an active or waiting service\n   * worker with a matching script URL, it will be used (with the waiting\n   * service worker taking precedence over the active service worker if both\n   * match, since the waiting service worker would have been registered more\n   * recently).\n   * If there's no matching active or waiting service worker at registration\n   * time then the promise will not resolve until an update is found and starts\n   * installing, at which point the installing service worker is used.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n\n\n  async getSW() {\n    // If `this._sw` is set, resolve with that as we want `getSW()` to\n    // return the correct (new) service worker if an update is found.\n    return this._sw !== undefined ? this._sw : this._swDeferred.promise;\n  }\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n   * with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n\n\n  async messageSW(data) {\n    const sw = await this.getSW();\n    return messageSW(sw, data);\n  }\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL matches.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n\n\n  _getControllingSWIfCompatible() {\n    const controller = navigator.serviceWorker.controller;\n\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      return controller;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n\n\n  async _registerScript() {\n    try {\n      const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions); // Keep track of when registration happened, so it can be used in the\n      // `this._onUpdateFound` heuristic. Also use the presence of this\n      // property as a way to see if `.register()` has been called.\n\n      this._registrationTime = performance.now();\n      return reg;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(error);\n      } // Re-throw the error.\n\n\n      throw error;\n    }\n  }\n\n}\n\nexport { Workbox }; // The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/workbox-window/Workbox.js"],"names":["Deferred","dontWaitFor","logger","messageSW","WorkboxEventTarget","urlsMatch","WorkboxEvent","WAITING_TIMEOUT_DURATION","REGISTRATION_TIMEOUT_DURATION","Workbox","constructor","scriptURL","registerOptions","_registerOptions","_updateFoundCount","_swDeferred","_activeDeferred","_controllingDeferred","_registrationTime","_ownSWs","Set","_onUpdateFound","registration","_registration","installingSW","installing","updateLikelyTriggeredExternally","_scriptURL","performance","now","_externalSW","removeEventListener","_sw","add","resolve","process","env","NODE_ENV","navigator","serviceWorker","controller","log","addEventListener","_onStateChange","originalEvent","sw","target","state","isExternal","eventPrefix","eventProps","_isUpdate","isUpdate","dispatchEvent","_waitingTimeout","self","setTimeout","waiting","warn","clearTimeout","_compatibleControllingSW","_onControllerChange","_onMessage","data","source","getSW","has","register","immediate","error","document","readyState","Promise","res","window","Boolean","_getControllingSWIfCompatible","_registerScript","once","waitingSW","then","wasWaitingBeforeRegister","debug","currentPageIsOutOfScope","scopeURL","URL","scope","baseURI","scopeURLBasePath","href","pathname","location","startsWith","update","active","promise","controlling","undefined","reg"],"mappings":"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UAAU,CAAC7B,SAAZ,EAAuB,KAAKgB,UAA5B,CAA3B,EAAoE;AAChE,aAAOa,UAAP;AACH,KAFD,MAGK;AACD,aAAOyD,SAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACyB,QAAfpB,eAAe,GAAG;AACpB,QAAI;AACA,YAAMqB,GAAG,GAAG,MAAM5D,SAAS,CAACC,aAAV,CAAwB4B,QAAxB,CAAiC,KAAKxC,UAAtC,EAAkD,KAAKd,gBAAvD,CAAlB,CADA,CAEA;AACA;AACA;;AACA,WAAKK,iBAAL,GAAyBU,WAAW,CAACC,GAAZ,EAAzB;AACA,aAAOqE,GAAP;AACH,KAPD,CAQA,OAAO7B,KAAP,EAAc;AACV,UAAIlC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvCnC,QAAAA,MAAM,CAACmE,KAAP,CAAaA,KAAb;AACH,OAHS,CAIV;;;AACA,YAAMA,KAAN;AACH;AACJ;;AA7aoC;;AA+azC,SAAS5D,OAAT,G,CACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { messageSW } from './messageSW.js';\nimport { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';\nimport { urlsMatch } from './utils/urlsMatch.js';\nimport { WorkboxEvent } from './utils/WorkboxEvent.js';\nimport './_version.js';\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n * @memberof module:workbox-window\n */\nclass Workbox extends WorkboxEventTarget {\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n     *\n     * @param {string} scriptURL The service worker script associated with this\n     *     instance.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n    constructor(scriptURL, registerOptions = {}) {\n        super();\n        this._registerOptions = {};\n        this._updateFoundCount = 0;\n        // Deferreds we can resolve later.\n        this._swDeferred = new Deferred();\n        this._activeDeferred = new Deferred();\n        this._controllingDeferred = new Deferred();\n        this._registrationTime = 0;\n        this._ownSWs = new Set();\n        /**\n         * @private\n         */\n        this._onUpdateFound = () => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const installingSW = registration.installing;\n            // If the script URL passed to `navigator.serviceWorker.register()` is\n            // different from the current controlling SW's script URL, we know any\n            // successful registration calls will trigger an `updatefound` event.\n            // But if the registered script URL is the same as the current controlling\n            // SW's script URL, we'll only get an `updatefound` event if the file\n            // changed since it was last registered. This can be a problem if the user\n            // opens up the same page in a different tab, and that page registers\n            // a SW that triggers an update. It's a problem because this page has no\n            // good way of knowing whether the `updatefound` event came from the SW\n            // script it registered or from a registration attempt made by a newer\n            // version of the page running in another tab.\n            // To minimize the possibility of a false positive, we use the logic here:\n            const updateLikelyTriggeredExternally = \n            // Since we enforce only calling `register()` once, and since we don't\n            // add the `updatefound` event listener until the `register()` call, if\n            // `_updateFoundCount` is > 0 then it means this method has already\n            // been called, thus this SW must be external\n            this._updateFoundCount > 0 ||\n                // If the script URL of the installing SW is different from this\n                // instance's script URL, we know it's definitely not from our\n                // registration.\n                !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n                // If all of the above are false, then we use a time-based heuristic:\n                // Any `updatefound` event that occurs long after our registration is\n                // assumed to be external.\n                (performance.now() >\n                    this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n            if (updateLikelyTriggeredExternally) {\n                this._externalSW = installingSW;\n                registration.removeEventListener('updatefound', this._onUpdateFound);\n            }\n            else {\n                // If the update was not triggered externally we know the installing\n                // SW is the one we registered, so we set it.\n                this._sw = installingSW;\n                this._ownSWs.add(installingSW);\n                this._swDeferred.resolve(installingSW);\n                // The `installing` state isn't something we have a dedicated\n                // callback for, but we do log messages for it in development.\n                if (process.env.NODE_ENV !== 'production') {\n                    if (navigator.serviceWorker.controller) {\n                        logger.log('Updated service worker found. Installing now...');\n                    }\n                    else {\n                        logger.log('Service worker is installing...');\n                    }\n                }\n            }\n            // Increment the `updatefound` count, so future invocations of this\n            // method can be sure they were triggered externally.\n            ++this._updateFoundCount;\n            // Add a `statechange` listener regardless of whether this update was\n            // triggered externally, since we have callbacks for both.\n            installingSW.addEventListener('statechange', this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onStateChange = (originalEvent) => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const sw = originalEvent.target;\n            const { state } = sw;\n            const isExternal = sw === this._externalSW;\n            const eventPrefix = isExternal ? 'external' : '';\n            const eventProps = {\n                sw,\n                originalEvent\n            };\n            if (!isExternal && this._isUpdate) {\n                eventProps.isUpdate = true;\n            }\n            this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n            if (state === 'installed') {\n                // This timeout is used to ignore cases where the service worker calls\n                // `skipWaiting()` in the install event, thus moving it directly in the\n                // activating state. (Since all service workers *must* go through the\n                // waiting phase, the only way to detect `skipWaiting()` called in the\n                // install event is to observe that the time spent in the waiting phase\n                // is very short.)\n                // NOTE: we don't need separate timeouts for the own and external SWs\n                // since they can't go through these phases at the same time.\n                this._waitingTimeout = self.setTimeout(() => {\n                    // Ensure the SW is still waiting (it may now be redundant).\n                    if (state === 'installed' && registration.waiting === sw) {\n                        this.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n                        if (process.env.NODE_ENV !== 'production') {\n                            if (isExternal) {\n                                logger.warn('An external service worker has installed but is ' +\n                                    'waiting for this client to close before activating...');\n                            }\n                            else {\n                                logger.warn('The service worker has installed but is waiting ' +\n                                    'for existing clients to close before activating...');\n                            }\n                        }\n                    }\n                }, WAITING_TIMEOUT_DURATION);\n            }\n            else if (state === 'activating') {\n                clearTimeout(this._waitingTimeout);\n                if (!isExternal) {\n                    this._activeDeferred.resolve(sw);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                switch (state) {\n                    case 'installed':\n                        if (isExternal) {\n                            logger.warn('An external service worker has installed. ' +\n                                'You may want to suggest users reload this page.');\n                        }\n                        else {\n                            logger.log('Registered service worker installed.');\n                        }\n                        break;\n                    case 'activated':\n                        if (isExternal) {\n                            logger.warn('An external service worker has activated.');\n                        }\n                        else {\n                            logger.log('Registered service worker activated.');\n                            if (sw !== navigator.serviceWorker.controller) {\n                                logger.warn('The registered service worker is active but ' +\n                                    'not yet controlling the page. Reload or run ' +\n                                    '`clients.claim()` in the service worker.');\n                            }\n                        }\n                        break;\n                    case 'redundant':\n                        if (sw === this._compatibleControllingSW) {\n                            logger.log('Previously controlling service worker now redundant!');\n                        }\n                        else if (!isExternal) {\n                            logger.log('Registered service worker now redundant!');\n                        }\n                        break;\n                }\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onControllerChange = (originalEvent) => {\n            const sw = this._sw;\n            if (sw === navigator.serviceWorker.controller) {\n                this.dispatchEvent(new WorkboxEvent('controlling', {\n                    sw,\n                    originalEvent,\n                    isUpdate: this._isUpdate,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log('Registered service worker now controlling this page.');\n                }\n                this._controllingDeferred.resolve(sw);\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onMessage = async (originalEvent) => {\n            const { data, source } = originalEvent;\n            // Wait until there's an \"own\" service worker. This is used to buffer\n            // `message` events that may be received prior to calling `register()`.\n            await this.getSW();\n            // If the service worker that sent the message is in the list of own\n            // service workers for this instance, dispatch a `message` event.\n            // NOTE: we check for all previously owned service workers rather than\n            // just the current one because some messages (e.g. cache updates) use\n            // a timeout when sent and may be delayed long enough for a service worker\n            // update to be found.\n            if (this._ownSWs.has(source)) {\n                this.dispatchEvent(new WorkboxEvent('message', {\n                    data,\n                    sw: source,\n                    originalEvent,\n                }));\n            }\n        };\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n        navigator.serviceWorker.addEventListener('message', this._onMessage);\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n    async register({ immediate = false } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._registrationTime) {\n                logger.error('Cannot re-register a Workbox instance after it has ' +\n                    'been registered. Create a new instance instead.');\n                return;\n            }\n        }\n        if (!immediate && document.readyState !== 'complete') {\n            await new Promise((res) => window.addEventListener('load', res));\n        }\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        // If we have a compatible controller, store the controller as the \"own\"\n        // SW, resolve active/controlling deferreds and add necessary listeners.\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });\n        }\n        // If there's a waiting service worker with a matching URL before the\n        // `updatefound` event fires, it likely means that this site is open\n        // in another tab, or the user refreshed the page (and thus the previous\n        // page wasn't fully unloaded before this page started loading).\n        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n        const waitingSW = this._registration.waiting;\n        if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            this._sw = waitingSW;\n            // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n            dontWaitFor(Promise.resolve().then(() => {\n                this.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn('A service worker was already waiting to activate ' +\n                        'before this script was registered...');\n                }\n            }));\n        }\n        // If an \"own\" SW is already set, resolve the deferred.\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log('Successfully registered service worker.', this._scriptURL);\n            if (navigator.serviceWorker.controller) {\n                if (this._compatibleControllingSW) {\n                    logger.debug('A service worker with the same script URL ' +\n                        'is already controlling this page.');\n                }\n                else {\n                    logger.debug('A service worker with a different script URL is ' +\n                        'currently controlling the page. The browser is now fetching ' +\n                        'the new script now...');\n                }\n            }\n            const currentPageIsOutOfScope = () => {\n                const scopeURL = new URL(this._registerOptions.scope || this._scriptURL, document.baseURI);\n                const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n                return !location.pathname.startsWith(scopeURLBasePath);\n            };\n            if (currentPageIsOutOfScope()) {\n                logger.warn('The current page is not in scope for the registered ' +\n                    'service worker. Was this a mistake?');\n            }\n        }\n        this._registration.addEventListener('updatefound', this._onUpdateFound);\n        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange, { once: true });\n        return this._registration;\n    }\n    /**\n     * Checks for updates of the registered service worker.\n     */\n    async update() {\n        if (!this._registration) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error('Cannot update a Workbox instance without ' +\n                    'being registered. Register the Workbox instance first.');\n            }\n            return;\n        }\n        // Try to update registration\n        await this._registration.update();\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    async getSW() {\n        // If `this._sw` is set, resolve with that as we want `getSW()` to\n        // return the correct (new) service worker if an update is found.\n        return this._sw !== undefined ? this._sw : this._swDeferred.promise;\n    }\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matches.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n            return controller;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n    async _registerScript() {\n        try {\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            // Keep track of when registration happened, so it can be used in the\n            // `this._onUpdateFound` heuristic. Also use the presence of this\n            // property as a way to see if `.register()` has been called.\n            this._registrationTime = performance.now();\n            return reg;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(error);\n            }\n            // Re-throw the error.\n            throw error;\n        }\n    }\n}\nexport { Workbox };\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n"]},"metadata":{},"sourceType":"module"}