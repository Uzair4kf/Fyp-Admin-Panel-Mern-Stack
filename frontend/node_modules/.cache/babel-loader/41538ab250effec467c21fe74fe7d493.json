{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport './_version.js';\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {module:workbox-streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\n\nfunction _getReaderFromSource(source) {\n  if (source instanceof Response) {\n    return source.body.getReader();\n  }\n\n  if (source instanceof ReadableStream) {\n    return source.getReader();\n  }\n\n  return new Response(source).body.getReader();\n}\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof module:workbox-streams\n */\n\n\nfunction concatenate(sourcePromises) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert.isArray(sourcePromises, {\n      moduleName: 'workbox-streams',\n      funcName: 'concatenate',\n      paramName: 'sourcePromises'\n    });\n  }\n\n  const readerPromises = sourcePromises.map(sourcePromise => {\n    return Promise.resolve(sourcePromise).then(source => {\n      return _getReaderFromSource(source);\n    });\n  });\n  const streamDeferred = new Deferred();\n  let i = 0;\n  const logMessages = [];\n  const stream = new ReadableStream({\n    pull(controller) {\n      return readerPromises[i].then(reader => reader.read()).then(result => {\n        if (result.done) {\n          if (process.env.NODE_ENV !== 'production') {\n            logMessages.push(['Reached the end of source:', sourcePromises[i]]);\n          }\n\n          i++;\n\n          if (i >= readerPromises.length) {\n            // Log all the messages in the group at once in a single group.\n            if (process.env.NODE_ENV !== 'production') {\n              logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n\n              for (const message of logMessages) {\n                if (Array.isArray(message)) {\n                  logger.log(...message);\n                } else {\n                  logger.log(message);\n                }\n              }\n\n              logger.log('Finished reading all sources.');\n              logger.groupEnd();\n            }\n\n            controller.close();\n            streamDeferred.resolve();\n            return;\n          } // The `pull` method is defined because we're inside it.\n\n\n          return this.pull(controller);\n        } else {\n          controller.enqueue(result.value);\n        }\n      }).catch(error => {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.error('An error occurred:', error);\n        }\n\n        streamDeferred.reject(error);\n        throw error;\n      });\n    },\n\n    cancel() {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn('The ReadableStream was cancelled.');\n      }\n\n      streamDeferred.resolve();\n    }\n\n  });\n  return {\n    done: streamDeferred.promise,\n    stream\n  };\n}\n\nexport { concatenate };","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/workbox-streams/concatenate.js"],"names":["logger","assert","Deferred","_getReaderFromSource","source","Response","body","getReader","ReadableStream","concatenate","sourcePromises","process","env","NODE_ENV","isArray","moduleName","funcName","paramName","readerPromises","map","sourcePromise","Promise","resolve","then","streamDeferred","i","logMessages","stream","pull","controller","reader","read","result","done","push","length","groupCollapsed","message","Array","log","groupEnd","close","enqueue","value","catch","error","reject","cancel","warn","promise"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport './_version.js';\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {module:workbox-streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n    if (source instanceof Response) {\n        return source.body.getReader();\n    }\n    if (source instanceof ReadableStream) {\n        return source.getReader();\n    }\n    return new Response(source).body.getReader();\n}\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof module:workbox-streams\n */\nfunction concatenate(sourcePromises) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(sourcePromises, {\n            moduleName: 'workbox-streams',\n            funcName: 'concatenate',\n            paramName: 'sourcePromises',\n        });\n    }\n    const readerPromises = sourcePromises.map((sourcePromise) => {\n        return Promise.resolve(sourcePromise).then((source) => {\n            return _getReaderFromSource(source);\n        });\n    });\n    const streamDeferred = new Deferred();\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n        pull(controller) {\n            return readerPromises[i]\n                .then((reader) => reader.read())\n                .then((result) => {\n                if (result.done) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logMessages.push(['Reached the end of source:',\n                            sourcePromises[i]]);\n                    }\n                    i++;\n                    if (i >= readerPromises.length) {\n                        // Log all the messages in the group at once in a single group.\n                        if (process.env.NODE_ENV !== 'production') {\n                            logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n                            for (const message of logMessages) {\n                                if (Array.isArray(message)) {\n                                    logger.log(...message);\n                                }\n                                else {\n                                    logger.log(message);\n                                }\n                            }\n                            logger.log('Finished reading all sources.');\n                            logger.groupEnd();\n                        }\n                        controller.close();\n                        streamDeferred.resolve();\n                        return;\n                    }\n                    // The `pull` method is defined because we're inside it.\n                    return this.pull(controller);\n                }\n                else {\n                    controller.enqueue(result.value);\n                }\n            }).catch((error) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.error('An error occurred:', error);\n                }\n                streamDeferred.reject(error);\n                throw error;\n            });\n        },\n        cancel() {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn('The ReadableStream was cancelled.');\n            }\n            streamDeferred.resolve();\n        },\n    });\n    return { done: streamDeferred.promise, stream };\n}\nexport { concatenate };\n"]},"metadata":{},"sourceType":"module"}