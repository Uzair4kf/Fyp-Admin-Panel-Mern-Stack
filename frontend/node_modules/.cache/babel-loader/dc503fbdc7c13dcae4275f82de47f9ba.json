{"ast":null,"code":"try {\n  self['workbox:window:5.1.4'] && _();\n} catch (e) {}\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n * @memberof module:workbox-window\n */\n\n\nfunction messageSW(sw, data) {\n  return new Promise(function (resolve) {\n    var messageChannel = new MessageChannel();\n\n    messageChannel.port1.onmessage = function (event) {\n      resolve(event.data);\n    };\n\n    sw.postMessage(data, [messageChannel.port2]);\n  });\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\ntry {\n  self['workbox:core:5.1.4'] && _();\n} catch (e) {}\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\n\n\nvar Deferred =\n/**\n * Creates a promise and exposes its resolve and reject functions as methods.\n */\nfunction Deferred() {\n  var _this = this;\n\n  this.promise = new Promise(function (resolve, reject) {\n    _this.resolve = resolve;\n    _this.reject = reject;\n  });\n};\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\n\n\nfunction dontWaitFor(promise) {\n  // Effective no-op.\n  promise.then(function () {});\n}\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nvar logger = function () {\n  // Don't overwrite this value if it's already set.\n  // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n  if (!('__WB_DISABLE_DEV_LOGS' in self)) {\n    self.__WB_DISABLE_DEV_LOGS = false;\n  }\n\n  var inGroup = false;\n  var methodToColorMap = {\n    debug: \"#7f8c8d\",\n    log: \"#2ecc71\",\n    warn: \"#f39c12\",\n    error: \"#c0392b\",\n    groupCollapsed: \"#3498db\",\n    groupEnd: null\n  };\n\n  var print = function print(method, args) {\n    var _console2;\n\n    if (self.__WB_DISABLE_DEV_LOGS) {\n      return;\n    }\n\n    if (method === 'groupCollapsed') {\n      // Safari doesn't print all console.groupCollapsed() arguments:\n      // https://bugs.webkit.org/show_bug.cgi?id=182754\n      if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        var _console;\n\n        (_console = console)[method].apply(_console, args);\n\n        return;\n      }\n    }\n\n    var styles = [\"background: \" + methodToColorMap[method], \"border-radius: 0.5em\", \"color: white\", \"font-weight: bold\", \"padding: 2px 0.5em\"]; // When in a group, the workbox prefix is not displayed.\n\n    var logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n\n    (_console2 = console)[method].apply(_console2, logPrefix.concat(args));\n\n    if (method === 'groupCollapsed') {\n      inGroup = true;\n    }\n\n    if (method === 'groupEnd') {\n      inGroup = false;\n    }\n  };\n\n  var api = {};\n  var loggerMethods = Object.keys(methodToColorMap);\n\n  var _loop = function _loop() {\n    var key = _loggerMethods[_i];\n    var method = key;\n\n    api[method] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      print(method, args);\n    };\n  };\n\n  for (var _i = 0, _loggerMethods = loggerMethods; _i < _loggerMethods.length; _i++) {\n    _loop();\n  }\n\n  return api;\n}();\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\n\n\nvar WorkboxEventTarget = /*#__PURE__*/function () {\n  function WorkboxEventTarget() {\n    this._eventListenerRegistry = new Map();\n  }\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n\n\n  var _proto = WorkboxEventTarget.prototype;\n\n  _proto.addEventListener = function addEventListener(type, listener) {\n    var foo = this._getEventListenersByType(type);\n\n    foo.add(listener);\n  }\n  /**\n   * @param {string} type\n   * @param {Function} listener\n   * @private\n   */\n  ;\n\n  _proto.removeEventListener = function removeEventListener(type, listener) {\n    this._getEventListenersByType(type).delete(listener);\n  }\n  /**\n   * @param {Object} event\n   * @private\n   */\n  ;\n\n  _proto.dispatchEvent = function dispatchEvent(event) {\n    event.target = this;\n\n    var listeners = this._getEventListenersByType(event.type);\n\n    for (var _iterator = _createForOfIteratorHelperLoose(listeners), _step; !(_step = _iterator()).done;) {\n      var listener = _step.value;\n      listener(event);\n    }\n  }\n  /**\n   * Returns a Set of listeners associated with the passed event type.\n   * If no handlers have been registered, an empty Set is returned.\n   *\n   * @param {string} type The event type.\n   * @return {Set<ListenerCallback>} An array of handler functions.\n   * @private\n   */\n  ;\n\n  _proto._getEventListenersByType = function _getEventListenersByType(type) {\n    if (!this._eventListenerRegistry.has(type)) {\n      this._eventListenerRegistry.set(type, new Set());\n    }\n\n    return this._eventListenerRegistry.get(type);\n  };\n\n  return WorkboxEventTarget;\n}();\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\n\n\nfunction urlsMatch(url1, url2) {\n  var _location = location,\n      href = _location.href;\n  return new URL(url1, href).href === new URL(url2, href).href;\n}\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\n\n\nvar WorkboxEvent = function WorkboxEvent(type, props) {\n  this.type = type;\n  Object.assign(this, props);\n}; // `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\n\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nvar WAITING_TIMEOUT_DURATION = 200; // The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nvar REGISTRATION_TIMEOUT_DURATION = 60000;\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n * @memberof module:workbox-window\n */\n\nfunction _empty() {}\n\nvar Workbox = /*#__PURE__*/function (_WorkboxEventTarget) {\n  _inheritsLoose(Workbox, _WorkboxEventTarget);\n  /**\n   * Creates a new Workbox instance with a script URL and service worker\n   * options. The script URL and options are the same as those used when\n   * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n   * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n   *\n   * @param {string} scriptURL The service worker script associated with this\n   *     instance.\n   * @param {Object} [registerOptions] The service worker options associated\n   *     with this instance.\n   */\n\n\n  function Workbox(scriptURL, registerOptions) {\n    var _this;\n\n    if (registerOptions === void 0) {\n      registerOptions = {};\n    }\n\n    _this = _WorkboxEventTarget.call(this) || this;\n    _this._registerOptions = {};\n    _this._updateFoundCount = 0; // Deferreds we can resolve later.\n\n    _this._swDeferred = new Deferred();\n    _this._activeDeferred = new Deferred();\n    _this._controllingDeferred = new Deferred();\n    _this._registrationTime = 0;\n    _this._ownSWs = new Set();\n    /**\n     * @private\n     */\n\n    _this._onUpdateFound = function () {\n      // `this._registration` will never be `undefined` after an update is found.\n      var registration = _this._registration;\n      var installingSW = registration.installing; // If the script URL passed to `navigator.serviceWorker.register()` is\n      // different from the current controlling SW's script URL, we know any\n      // successful registration calls will trigger an `updatefound` event.\n      // But if the registered script URL is the same as the current controlling\n      // SW's script URL, we'll only get an `updatefound` event if the file\n      // changed since it was last registered. This can be a problem if the user\n      // opens up the same page in a different tab, and that page registers\n      // a SW that triggers an update. It's a problem because this page has no\n      // good way of knowing whether the `updatefound` event came from the SW\n      // script it registered or from a registration attempt made by a newer\n      // version of the page running in another tab.\n      // To minimize the possibility of a false positive, we use the logic here:\n\n      var updateLikelyTriggeredExternally = // Since we enforce only calling `register()` once, and since we don't\n      // add the `updatefound` event listener until the `register()` call, if\n      // `_updateFoundCount` is > 0 then it means this method has already\n      // been called, thus this SW must be external\n      _this._updateFoundCount > 0 || // If the script URL of the installing SW is different from this\n      // instance's script URL, we know it's definitely not from our\n      // registration.\n      !urlsMatch(installingSW.scriptURL, _this._scriptURL) || // If all of the above are false, then we use a time-based heuristic:\n      // Any `updatefound` event that occurs long after our registration is\n      // assumed to be external.\n      performance.now() > _this._registrationTime + REGISTRATION_TIMEOUT_DURATION ? // If any of the above are not true, we assume the update was\n      // triggered by this instance.\n      true : false;\n\n      if (updateLikelyTriggeredExternally) {\n        _this._externalSW = installingSW;\n        registration.removeEventListener('updatefound', _this._onUpdateFound);\n      } else {\n        // If the update was not triggered externally we know the installing\n        // SW is the one we registered, so we set it.\n        _this._sw = installingSW;\n\n        _this._ownSWs.add(installingSW);\n\n        _this._swDeferred.resolve(installingSW); // The `installing` state isn't something we have a dedicated\n        // callback for, but we do log messages for it in development.\n\n\n        {\n          if (navigator.serviceWorker.controller) {\n            logger.log('Updated service worker found. Installing now...');\n          } else {\n            logger.log('Service worker is installing...');\n          }\n        }\n      } // Increment the `updatefound` count, so future invocations of this\n      // method can be sure they were triggered externally.\n\n\n      ++_this._updateFoundCount; // Add a `statechange` listener regardless of whether this update was\n      // triggered externally, since we have callbacks for both.\n\n      installingSW.addEventListener('statechange', _this._onStateChange);\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    _this._onStateChange = function (originalEvent) {\n      // `this._registration` will never be `undefined` after an update is found.\n      var registration = _this._registration;\n      var sw = originalEvent.target;\n      var state = sw.state;\n      var isExternal = sw === _this._externalSW;\n      var eventPrefix = isExternal ? 'external' : '';\n      var eventProps = {\n        sw: sw,\n        originalEvent: originalEvent\n      };\n\n      if (!isExternal && _this._isUpdate) {\n        eventProps.isUpdate = true;\n      }\n\n      _this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n\n      if (state === 'installed') {\n        // This timeout is used to ignore cases where the service worker calls\n        // `skipWaiting()` in the install event, thus moving it directly in the\n        // activating state. (Since all service workers *must* go through the\n        // waiting phase, the only way to detect `skipWaiting()` called in the\n        // install event is to observe that the time spent in the waiting phase\n        // is very short.)\n        // NOTE: we don't need separate timeouts for the own and external SWs\n        // since they can't go through these phases at the same time.\n        _this._waitingTimeout = self.setTimeout(function () {\n          // Ensure the SW is still waiting (it may now be redundant).\n          if (state === 'installed' && registration.waiting === sw) {\n            _this.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n\n            {\n              if (isExternal) {\n                logger.warn('An external service worker has installed but is ' + 'waiting for this client to close before activating...');\n              } else {\n                logger.warn('The service worker has installed but is waiting ' + 'for existing clients to close before activating...');\n              }\n            }\n          }\n        }, WAITING_TIMEOUT_DURATION);\n      } else if (state === 'activating') {\n        clearTimeout(_this._waitingTimeout);\n\n        if (!isExternal) {\n          _this._activeDeferred.resolve(sw);\n        }\n      }\n\n      {\n        switch (state) {\n          case 'installed':\n            if (isExternal) {\n              logger.warn('An external service worker has installed. ' + 'You may want to suggest users reload this page.');\n            } else {\n              logger.log('Registered service worker installed.');\n            }\n\n            break;\n\n          case 'activated':\n            if (isExternal) {\n              logger.warn('An external service worker has activated.');\n            } else {\n              logger.log('Registered service worker activated.');\n\n              if (sw !== navigator.serviceWorker.controller) {\n                logger.warn('The registered service worker is active but ' + 'not yet controlling the page. Reload or run ' + '`clients.claim()` in the service worker.');\n              }\n            }\n\n            break;\n\n          case 'redundant':\n            if (sw === _this._compatibleControllingSW) {\n              logger.log('Previously controlling service worker now redundant!');\n            } else if (!isExternal) {\n              logger.log('Registered service worker now redundant!');\n            }\n\n            break;\n        }\n      }\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    _this._onControllerChange = function (originalEvent) {\n      var sw = _this._sw;\n\n      if (sw === navigator.serviceWorker.controller) {\n        _this.dispatchEvent(new WorkboxEvent('controlling', {\n          sw: sw,\n          originalEvent: originalEvent,\n          isUpdate: _this._isUpdate\n        }));\n\n        {\n          logger.log('Registered service worker now controlling this page.');\n        }\n\n        _this._controllingDeferred.resolve(sw);\n      }\n    };\n    /**\n     * @private\n     * @param {Event} originalEvent\n     */\n\n\n    _this._onMessage = _async(function (originalEvent) {\n      var data = originalEvent.data,\n          source = originalEvent.source; // Wait until there's an \"own\" service worker. This is used to buffer\n      // `message` events that may be received prior to calling `register()`.\n\n      return _await(_this.getSW(), function () {\n        if (_this._ownSWs.has(source)) {\n          _this.dispatchEvent(new WorkboxEvent('message', {\n            data: data,\n            sw: source,\n            originalEvent: originalEvent\n          }));\n        }\n      }); // If the service worker that sent the message is in the list of own\n      // service workers for this instance, dispatch a `message` event.\n      // NOTE: we check for all previously owned service workers rather than\n      // just the current one because some messages (e.g. cache updates) use\n      // a timeout when sent and may be delayed long enough for a service worker\n      // update to be found.\n    });\n    _this._scriptURL = scriptURL;\n    _this._registerOptions = registerOptions; // Add a message listener immediately since messages received during\n    // page load are buffered only until the DOMContentLoaded event:\n    // https://github.com/GoogleChrome/workbox/issues/2202\n\n    navigator.serviceWorker.addEventListener('message', _this._onMessage);\n    return _this;\n  }\n  /**\n   * Registers a service worker for this instances script URL and service\n   * worker options. By default this method delays registration until after\n   * the window has loaded.\n   *\n   * @param {Object} [options]\n   * @param {Function} [options.immediate=false] Setting this to true will\n   *     register the service worker immediately, even if the window has\n   *     not loaded (not recommended).\n   */\n\n\n  var _proto = Workbox.prototype;\n\n  _proto.register = function register(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$immediate = _ref.immediate,\n        immediate = _ref$immediate === void 0 ? false : _ref$immediate;\n\n    try {\n      var _this3 = this;\n\n      if (\"dev\" !== 'production') {\n        if (_this3._registrationTime) {\n          logger.error('Cannot re-register a Workbox instance after it has ' + 'been registered. Create a new instance instead.');\n          return;\n        }\n      }\n\n      return _invoke(function () {\n        if (!immediate && document.readyState !== 'complete') {\n          return _awaitIgnored(new Promise(function (res) {\n            return window.addEventListener('load', res);\n          }));\n        }\n      }, function () {\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        _this3._isUpdate = Boolean(navigator.serviceWorker.controller); // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n\n        _this3._compatibleControllingSW = _this3._getControllingSWIfCompatible();\n        return _await(_this3._registerScript(), function (_this2$_registerScrip) {\n          _this3._registration = _this2$_registerScrip; // If we have a compatible controller, store the controller as the \"own\"\n          // SW, resolve active/controlling deferreds and add necessary listeners.\n\n          if (_this3._compatibleControllingSW) {\n            _this3._sw = _this3._compatibleControllingSW;\n\n            _this3._activeDeferred.resolve(_this3._compatibleControllingSW);\n\n            _this3._controllingDeferred.resolve(_this3._compatibleControllingSW);\n\n            _this3._compatibleControllingSW.addEventListener('statechange', _this3._onStateChange, {\n              once: true\n            });\n          } // If there's a waiting service worker with a matching URL before the\n          // `updatefound` event fires, it likely means that this site is open\n          // in another tab, or the user refreshed the page (and thus the previous\n          // page wasn't fully unloaded before this page started loading).\n          // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n\n\n          var waitingSW = _this3._registration.waiting;\n\n          if (waitingSW && urlsMatch(waitingSW.scriptURL, _this3._scriptURL)) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            _this3._sw = waitingSW; // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n\n            dontWaitFor(Promise.resolve().then(function () {\n              _this3.dispatchEvent(new WorkboxEvent('waiting', {\n                sw: waitingSW,\n                wasWaitingBeforeRegister: true\n              }));\n\n              if (\"dev\" !== 'production') {\n                logger.warn('A service worker was already waiting to activate ' + 'before this script was registered...');\n              }\n            }));\n          } // If an \"own\" SW is already set, resolve the deferred.\n\n\n          if (_this3._sw) {\n            _this3._swDeferred.resolve(_this3._sw);\n\n            _this3._ownSWs.add(_this3._sw);\n          }\n\n          if (\"dev\" !== 'production') {\n            logger.log('Successfully registered service worker.', _this3._scriptURL);\n\n            if (navigator.serviceWorker.controller) {\n              if (_this3._compatibleControllingSW) {\n                logger.debug('A service worker with the same script URL ' + 'is already controlling this page.');\n              } else {\n                logger.debug('A service worker with a different script URL is ' + 'currently controlling the page. The browser is now fetching ' + 'the new script now...');\n              }\n            }\n\n            var currentPageIsOutOfScope = function currentPageIsOutOfScope() {\n              var scopeURL = new URL(_this3._registerOptions.scope || _this3._scriptURL, document.baseURI);\n              var scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n              return !location.pathname.startsWith(scopeURLBasePath);\n            };\n\n            if (currentPageIsOutOfScope()) {\n              logger.warn('The current page is not in scope for the registered ' + 'service worker. Was this a mistake?');\n            }\n          }\n\n          _this3._registration.addEventListener('updatefound', _this3._onUpdateFound);\n\n          navigator.serviceWorker.addEventListener('controllerchange', _this3._onControllerChange, {\n            once: true\n          });\n          return _this3._registration;\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Checks for updates of the registered service worker.\n   */\n  ;\n\n  _proto.update = function update() {\n    try {\n      var _this5 = this;\n\n      if (!_this5._registration) {\n        if (\"dev\" !== 'production') {\n          logger.error('Cannot update a Workbox instance without ' + 'being registered. Register the Workbox instance first.');\n        }\n\n        return;\n      } // Try to update registration\n\n\n      return _awaitIgnored(_this5._registration.update());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Resolves to the service worker registered by this instance as soon as it\n   * is active. If a service worker was already controlling at registration\n   * time then it will resolve to that if the script URLs (and optionally\n   * script versions) match, otherwise it will wait until an update is found\n   * and activates.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n  ;\n  /**\n   * Resolves with a reference to a service worker that matches the script URL\n   * of this instance, as soon as it's available.\n   *\n   * If, at registration time, there's already an active or waiting service\n   * worker with a matching script URL, it will be used (with the waiting\n   * service worker taking precedence over the active service worker if both\n   * match, since the waiting service worker would have been registered more\n   * recently).\n   * If there's no matching active or waiting service worker at registration\n   * time then the promise will not resolve until an update is found and starts\n   * installing, at which point the installing service worker is used.\n   *\n   * @return {Promise<ServiceWorker>}\n   */\n\n\n  _proto.getSW = function getSW() {\n    try {\n      var _this7 = this; // If `this._sw` is set, resolve with that as we want `getSW()` to\n      // return the correct (new) service worker if an update is found.\n\n\n      return _this7._sw !== undefined ? _this7._sw : _this7._swDeferred.promise;\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Sends the passed data object to the service worker registered by this\n   * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n   * with a response (if any).\n   *\n   * A response can be set in a message handler in the service worker by\n   * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n   * returned by `messageSW()`. If no response is set, the promise will never\n   * resolve.\n   *\n   * @param {Object} data An object to send to the service worker\n   * @return {Promise<Object>}\n   */\n  ;\n\n  _proto.messageSW = function messageSW$1(data) {\n    try {\n      var _this9 = this;\n\n      return _await(_this9.getSW(), function (sw) {\n        return messageSW(sw, data);\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Checks for a service worker already controlling the page and returns\n   * it if its script URL matches.\n   *\n   * @private\n   * @return {ServiceWorker|undefined}\n   */\n  ;\n\n  _proto._getControllingSWIfCompatible = function _getControllingSWIfCompatible() {\n    var controller = navigator.serviceWorker.controller;\n\n    if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n      return controller;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Registers a service worker for this instances script URL and register\n   * options and tracks the time registration was complete.\n   *\n   * @private\n   */\n  ;\n\n  _proto._registerScript = function _registerScript() {\n    try {\n      var _this11 = this;\n\n      return _catch(function () {\n        return _await(navigator.serviceWorker.register(_this11._scriptURL, _this11._registerOptions), function (reg) {\n          // Keep track of when registration happened, so it can be used in the\n          // `this._onUpdateFound` heuristic. Also use the presence of this\n          // property as a way to see if `.register()` has been called.\n          _this11._registrationTime = performance.now();\n          return reg;\n        });\n      }, function (error) {\n        if (\"dev\" !== 'production') {\n          logger.error(error);\n        } // Re-throw the error.\n\n\n        throw error;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _createClass(Workbox, [{\n    key: \"active\",\n    get: function get() {\n      return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n\n  }, {\n    key: \"controlling\",\n    get: function get() {\n      return this._controllingDeferred.promise;\n    }\n  }]);\n\n  return Workbox;\n}(WorkboxEventTarget);\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n} // The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nexport { Workbox, messageSW };","map":{"version":3,"sources":["../_version.js","../messageSW.js","../../workbox-core/_version.js","../../workbox-core/_private/Deferred.js","../../workbox-core/_private/dontWaitFor.js","../../workbox-core/_private/logger.js","../utils/WorkboxEventTarget.js","../utils/urlsMatch.js","../utils/WorkboxEvent.js","../Workbox.js"],"names":["self","_","messageChannel","resolve","event","sw","Deferred","promise","logger","inGroup","methodToColorMap","debug","log","warn","error","groupCollapsed","groupEnd","print","method","navigator","styles","logPrefix","api","loggerMethods","Object","key","args","WorkboxEventTarget","addEventListener","foo","removeEventListener","dispatchEvent","listeners","listener","_getEventListenersByType","href","WorkboxEvent","WAITING_TIMEOUT_DURATION","REGISTRATION_TIMEOUT_DURATION","Workbox","registerOptions","registration","installingSW","i","arguments","Promise","f","updateLikelyTriggeredExternally","then","urlsMatch","value","performance","originalEvent","state","isExternal","eventPrefix","eventProps","clearTimeout","isUpdate","_isUpdate","data","source","register","immediate","process","document","window","Boolean","once","waitingSW","dontWaitFor","wasWaitingBeforeRegister","currentPageIsOutOfScope","scopeURL","scopeURLBasePath","location","update","getSW","messageSW","_getControllingSWIfCompatible","controller","_registerScript","result","body","recover"],"mappings":"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","sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:window:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n * @memberof module:workbox-window\n */\nfunction messageSW(sw, data) {\n    return new Promise((resolve) => {\n        const messageChannel = new MessageChannel();\n        messageChannel.port1.onmessage = (event) => {\n            resolve(event.data);\n        };\n        sw.postMessage(data, [messageChannel.port2]);\n    });\n}\nexport { messageSW };\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nexport { Deferred };\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    promise.then(() => { });\n}\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nconst logger = (process.env.NODE_ENV === 'production' ? null : (() => {\n    // Don't overwrite this value if it's already set.\n    // See https://github.com/GoogleChrome/workbox/pull/2284#issuecomment-560470923\n    if (!('__WB_DISABLE_DEV_LOGS' in self)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n    }\n    let inGroup = false;\n    const methodToColorMap = {\n        debug: `#7f8c8d`,\n        log: `#2ecc71`,\n        warn: `#f39c12`,\n        error: `#c0392b`,\n        groupCollapsed: `#3498db`,\n        groupEnd: null,\n    };\n    const print = function (method, args) {\n        if (self.__WB_DISABLE_DEV_LOGS) {\n            return;\n        }\n        if (method === 'groupCollapsed') {\n            // Safari doesn't print all console.groupCollapsed() arguments:\n            // https://bugs.webkit.org/show_bug.cgi?id=182754\n            if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                console[method](...args);\n                return;\n            }\n        }\n        const styles = [\n            `background: ${methodToColorMap[method]}`,\n            `border-radius: 0.5em`,\n            `color: white`,\n            `font-weight: bold`,\n            `padding: 2px 0.5em`,\n        ];\n        // When in a group, the workbox prefix is not displayed.\n        const logPrefix = inGroup ? [] : ['%cworkbox', styles.join(';')];\n        console[method](...logPrefix, ...args);\n        if (method === 'groupCollapsed') {\n            inGroup = true;\n        }\n        if (method === 'groupEnd') {\n            inGroup = false;\n        }\n    };\n    const api = {};\n    const loggerMethods = Object.keys(methodToColorMap);\n    for (const key of loggerMethods) {\n        const method = key;\n        api[method] = (...args) => {\n            print(method, args);\n        };\n    }\n    return api;\n})());\nexport { logger };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nexport class WorkboxEventTarget {\n    constructor() {\n        this._eventListenerRegistry = new Map();\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    addEventListener(type, listener) {\n        const foo = this._getEventListenersByType(type);\n        foo.add(listener);\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n    }\n    /**\n     * @param {Object} event\n     * @private\n     */\n    dispatchEvent(event) {\n        event.target = this;\n        const listeners = this._getEventListenersByType(event.type);\n        for (const listener of listeners) {\n            listener(event);\n        }\n    }\n    /**\n     * Returns a Set of listeners associated with the passed event type.\n     * If no handlers have been registered, an empty Set is returned.\n     *\n     * @param {string} type The event type.\n     * @return {Set<ListenerCallback>} An array of handler functions.\n     * @private\n     */\n    _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n            this._eventListenerRegistry.set(type, new Set());\n        }\n        return this._eventListenerRegistry.get(type);\n    }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nexport function urlsMatch(url1, url2) {\n    const { href } = location;\n    return new URL(url1, href).href === new URL(url2, href).href;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nexport class WorkboxEvent {\n    constructor(type, props) {\n        this.type = type;\n        Object.assign(this, props);\n    }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { messageSW } from './messageSW.js';\nimport { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';\nimport { urlsMatch } from './utils/urlsMatch.js';\nimport { WorkboxEvent } from './utils/WorkboxEvent.js';\nimport './_version.js';\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires [message]{@link module:workbox-window.Workbox#message}\n * @fires [installed]{@link module:workbox-window.Workbox#installed}\n * @fires [waiting]{@link module:workbox-window.Workbox#waiting}\n * @fires [controlling]{@link module:workbox-window.Workbox#controlling}\n * @fires [activated]{@link module:workbox-window.Workbox#activated}\n * @fires [redundant]{@link module:workbox-window.Workbox#redundant}\n * @fires [externalinstalled]{@link module:workbox-window.Workbox#externalinstalled}\n * @fires [externalwaiting]{@link module:workbox-window.Workbox#externalwaiting}\n * @fires [externalactivated]{@link module:workbox-window.Workbox#externalactivated}\n * @memberof module:workbox-window\n */\nclass Workbox extends WorkboxEventTarget {\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling `navigator.serviceWorker.register(scriptURL, options)`. See:\n     * https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register\n     *\n     * @param {string} scriptURL The service worker script associated with this\n     *     instance.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n    constructor(scriptURL, registerOptions = {}) {\n        super();\n        this._registerOptions = {};\n        this._updateFoundCount = 0;\n        // Deferreds we can resolve later.\n        this._swDeferred = new Deferred();\n        this._activeDeferred = new Deferred();\n        this._controllingDeferred = new Deferred();\n        this._registrationTime = 0;\n        this._ownSWs = new Set();\n        /**\n         * @private\n         */\n        this._onUpdateFound = () => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const installingSW = registration.installing;\n            // If the script URL passed to `navigator.serviceWorker.register()` is\n            // different from the current controlling SW's script URL, we know any\n            // successful registration calls will trigger an `updatefound` event.\n            // But if the registered script URL is the same as the current controlling\n            // SW's script URL, we'll only get an `updatefound` event if the file\n            // changed since it was last registered. This can be a problem if the user\n            // opens up the same page in a different tab, and that page registers\n            // a SW that triggers an update. It's a problem because this page has no\n            // good way of knowing whether the `updatefound` event came from the SW\n            // script it registered or from a registration attempt made by a newer\n            // version of the page running in another tab.\n            // To minimize the possibility of a false positive, we use the logic here:\n            const updateLikelyTriggeredExternally = \n            // Since we enforce only calling `register()` once, and since we don't\n            // add the `updatefound` event listener until the `register()` call, if\n            // `_updateFoundCount` is > 0 then it means this method has already\n            // been called, thus this SW must be external\n            this._updateFoundCount > 0 ||\n                // If the script URL of the installing SW is different from this\n                // instance's script URL, we know it's definitely not from our\n                // registration.\n                !urlsMatch(installingSW.scriptURL, this._scriptURL) ||\n                // If all of the above are false, then we use a time-based heuristic:\n                // Any `updatefound` event that occurs long after our registration is\n                // assumed to be external.\n                (performance.now() >\n                    this._registrationTime + REGISTRATION_TIMEOUT_DURATION) ?\n                // If any of the above are not true, we assume the update was\n                // triggered by this instance.\n                true : false;\n            if (updateLikelyTriggeredExternally) {\n                this._externalSW = installingSW;\n                registration.removeEventListener('updatefound', this._onUpdateFound);\n            }\n            else {\n                // If the update was not triggered externally we know the installing\n                // SW is the one we registered, so we set it.\n                this._sw = installingSW;\n                this._ownSWs.add(installingSW);\n                this._swDeferred.resolve(installingSW);\n                // The `installing` state isn't something we have a dedicated\n                // callback for, but we do log messages for it in development.\n                if (process.env.NODE_ENV !== 'production') {\n                    if (navigator.serviceWorker.controller) {\n                        logger.log('Updated service worker found. Installing now...');\n                    }\n                    else {\n                        logger.log('Service worker is installing...');\n                    }\n                }\n            }\n            // Increment the `updatefound` count, so future invocations of this\n            // method can be sure they were triggered externally.\n            ++this._updateFoundCount;\n            // Add a `statechange` listener regardless of whether this update was\n            // triggered externally, since we have callbacks for both.\n            installingSW.addEventListener('statechange', this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onStateChange = (originalEvent) => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const sw = originalEvent.target;\n            const { state } = sw;\n            const isExternal = sw === this._externalSW;\n            const eventPrefix = isExternal ? 'external' : '';\n            const eventProps = {\n                sw,\n                originalEvent\n            };\n            if (!isExternal && this._isUpdate) {\n                eventProps.isUpdate = true;\n            }\n            this.dispatchEvent(new WorkboxEvent(eventPrefix + state, eventProps));\n            if (state === 'installed') {\n                // This timeout is used to ignore cases where the service worker calls\n                // `skipWaiting()` in the install event, thus moving it directly in the\n                // activating state. (Since all service workers *must* go through the\n                // waiting phase, the only way to detect `skipWaiting()` called in the\n                // install event is to observe that the time spent in the waiting phase\n                // is very short.)\n                // NOTE: we don't need separate timeouts for the own and external SWs\n                // since they can't go through these phases at the same time.\n                this._waitingTimeout = self.setTimeout(() => {\n                    // Ensure the SW is still waiting (it may now be redundant).\n                    if (state === 'installed' && registration.waiting === sw) {\n                        this.dispatchEvent(new WorkboxEvent(eventPrefix + 'waiting', eventProps));\n                        if (process.env.NODE_ENV !== 'production') {\n                            if (isExternal) {\n                                logger.warn('An external service worker has installed but is ' +\n                                    'waiting for this client to close before activating...');\n                            }\n                            else {\n                                logger.warn('The service worker has installed but is waiting ' +\n                                    'for existing clients to close before activating...');\n                            }\n                        }\n                    }\n                }, WAITING_TIMEOUT_DURATION);\n            }\n            else if (state === 'activating') {\n                clearTimeout(this._waitingTimeout);\n                if (!isExternal) {\n                    this._activeDeferred.resolve(sw);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                switch (state) {\n                    case 'installed':\n                        if (isExternal) {\n                            logger.warn('An external service worker has installed. ' +\n                                'You may want to suggest users reload this page.');\n                        }\n                        else {\n                            logger.log('Registered service worker installed.');\n                        }\n                        break;\n                    case 'activated':\n                        if (isExternal) {\n                            logger.warn('An external service worker has activated.');\n                        }\n                        else {\n                            logger.log('Registered service worker activated.');\n                            if (sw !== navigator.serviceWorker.controller) {\n                                logger.warn('The registered service worker is active but ' +\n                                    'not yet controlling the page. Reload or run ' +\n                                    '`clients.claim()` in the service worker.');\n                            }\n                        }\n                        break;\n                    case 'redundant':\n                        if (sw === this._compatibleControllingSW) {\n                            logger.log('Previously controlling service worker now redundant!');\n                        }\n                        else if (!isExternal) {\n                            logger.log('Registered service worker now redundant!');\n                        }\n                        break;\n                }\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onControllerChange = (originalEvent) => {\n            const sw = this._sw;\n            if (sw === navigator.serviceWorker.controller) {\n                this.dispatchEvent(new WorkboxEvent('controlling', {\n                    sw,\n                    originalEvent,\n                    isUpdate: this._isUpdate,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log('Registered service worker now controlling this page.');\n                }\n                this._controllingDeferred.resolve(sw);\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onMessage = async (originalEvent) => {\n            const { data, source } = originalEvent;\n            // Wait until there's an \"own\" service worker. This is used to buffer\n            // `message` events that may be received prior to calling `register()`.\n            await this.getSW();\n            // If the service worker that sent the message is in the list of own\n            // service workers for this instance, dispatch a `message` event.\n            // NOTE: we check for all previously owned service workers rather than\n            // just the current one because some messages (e.g. cache updates) use\n            // a timeout when sent and may be delayed long enough for a service worker\n            // update to be found.\n            if (this._ownSWs.has(source)) {\n                this.dispatchEvent(new WorkboxEvent('message', {\n                    data,\n                    sw: source,\n                    originalEvent,\n                }));\n            }\n        };\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n        navigator.serviceWorker.addEventListener('message', this._onMessage);\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n    async register({ immediate = false } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._registrationTime) {\n                logger.error('Cannot re-register a Workbox instance after it has ' +\n                    'been registered. Create a new instance instead.');\n                return;\n            }\n        }\n        if (!immediate && document.readyState !== 'complete') {\n            await new Promise((res) => window.addEventListener('load', res));\n        }\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        // If we have a compatible controller, store the controller as the \"own\"\n        // SW, resolve active/controlling deferreds and add necessary listeners.\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });\n        }\n        // If there's a waiting service worker with a matching URL before the\n        // `updatefound` event fires, it likely means that this site is open\n        // in another tab, or the user refreshed the page (and thus the previous\n        // page wasn't fully unloaded before this page started loading).\n        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n        const waitingSW = this._registration.waiting;\n        if (waitingSW && urlsMatch(waitingSW.scriptURL, this._scriptURL)) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            this._sw = waitingSW;\n            // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n            dontWaitFor(Promise.resolve().then(() => {\n                this.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn('A service worker was already waiting to activate ' +\n                        'before this script was registered...');\n                }\n            }));\n        }\n        // If an \"own\" SW is already set, resolve the deferred.\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log('Successfully registered service worker.', this._scriptURL);\n            if (navigator.serviceWorker.controller) {\n                if (this._compatibleControllingSW) {\n                    logger.debug('A service worker with the same script URL ' +\n                        'is already controlling this page.');\n                }\n                else {\n                    logger.debug('A service worker with a different script URL is ' +\n                        'currently controlling the page. The browser is now fetching ' +\n                        'the new script now...');\n                }\n            }\n            const currentPageIsOutOfScope = () => {\n                const scopeURL = new URL(this._registerOptions.scope || this._scriptURL, document.baseURI);\n                const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n                return !location.pathname.startsWith(scopeURLBasePath);\n            };\n            if (currentPageIsOutOfScope()) {\n                logger.warn('The current page is not in scope for the registered ' +\n                    'service worker. Was this a mistake?');\n            }\n        }\n        this._registration.addEventListener('updatefound', this._onUpdateFound);\n        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange, { once: true });\n        return this._registration;\n    }\n    /**\n     * Checks for updates of the registered service worker.\n     */\n    async update() {\n        if (!this._registration) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error('Cannot update a Workbox instance without ' +\n                    'being registered. Register the Workbox instance first.');\n            }\n            return;\n        }\n        // Try to update registration\n        await this._registration.update();\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    async getSW() {\n        // If `this._sw` is set, resolve with that as we want `getSW()` to\n        // return the correct (new) service worker if an update is found.\n        return this._sw !== undefined ? this._sw : this._swDeferred.promise;\n    }\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via [`getSW()`]{@link module:workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matches.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller && urlsMatch(controller.scriptURL, this._scriptURL)) {\n            return controller;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n    async _registerScript() {\n        try {\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            // Keep track of when registration happened, so it can be used in the\n            // `this._onUpdateFound` heuristic. Also use the presence of this\n            // property as a way to see if `.register()` has been called.\n            this._registrationTime = performance.now();\n            return reg;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(error);\n            }\n            // Re-throw the error.\n            throw error;\n        }\n    }\n}\nexport { Workbox };\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event module:workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `installed` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event module:workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `waiting` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the [`register()`]{@link module:workbox-window.Workbox#register}\n * method was called.\n *\n * @event module:workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event module:workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `activated` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `redundant` event is dispatched if the state of a\n * [`Workbox`]{@link module:workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event module:workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalinstalled` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `installed`.\n *\n * @event module:workbox-window.Workbox#externalinstalled\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalinstalled`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalwaiting` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `waiting`.\n *\n * @event module:workbox-window.Workbox#externalwaiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalwaiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `externalactivated` event is dispatched if the state of an\n * [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}\n * changes to `activated`.\n *\n * @event module:workbox-window.Workbox#externalactivated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {string} type `externalactivated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n"]},"metadata":{},"sourceType":"module"}