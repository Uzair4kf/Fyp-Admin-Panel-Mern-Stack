{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.strategies = function (exports, assert_js, cacheNames_js, cacheWrapper_js, fetchWrapper_js, getFriendlyURL_js, logger_js, WorkboxError_js) {\n  'use strict';\n\n  try {\n    self['workbox:strategies:5.1.4'] && _();\n  } catch (e) {}\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const messages = {\n    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL_js.getFriendlyURL(request.url)}'`,\n    printFinalResponse: response => {\n      if (response) {\n        logger_js.logger.groupCollapsed(`View the final response here.`);\n        logger_js.logger.log(response || '[No response returned]');\n        logger_js.logger.groupEnd();\n      }\n    }\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n   * request strategy.\n   *\n   * A cache first strategy is useful for assets that have been revisioned,\n   * such as URLs like `/styles/example.a8f5f1.css`, since they\n   * can be cached for long periods of time.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof module:workbox-strategies\n   */\n\n  class CacheFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._fetchOptions = options.fetchOptions;\n      this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_js.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'CacheFirst',\n          funcName: 'makeRequest',\n          paramName: 'request'\n        });\n      }\n      let response = await cacheWrapper_js.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      let error;\n\n      if (!response) {\n        {\n          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will respond with a network request.`);\n        }\n\n        try {\n          response = await this._getFromNetwork(request, event);\n        } catch (err) {\n          error = err;\n        }\n\n        {\n          if (response) {\n            logs.push(`Got response from network.`);\n          } else {\n            logs.push(`Unable to get a response from the network.`);\n          }\n        }\n      } else {\n        {\n          logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n        }\n      }\n\n      {\n        logger_js.logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n\n        for (const log of logs) {\n          logger_js.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_js.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_js.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n    /**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {Event} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getFromNetwork(request, event) {\n      const response = await fetchWrapper_js.fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins\n      }); // Keep the service worker while we put the request to the cache\n\n      const responseClone = response.clone();\n      const cachePutPromise = cacheWrapper_js.cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: responseClone,\n        event,\n        plugins: this._plugins\n      });\n\n      if (event) {\n        try {\n          event.waitUntil(cachePutPromise);\n        } catch (error) {\n          {\n            logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n\n      return response;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n   * request strategy.\n   *\n   * This class is useful if you want to take advantage of any\n   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n   *\n   * If there is no cache match, this will throw a `WorkboxError` exception.\n   *\n   * @memberof module:workbox-strategies\n   */\n\n\n  class CacheOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_js.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'CacheOnly',\n          funcName: 'makeRequest',\n          paramName: 'request'\n        });\n      }\n      const response = await cacheWrapper_js.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      {\n        logger_js.logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n\n        if (response) {\n          logger_js.logger.log(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n          messages.printFinalResponse(response);\n        } else {\n          logger_js.logger.log(`No response found in the '${this._cacheName}' cache.`);\n        }\n\n        logger_js.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_js.WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n\n      return response;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n\n  const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({\n      response\n    }) => {\n      if (response.status === 200 || response.status === 0) {\n        return response;\n      }\n\n      return null;\n    }\n  };\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n   * request strategy.\n   *\n   * By default, this strategy will cache responses with a 200 status code as\n   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n   * Opaque responses are are cross-origin requests where the response doesn't\n   * support [CORS]{@link https://enable-cors.org/}.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof module:workbox-strategies\n   */\n\n  class NetworkFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n\n      if (options.plugins) {\n        const isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n      } else {\n        // No plugins passed in, use the default plugin.\n        this._plugins = [cacheOkAndOpaquePlugin];\n      }\n\n      this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n      {\n        if (this._networkTimeoutSeconds) {\n          assert_js.assert.isType(this._networkTimeoutSeconds, 'number', {\n            moduleName: 'workbox-strategies',\n            className: 'NetworkFirst',\n            funcName: 'constructor',\n            paramName: 'networkTimeoutSeconds'\n          });\n        }\n      }\n      this._fetchOptions = options.fetchOptions;\n      this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_js.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkFirst',\n          funcName: 'handle',\n          paramName: 'makeRequest'\n        });\n      }\n      const promises = [];\n      let timeoutId;\n\n      if (this._networkTimeoutSeconds) {\n        const {\n          id,\n          promise\n        } = this._getTimeoutPromise({\n          request,\n          event,\n          logs\n        });\n\n        timeoutId = id;\n        promises.push(promise);\n      }\n\n      const networkPromise = this._getNetworkPromise({\n        timeoutId,\n        request,\n        event,\n        logs\n      });\n\n      promises.push(networkPromise); // Promise.race() will resolve as soon as the first promise resolves.\n\n      let response = await Promise.race(promises); // If Promise.race() resolved with null, it might be due to a network\n      // timeout + a cache miss. If that were to happen, we'd rather wait until\n      // the networkPromise resolves instead of returning null.\n      // Note that it's fine to await an already-resolved promise, so we don't\n      // have to check to see if it's still \"in flight\".\n\n      if (!response) {\n        response = await networkPromise;\n      }\n\n      {\n        logger_js.logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n\n        for (const log of logs) {\n          logger_js.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_js.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_js.WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n\n      return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    _getTimeoutPromise({\n      request,\n      logs,\n      event\n    }) {\n      let timeoutId;\n      const timeoutPromise = new Promise(resolve => {\n        const onNetworkTimeout = async () => {\n          {\n            logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);\n          }\n          resolve(await this._respondFromCache({\n            request,\n            event\n          }));\n        };\n\n        timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n      });\n      return {\n        promise: timeoutPromise,\n        id: timeoutId\n      };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getNetworkPromise({\n      timeoutId,\n      request,\n      logs,\n      event\n    }) {\n      let error;\n      let response;\n\n      try {\n        response = await fetchWrapper_js.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        });\n      } catch (err) {\n        error = err;\n      }\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);\n        }\n      }\n\n      if (error || !response) {\n        response = await this._respondFromCache({\n          request,\n          event\n        });\n        {\n          if (response) {\n            logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n          } else {\n            logs.push(`No response found in the '${this._cacheName}' cache.`);\n          }\n        }\n      } else {\n        // Keep the service worker alive while we put the request in the cache\n        const responseClone = response.clone();\n        const cachePut = cacheWrapper_js.cacheWrapper.put({\n          cacheName: this._cacheName,\n          request,\n          response: responseClone,\n          event,\n          plugins: this._plugins\n        });\n\n        if (event) {\n          try {\n            // The event has been responded to so we can keep the SW alive to\n            // respond to the request\n            event.waitUntil(cachePut);\n          } catch (err) {\n            {\n              logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n            }\n          }\n        }\n      }\n\n      return response;\n    }\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n\n\n    _respondFromCache({\n      event,\n      request\n    }) {\n      return cacheWrapper_js.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n   * request strategy.\n   *\n   * This class is useful if you want to take advantage of any\n   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n   *\n   * If the network request fails, this will throw a `WorkboxError` exception.\n   *\n   * @memberof module:workbox-strategies\n   */\n\n\n  class NetworkOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     */\n    constructor(options = {}) {\n      this._plugins = options.plugins || [];\n      this._fetchOptions = options.fetchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_js.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkOnly',\n          funcName: 'handle',\n          paramName: 'request'\n        });\n      }\n      let error;\n      let response;\n\n      try {\n        response = await fetchWrapper_js.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        });\n      } catch (err) {\n        error = err;\n      }\n\n      {\n        logger_js.logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n\n        if (response) {\n          logger_js.logger.log(`Got response from network.`);\n        } else {\n          logger_js.logger.log(`Unable to get a response from the network.`);\n        }\n\n        messages.printFinalResponse(response);\n        logger_js.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_js.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * An implementation of a\n   * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n   * request strategy.\n   *\n   * Resources are requested from both the cache and the network in parallel.\n   * The strategy will respond with the cached version if available, otherwise\n   * wait for the network response. The cache is updated with the network response\n   * with each successful request.\n   *\n   * By default, this strategy will cache responses with a 200 status code as\n   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n   * Opaque responses are cross-origin requests where the response doesn't\n   * support [CORS]{@link https://enable-cors.org/}.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof module:workbox-strategies\n   */\n\n\n  class StaleWhileRevalidate {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_js.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n\n      if (options.plugins) {\n        const isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n      } else {\n        // No plugins passed in, use the default plugin.\n        this._plugins = [cacheOkAndOpaquePlugin];\n      }\n\n      this._fetchOptions = options.fetchOptions;\n      this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_js.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'StaleWhileRevalidate',\n          funcName: 'handle',\n          paramName: 'request'\n        });\n      }\n\n      const fetchAndCachePromise = this._getFromNetwork({\n        request,\n        event\n      });\n\n      let response = await cacheWrapper_js.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      let error;\n\n      if (response) {\n        {\n          logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache. Will update with the network response in the background.`);\n        }\n\n        if (event) {\n          try {\n            event.waitUntil(fetchAndCachePromise);\n          } catch (error) {\n            {\n              logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n            }\n          }\n        }\n      } else {\n        {\n          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will wait for the network response.`);\n        }\n\n        try {\n          response = await fetchAndCachePromise;\n        } catch (err) {\n          error = err;\n        }\n      }\n\n      {\n        logger_js.logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n\n        for (const log of logs) {\n          logger_js.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_js.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_js.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getFromNetwork({\n      request,\n      event\n    }) {\n      const response = await fetchWrapper_js.fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins\n      });\n      const cachePutPromise = cacheWrapper_js.cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: response.clone(),\n        event,\n        plugins: this._plugins\n      });\n\n      if (event) {\n        try {\n          event.waitUntil(cachePutPromise);\n        } catch (error) {\n          {\n            logger_js.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_js.getFriendlyURL(request.url)}'.`);\n          }\n        }\n      }\n\n      return response;\n    }\n\n  }\n\n  exports.CacheFirst = CacheFirst;\n  exports.CacheOnly = CacheOnly;\n  exports.NetworkFirst = NetworkFirst;\n  exports.NetworkOnly = NetworkOnly;\n  exports.StaleWhileRevalidate = StaleWhileRevalidate;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.js","../utils/messages.js","../CacheFirst.js","../CacheOnly.js","../plugins/cacheOkAndOpaquePlugin.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"names":["self","_","messages","strategyStart","strategyName","getFriendlyURL","request","printFinalResponse","response","logger","constructor","options","cacheNames","handle","logs","assert","moduleName","className","funcName","paramName","cacheName","matchOptions","plugins","_plugins","_cacheName","error","WorkboxError","url","_getFromNetwork","fetchOptions","responseClone","cachePutPromise","event","cacheOkAndOpaquePlugin","cacheWillUpdate","isUsingCacheWillUpdate","plugin","promises","promise","timeoutId","networkPromise","Promise","_getTimeoutPromise","timeoutPromise","resolve","onNetworkTimeout","_networkTimeoutSeconds","setTimeout","id","_getNetworkPromise","clearTimeout","cachePut","_respondFromCache","fetchAndCachePromise"],"mappings":"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","sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport '../_version.js';\nexport const messages = {\n    strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${getFriendlyURL(request.url)}'`,\n    printFinalResponse: (response) => {\n        if (response) {\n            logger.groupCollapsed(`View the final response here.`);\n            logger.log(response || '[No response returned]');\n            logger.groupEnd();\n        }\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass CacheFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheFirst',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await this._getFromNetwork(request, event);\n            }\n            catch (err) {\n                error = err;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {Event} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork(request, event) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        // Keep the service worker while we put the request to the cache\n        const responseClone = response.clone();\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: responseClone,\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass CacheOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheOnly',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this._cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass NetworkFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        if (options.plugins) {\n            const isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: 'NetworkFirst',\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'NetworkFirst',\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, event, logs });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({ timeoutId, request, event, logs });\n        promises.push(networkPromise);\n        // Promise.race() will resolve as soon as the first promise resolves.\n        let response = await Promise.race(promises);\n        // If Promise.race() resolved with null, it might be due to a network\n        // timeout + a cache miss. If that were to happen, we'd rather wait until\n        // the networkPromise resolves instead of returning null.\n        // Note that it's fine to await an already-resolved promise, so we don't\n        // have to check to see if it's still \"in flight\".\n        if (!response) {\n            response = await networkPromise;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, event }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await this._respondFromCache({ request, event }));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, event }) {\n        let error;\n        let response;\n        try {\n            response = await fetchWrapper.fetch({\n                request,\n                event,\n                fetchOptions: this._fetchOptions,\n                plugins: this._plugins,\n            });\n        }\n        catch (err) {\n            error = err;\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await this._respondFromCache({ request, event });\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this._cacheName}'` +\n                        ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this._cacheName}' cache.`);\n                }\n            }\n        }\n        else {\n            // Keep the service worker alive while we put the request in the cache\n            const responseClone = response.clone();\n            const cachePut = cacheWrapper.put({\n                cacheName: this._cacheName,\n                request,\n                response: responseClone,\n                event,\n                plugins: this._plugins,\n            });\n            if (event) {\n                try {\n                    // The event has been responded to so we can keep the SW alive to\n                    // respond to the request\n                    event.waitUntil(cachePut);\n                }\n                catch (err) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        return response;\n    }\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n    _respondFromCache({ event, request }) {\n        return cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass NetworkOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     */\n    constructor(options = {}) {\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'NetworkOnly',\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        let error;\n        let response;\n        try {\n            response = await fetchWrapper.fetch({\n                request,\n                event,\n                fetchOptions: this._fetchOptions,\n                plugins: this._plugins,\n            });\n        }\n        catch (err) {\n            error = err;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass StaleWhileRevalidate {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        if (options.plugins) {\n            const isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'StaleWhileRevalidate',\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = this._getFromNetwork({ request, event });\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n            if (event) {\n                try {\n                    event.waitUntil(fetchAndCachePromise);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                response = await fetchAndCachePromise;\n            }\n            catch (err) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork({ request, event }) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: response.clone(),\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"]},"metadata":{},"sourceType":"script"}