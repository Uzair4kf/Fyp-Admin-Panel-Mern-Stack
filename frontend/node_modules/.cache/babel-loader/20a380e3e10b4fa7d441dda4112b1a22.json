{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenateToResponse } from './concatenateToResponse.js';\nimport { isSupported } from './isSupported.js';\nimport './_version.js';\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {Array<function({event, request, url, params})>} sourceFunctions\n * An array of functions similar to {@link module:workbox-routing~handlerCallback}\n * but that instead return a {@link module:workbox-streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {module:workbox-routing~handlerCallback}\n * @memberof module:workbox-streams\n */\n\nfunction strategy(sourceFunctions, headersInit) {\n  return async ({\n    event,\n    request,\n    url,\n    params\n  }) => {\n    const sourcePromises = sourceFunctions.map(fn => {\n      // Ensure the return value of the function is always a promise.\n      return Promise.resolve(fn({\n        event,\n        request,\n        url,\n        params\n      }));\n    });\n\n    if (isSupported()) {\n      const {\n        done,\n        response\n      } = concatenateToResponse(sourcePromises, headersInit);\n\n      if (event) {\n        event.waitUntil(done);\n      }\n\n      return response;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      logger.log(`The current browser doesn't support creating response ` + `streams. Falling back to non-streaming response instead.`);\n    } // Fallback to waiting for everything to finish, and concatenating the\n    // responses.\n\n\n    const blobPartsPromises = sourcePromises.map(async sourcePromise => {\n      const source = await sourcePromise;\n\n      if (source instanceof Response) {\n        return source.blob();\n      } else {\n        // Technically, a `StreamSource` object can include any valid\n        // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n        // cannot be passed to the Blob constructor directly, so we have to\n        // convert them to actual Blobs first.\n        return new Response(source).blob();\n      }\n    });\n    const blobParts = await Promise.all(blobPartsPromises);\n    const headers = createHeaders(headersInit); // Constructing a new Response from a Blob source is well-supported.\n    // So is constructing a new Blob from multiple source Blobs or strings.\n\n    return new Response(new Blob(blobParts), {\n      headers\n    });\n  };\n}\n\nexport { strategy };","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/workbox-streams/strategy.js"],"names":["logger","createHeaders","concatenateToResponse","isSupported","strategy","sourceFunctions","headersInit","event","request","url","params","sourcePromises","map","fn","Promise","resolve","done","response","waitUntil","process","env","NODE_ENV","log","blobPartsPromises","sourcePromise","source","Response","blob","blobParts","all","headers","Blob"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,iCAAvB;AACA,SAASC,aAAT,QAA8B,0BAA9B;AACA,SAASC,qBAAT,QAAsC,4BAAtC;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,OAAO,eAAP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,QAAT,CAAkBC,eAAlB,EAAmCC,WAAnC,EAAgD;AAC5C,SAAO,OAAO;AAAEC,IAAAA,KAAF;AAASC,IAAAA,OAAT;AAAkBC,IAAAA,GAAlB;AAAuBC,IAAAA;AAAvB,GAAP,KAA2C;AAC9C,UAAMC,cAAc,GAAGN,eAAe,CAACO,GAAhB,CAAqBC,EAAD,IAAQ;AAC/C;AACA,aAAOC,OAAO,CAACC,OAAR,CAAgBF,EAAE,CAAC;AAAEN,QAAAA,KAAF;AAASC,QAAAA,OAAT;AAAkBC,QAAAA,GAAlB;AAAuBC,QAAAA;AAAvB,OAAD,CAAlB,CAAP;AACH,KAHsB,CAAvB;;AAIA,QAAIP,WAAW,EAAf,EAAmB;AACf,YAAM;AAAEa,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAAqBf,qBAAqB,CAACS,cAAD,EAAiBL,WAAjB,CAAhD;;AACA,UAAIC,KAAJ,EAAW;AACPA,QAAAA,KAAK,CAACW,SAAN,CAAgBF,IAAhB;AACH;;AACD,aAAOC,QAAP;AACH;;AACD,QAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvCrB,MAAAA,MAAM,CAACsB,GAAP,CAAY,wDAAD,GACN,0DADL;AAEH,KAf6C,CAgB9C;AACA;;;AACA,UAAMC,iBAAiB,GAAGZ,cAAc,CAACC,GAAf,CAAmB,MAAOY,aAAP,IAAyB;AAClE,YAAMC,MAAM,GAAG,MAAMD,aAArB;;AACA,UAAIC,MAAM,YAAYC,QAAtB,EAAgC;AAC5B,eAAOD,MAAM,CAACE,IAAP,EAAP;AACH,OAFD,MAGK;AACD;AACA;AACA;AACA;AACA,eAAO,IAAID,QAAJ,CAAaD,MAAb,EAAqBE,IAArB,EAAP;AACH;AACJ,KAZyB,CAA1B;AAaA,UAAMC,SAAS,GAAG,MAAMd,OAAO,CAACe,GAAR,CAAYN,iBAAZ,CAAxB;AACA,UAAMO,OAAO,GAAG7B,aAAa,CAACK,WAAD,CAA7B,CAhC8C,CAiC9C;AACA;;AACA,WAAO,IAAIoB,QAAJ,CAAa,IAAIK,IAAJ,CAASH,SAAT,CAAb,EAAkC;AAAEE,MAAAA;AAAF,KAAlC,CAAP;AACH,GApCD;AAqCH;;AACD,SAAS1B,QAAT","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenateToResponse } from './concatenateToResponse.js';\nimport { isSupported } from './isSupported.js';\nimport './_version.js';\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {Array<function({event, request, url, params})>} sourceFunctions\n * An array of functions similar to {@link module:workbox-routing~handlerCallback}\n * but that instead return a {@link module:workbox-streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {module:workbox-routing~handlerCallback}\n * @memberof module:workbox-streams\n */\nfunction strategy(sourceFunctions, headersInit) {\n    return async ({ event, request, url, params }) => {\n        const sourcePromises = sourceFunctions.map((fn) => {\n            // Ensure the return value of the function is always a promise.\n            return Promise.resolve(fn({ event, request, url, params }));\n        });\n        if (isSupported()) {\n            const { done, response } = concatenateToResponse(sourcePromises, headersInit);\n            if (event) {\n                event.waitUntil(done);\n            }\n            return response;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log(`The current browser doesn't support creating response ` +\n                `streams. Falling back to non-streaming response instead.`);\n        }\n        // Fallback to waiting for everything to finish, and concatenating the\n        // responses.\n        const blobPartsPromises = sourcePromises.map(async (sourcePromise) => {\n            const source = await sourcePromise;\n            if (source instanceof Response) {\n                return source.blob();\n            }\n            else {\n                // Technically, a `StreamSource` object can include any valid\n                // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n                // cannot be passed to the Blob constructor directly, so we have to\n                // convert them to actual Blobs first.\n                return new Response(source).blob();\n            }\n        });\n        const blobParts = await Promise.all(blobPartsPromises);\n        const headers = createHeaders(headersInit);\n        // Constructing a new Response from a Blob source is well-supported.\n        // So is constructing a new Blob from multiple source Blobs or strings.\n        return new Response(new Blob(blobParts), { headers });\n    };\n}\nexport { strategy };\n"]},"metadata":{},"sourceType":"module"}