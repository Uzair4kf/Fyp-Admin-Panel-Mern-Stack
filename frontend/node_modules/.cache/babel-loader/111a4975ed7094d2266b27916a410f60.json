{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.strategies = function (t, e, s, i, n) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:strategies:5.1.4\"] && _();\n  } catch (t) {}\n\n  const r = {\n    cacheWillUpdate: async ({\n      response: t\n    }) => 200 === t.status || 0 === t.status ? t : null\n  };\n  return t.CacheFirst = class {\n    constructor(t = {}) {\n      this.t = e.cacheNames.getRuntimeName(t.cacheName), this.s = t.plugins || [], this.i = t.fetchOptions, this.h = t.matchOptions;\n    }\n\n    async handle({\n      event: t,\n      request: e\n    }) {\n      \"string\" == typeof e && (e = new Request(e));\n      let i,\n          r = await s.cacheWrapper.match({\n        cacheName: this.t,\n        request: e,\n        event: t,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n      if (!r) try {\n        r = await this.o(e, t);\n      } catch (t) {\n        i = t;\n      }\n      if (!r) throw new n.WorkboxError(\"no-response\", {\n        url: e.url,\n        error: i\n      });\n      return r;\n    }\n\n    async o(t, e) {\n      const n = await i.fetchWrapper.fetch({\n        request: t,\n        event: e,\n        fetchOptions: this.i,\n        plugins: this.s\n      }),\n            r = n.clone(),\n            h = s.cacheWrapper.put({\n        cacheName: this.t,\n        request: t,\n        response: r,\n        event: e,\n        plugins: this.s\n      });\n      if (e) try {\n        e.waitUntil(h);\n      } catch (t) {}\n      return n;\n    }\n\n  }, t.CacheOnly = class {\n    constructor(t = {}) {\n      this.t = e.cacheNames.getRuntimeName(t.cacheName), this.s = t.plugins || [], this.h = t.matchOptions;\n    }\n\n    async handle({\n      event: t,\n      request: e\n    }) {\n      \"string\" == typeof e && (e = new Request(e));\n      const i = await s.cacheWrapper.match({\n        cacheName: this.t,\n        request: e,\n        event: t,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n      if (!i) throw new n.WorkboxError(\"no-response\", {\n        url: e.url\n      });\n      return i;\n    }\n\n  }, t.NetworkFirst = class {\n    constructor(t = {}) {\n      if (this.t = e.cacheNames.getRuntimeName(t.cacheName), t.plugins) {\n        const e = t.plugins.some(t => !!t.cacheWillUpdate);\n        this.s = e ? t.plugins : [r, ...t.plugins];\n      } else this.s = [r];\n\n      this.u = t.networkTimeoutSeconds || 0, this.i = t.fetchOptions, this.h = t.matchOptions;\n    }\n\n    async handle({\n      event: t,\n      request: e\n    }) {\n      const s = [];\n      \"string\" == typeof e && (e = new Request(e));\n      const i = [];\n      let r;\n\n      if (this.u) {\n        const {\n          id: n,\n          promise: h\n        } = this.l({\n          request: e,\n          event: t,\n          logs: s\n        });\n        r = n, i.push(h);\n      }\n\n      const h = this.p({\n        timeoutId: r,\n        request: e,\n        event: t,\n        logs: s\n      });\n      i.push(h);\n      let o = await Promise.race(i);\n      if (o || (o = await h), !o) throw new n.WorkboxError(\"no-response\", {\n        url: e.url\n      });\n      return o;\n    }\n\n    l({\n      request: t,\n      logs: e,\n      event: s\n    }) {\n      let i;\n      return {\n        promise: new Promise(e => {\n          i = setTimeout(async () => {\n            e(await this.q({\n              request: t,\n              event: s\n            }));\n          }, 1e3 * this.u);\n        }),\n        id: i\n      };\n    }\n\n    async p({\n      timeoutId: t,\n      request: e,\n      logs: n,\n      event: r\n    }) {\n      let h, o;\n\n      try {\n        o = await i.fetchWrapper.fetch({\n          request: e,\n          event: r,\n          fetchOptions: this.i,\n          plugins: this.s\n        });\n      } catch (t) {\n        h = t;\n      }\n\n      if (t && clearTimeout(t), h || !o) o = await this.q({\n        request: e,\n        event: r\n      });else {\n        const t = o.clone(),\n              i = s.cacheWrapper.put({\n          cacheName: this.t,\n          request: e,\n          response: t,\n          event: r,\n          plugins: this.s\n        });\n        if (r) try {\n          r.waitUntil(i);\n        } catch (t) {}\n      }\n      return o;\n    }\n\n    q({\n      event: t,\n      request: e\n    }) {\n      return s.cacheWrapper.match({\n        cacheName: this.t,\n        request: e,\n        event: t,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n    }\n\n  }, t.NetworkOnly = class {\n    constructor(t = {}) {\n      this.s = t.plugins || [], this.i = t.fetchOptions;\n    }\n\n    async handle({\n      event: t,\n      request: e\n    }) {\n      let s, r;\n      \"string\" == typeof e && (e = new Request(e));\n\n      try {\n        r = await i.fetchWrapper.fetch({\n          request: e,\n          event: t,\n          fetchOptions: this.i,\n          plugins: this.s\n        });\n      } catch (t) {\n        s = t;\n      }\n\n      if (!r) throw new n.WorkboxError(\"no-response\", {\n        url: e.url,\n        error: s\n      });\n      return r;\n    }\n\n  }, t.StaleWhileRevalidate = class {\n    constructor(t = {}) {\n      if (this.t = e.cacheNames.getRuntimeName(t.cacheName), this.s = t.plugins || [], t.plugins) {\n        const e = t.plugins.some(t => !!t.cacheWillUpdate);\n        this.s = e ? t.plugins : [r, ...t.plugins];\n      } else this.s = [r];\n\n      this.i = t.fetchOptions, this.h = t.matchOptions;\n    }\n\n    async handle({\n      event: t,\n      request: e\n    }) {\n      \"string\" == typeof e && (e = new Request(e));\n      const i = this.o({\n        request: e,\n        event: t\n      });\n      let r,\n          h = await s.cacheWrapper.match({\n        cacheName: this.t,\n        request: e,\n        event: t,\n        matchOptions: this.h,\n        plugins: this.s\n      });\n\n      if (h) {\n        if (t) try {\n          t.waitUntil(i);\n        } catch (r) {}\n      } else try {\n        h = await i;\n      } catch (t) {\n        r = t;\n      }\n\n      if (!h) throw new n.WorkboxError(\"no-response\", {\n        url: e.url,\n        error: r\n      });\n      return h;\n    }\n\n    async o({\n      request: t,\n      event: e\n    }) {\n      const n = await i.fetchWrapper.fetch({\n        request: t,\n        event: e,\n        fetchOptions: this.i,\n        plugins: this.s\n      }),\n            r = s.cacheWrapper.put({\n        cacheName: this.t,\n        request: t,\n        response: n.clone(),\n        event: e,\n        plugins: this.s\n      });\n      if (e) try {\n        e.waitUntil(r);\n      } catch (t) {}\n      return n;\n    }\n\n  }, t;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.js","../plugins/cacheOkAndOpaquePlugin.js","../CacheFirst.js","../CacheOnly.js","../NetworkFirst.js","../NetworkOnly.js","../StaleWhileRevalidate.js"],"names":["self","_","e","cacheOkAndOpaquePlugin","cacheWillUpdate","async","response","status","constructor","options","_cacheName","cacheNames","getRuntimeName","cacheName","_plugins","plugins","_fetchOptions","fetchOptions","_matchOptions","matchOptions","event","request","Request","cacheWrapper","match","this","error","_getFromNetwork","err","WorkboxError","url","fetchWrapper","fetch","responseClone","clone","cachePutPromise","put","waitUntil","isUsingCacheWillUpdate","some","plugin","_networkTimeoutSeconds","networkTimeoutSeconds","logs","promises","timeoutId","id","promise","_getTimeoutPromise","push","networkPromise","_getNetworkPromise","Promise","race","resolve","_respondFromCache","setTimeout","clearTimeout","cachePut","fetchAndCachePromise"],"mappings":"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","sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:strategies:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\nexport const cacheOkAndOpaquePlugin = {\n    /**\n     * Returns a valid response (to allow caching) if the status is 200 (OK) or\n     * 0 (opaque).\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: async ({ response }) => {\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    },\n};\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass CacheFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheFirst',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will respond with a network request.`);\n            }\n            try {\n                response = await this._getFromNetwork(request, event);\n            }\n            catch (err) {\n                error = err;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Got response from network.`);\n                }\n                else {\n                    logs.push(`Unable to get a response from the network.`);\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {Event} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork(request, event) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        // Keep the service worker while we put the request to the cache\n        const responseClone = response.clone();\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: responseClone,\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { CacheFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass CacheOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'CacheOnly',\n                funcName: 'makeRequest',\n                paramName: 'request',\n            });\n        }\n        const response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n            if (response) {\n                logger.log(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache.`);\n                messages.printFinalResponse(response);\n            }\n            else {\n                logger.log(`No response found in the '${this._cacheName}' cache.`);\n            }\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n}\nexport { CacheOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass NetworkFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        if (options.plugins) {\n            const isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._networkTimeoutSeconds) {\n                assert.isType(this._networkTimeoutSeconds, 'number', {\n                    moduleName: 'workbox-strategies',\n                    className: 'NetworkFirst',\n                    funcName: 'constructor',\n                    paramName: 'networkTimeoutSeconds',\n                });\n            }\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'NetworkFirst',\n                funcName: 'handle',\n                paramName: 'makeRequest',\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({ request, event, logs });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({ timeoutId, request, event, logs });\n        promises.push(networkPromise);\n        // Promise.race() will resolve as soon as the first promise resolves.\n        let response = await Promise.race(promises);\n        // If Promise.race() resolved with null, it might be due to a network\n        // timeout + a cache miss. If that were to happen, we'd rather wait until\n        // the networkPromise resolves instead of returning null.\n        // Note that it's fine to await an already-resolved promise, so we don't\n        // have to check to see if it's still \"in flight\".\n        if (!response) {\n            response = await networkPromise;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    _getTimeoutPromise({ request, logs, event }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve) => {\n            const onNetworkTimeout = async () => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logs.push(`Timing out the network response at ` +\n                        `${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await this._respondFromCache({ request, event }));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId,\n        };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getNetworkPromise({ timeoutId, request, logs, event }) {\n        let error;\n        let response;\n        try {\n            response = await fetchWrapper.fetch({\n                request,\n                event,\n                fetchOptions: this._fetchOptions,\n                plugins: this._plugins,\n            });\n        }\n        catch (err) {\n            error = err;\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            if (response) {\n                logs.push(`Got response from network.`);\n            }\n            else {\n                logs.push(`Unable to get a response from the network. Will respond ` +\n                    `with a cached response.`);\n            }\n        }\n        if (error || !response) {\n            response = await this._respondFromCache({ request, event });\n            if (process.env.NODE_ENV !== 'production') {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this._cacheName}'` +\n                        ` cache.`);\n                }\n                else {\n                    logs.push(`No response found in the '${this._cacheName}' cache.`);\n                }\n            }\n        }\n        else {\n            // Keep the service worker alive while we put the request in the cache\n            const responseClone = response.clone();\n            const cachePut = cacheWrapper.put({\n                cacheName: this._cacheName,\n                request,\n                response: responseClone,\n                event,\n                plugins: this._plugins,\n            });\n            if (event) {\n                try {\n                    // The event has been responded to so we can keep the SW alive to\n                    // respond to the request\n                    event.waitUntil(cachePut);\n                }\n                catch (err) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        return response;\n    }\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n    _respondFromCache({ event, request }) {\n        return cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n    }\n}\nexport { NetworkFirst };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass NetworkOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     */\n    constructor(options = {}) {\n        this._plugins = options.plugins || [];\n        this._fetchOptions = options.fetchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'NetworkOnly',\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        let error;\n        let response;\n        try {\n            response = await fetchWrapper.fetch({\n                request,\n                event,\n                fetchOptions: this._fetchOptions,\n                plugins: this._plugins,\n            });\n        }\n        catch (err) {\n            error = err;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n            if (response) {\n                logger.log(`Got response from network.`);\n            }\n            else {\n                logger.log(`Unable to get a response from the network.`);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n}\nexport { NetworkOnly };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { messages } from './utils/messages.js';\nimport { cacheOkAndOpaquePlugin } from './plugins/cacheOkAndOpaquePlugin.js';\nimport './_version.js';\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @memberof module:workbox-strategies\n */\nclass StaleWhileRevalidate {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n        this._cacheName = cacheNames.getRuntimeName(options.cacheName);\n        this._plugins = options.plugins || [];\n        if (options.plugins) {\n            const isUsingCacheWillUpdate = options.plugins.some((plugin) => !!plugin.cacheWillUpdate);\n            this._plugins = isUsingCacheWillUpdate ?\n                options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n        }\n        else {\n            // No plugins passed in, use the default plugin.\n            this._plugins = [cacheOkAndOpaquePlugin];\n        }\n        this._fetchOptions = options.fetchOptions;\n        this._matchOptions = options.matchOptions;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link module:workbox-routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n    async handle({ event, request }) {\n        const logs = [];\n        if (typeof request === 'string') {\n            request = new Request(request);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-strategies',\n                className: 'StaleWhileRevalidate',\n                funcName: 'handle',\n                paramName: 'request',\n            });\n        }\n        const fetchAndCachePromise = this._getFromNetwork({ request, event });\n        let response = await cacheWrapper.match({\n            cacheName: this._cacheName,\n            request,\n            event,\n            matchOptions: this._matchOptions,\n            plugins: this._plugins,\n        });\n        let error;\n        if (response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`Found a cached response in the '${this._cacheName}'` +\n                    ` cache. Will update with the network response in the background.`);\n            }\n            if (event) {\n                try {\n                    event.waitUntil(fetchAndCachePromise);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.warn(`Unable to ensure service worker stays alive when ` +\n                            `updating cache for '${getFriendlyURL(request.url)}'.`);\n                    }\n                }\n            }\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                logs.push(`No response found in the '${this._cacheName}' cache. ` +\n                    `Will wait for the network response.`);\n            }\n            try {\n                response = await fetchAndCachePromise;\n            }\n            catch (err) {\n                error = err;\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n            for (const log of logs) {\n                logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            logger.groupEnd();\n        }\n        if (!response) {\n            throw new WorkboxError('no-response', { url: request.url, error });\n        }\n        return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n    async _getFromNetwork({ request, event }) {\n        const response = await fetchWrapper.fetch({\n            request,\n            event,\n            fetchOptions: this._fetchOptions,\n            plugins: this._plugins,\n        });\n        const cachePutPromise = cacheWrapper.put({\n            cacheName: this._cacheName,\n            request,\n            response: response.clone(),\n            event,\n            plugins: this._plugins,\n        });\n        if (event) {\n            try {\n                event.waitUntil(cachePutPromise);\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn(`Unable to ensure service worker stays alive when ` +\n                        `updating cache for '${getFriendlyURL(request.url)}'.`);\n                }\n            }\n        }\n        return response;\n    }\n}\nexport { StaleWhileRevalidate };\n"]},"metadata":{},"sourceType":"script"}