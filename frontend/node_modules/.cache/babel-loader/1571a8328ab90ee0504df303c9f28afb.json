{"ast":null,"code":"'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\n\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\n\nvar Schema = require('./Schema-88e323a7.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: Object.create(null),\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/yaml/dist/Document-9b4560a1.js"],"names":["PlainValue","require","resolveSeq","Schema","defaultOptions","anchorPrefix","customTags","indent","indentSeq","keepCstNodes","keepNodeTypes","keepBlobsInJSON","mapAsMap","maxAliasCount","prettyErrors","simpleKeys","version","scalarOptions","binary","binaryOptions","opt","Object","assign","bool","boolOptions","int","intOptions","null","nullOptions","str","strOptions","documentOptions","schema","merge","tagPrefixes","handle","prefix","defaultTagPrefix","stringifyTag","doc","tag","options","priv","match","vocab","replace","p","find","indexOf","dtp","getDefaults","suffix","substr","length","ch","getTagObject","tags","item","Alias","filter","t","format","tagObj","obj","Scalar","value","identify","class","nodeClass","name","constructor","Error","stringifyProps","node","anchors","props","anchor","getName","push","default","join","stringify","ctx","onComment","onChompKeep","Node","createCtx","aliasNodes","onTagObj","o","prevObjects","Map","createNode","alias","source","newName","map","Pair","toString","indentAtStart","stringifyString","Anchors","validAnchorNode","YAMLSeq","YAMLMap","_defineProperty","create","createAlias","setAnchor","createMergePair","sources","Merge","items","s","keys","a","getNames","getNode","names","i","includes","resolveNodes","_cstAliases","forEach","resolved","test","prev","visit","Collection","n","key","listTagNames","parseContents","contents","comments","before","after","body","undefined","spaceBefore","valueRange","msg","errors","YAMLSyntaxError","res","resolveNode","comment","cc","type","Type","BLANK_LINE","commentBefore","concat","cb","cbNode","resolveTagDirective","directive","parameters","YAMLSemanticError","some","resolveYamlDirective","v0","warnings","YAMLWarning","parseDirectives","directives","prevDoc","directiveComments","hasDirectives","error","copyTagPrefix","assertCollection","Document","directivesEndMarker","add","addIn","path","delete","deleteIn","isEmptyPath","defaults","get","keepScalar","getIn","has","hasIn","set","setIn","setSchema","id","toFixed","Array","isArray","parse","cstNode","range","start","end","YAMLError","makePretty","warn","listNonDefaultTags","defaultPrefix","setTagPrefix","toJSON","arg","onAnchor","keep","indentStep","anchorNames","aliasCount","count","values","indentSize","Number","isInteger","JSON","lines","vd","tagNames","unshift","repeat","chompKeep","contentComment","forceBlockIndent","addComment","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar PlainValue = require('./PlainValue-ec8e588e.js');\nvar resolveSeq = require('./resolveSeq-d03cb037.js');\nvar Schema = require('./Schema-88e323a7.js');\n\nconst defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nconst scalarOptions = {\n  get binary() {\n    return resolveSeq.binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(resolveSeq.binaryOptions, opt);\n  },\n\n  get bool() {\n    return resolveSeq.boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(resolveSeq.boolOptions, opt);\n  },\n\n  get int() {\n    return resolveSeq.intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(resolveSeq.intOptions, opt);\n  },\n\n  get null() {\n    return resolveSeq.nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(resolveSeq.nullOptions, opt);\n  },\n\n  get str() {\n    return resolveSeq.strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(resolveSeq.strOptions, opt);\n  }\n\n};\nconst documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: PlainValue.defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: PlainValue.defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    const priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    const vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? `!${vocab[1]}/${vocab[2]}` : `!${tag.replace(/^tag:/, '')}`;\n  }\n\n  let p = doc.tagPrefixes.find(p => tag.indexOf(p.prefix) === 0);\n\n  if (!p) {\n    const dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(p => tag.indexOf(p.prefix) === 0);\n  }\n\n  if (!p) return tag[0] === '!' ? tag : `!<${tag}>`;\n  const suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, ch => ({\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n  })[ch]);\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof resolveSeq.Alias) return resolveSeq.Alias;\n\n  if (item.tag) {\n    const match = tags.filter(t => t.tag === item.tag);\n    if (match.length > 0) return match.find(t => t.format === item.format) || match[0];\n  }\n\n  let tagObj, obj;\n\n  if (item instanceof resolveSeq.Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    const match = tags.filter(t => t.identify && t.identify(obj) || t.class && obj instanceof t.class);\n    tagObj = match.find(t => t.format === item.format) || match.find(t => !t.format);\n  } else {\n    obj = item;\n    tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n  }\n\n  if (!tagObj) {\n    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\n    throw new Error(`Tag not resolved for ${name} value`);\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, {\n  anchors,\n  doc\n}) {\n  const props = [];\n  const anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(`&${anchor}`);\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify(item, ctx, onComment, onChompKeep) {\n  const {\n    anchors,\n    schema\n  } = ctx.doc;\n  let tagObj;\n\n  if (!(item instanceof resolveSeq.Node)) {\n    const createCtx = {\n      aliasNodes: [],\n      onTagObj: o => tagObj = o,\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    for (const alias of createCtx.aliasNodes) {\n      alias.source = alias.source.node;\n      let name = anchors.getName(alias.source);\n\n      if (!name) {\n        name = anchors.newName();\n        anchors.map[name] = alias.source;\n      }\n    }\n  }\n\n  if (item instanceof resolveSeq.Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  const props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  const str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof resolveSeq.Scalar ? resolveSeq.stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof resolveSeq.Scalar || str[0] === '{' || str[0] === '[' ? `${props} ${str}` : `${props}\\n${ctx.indent}${str}`;\n}\n\nclass Anchors {\n  static validAnchorNode(node) {\n    return node instanceof resolveSeq.Scalar || node instanceof resolveSeq.YAMLSeq || node instanceof resolveSeq.YAMLMap;\n  }\n\n  constructor(prefix) {\n    PlainValue._defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  createAlias(node, name) {\n    this.setAnchor(node, name);\n    return new resolveSeq.Alias(node);\n  }\n\n  createMergePair(...sources) {\n    const merge = new resolveSeq.Merge();\n    merge.value.items = sources.map(s => {\n      if (s instanceof resolveSeq.Alias) {\n        if (s.source instanceof resolveSeq.YAMLMap) return s;\n      } else if (s instanceof resolveSeq.YAMLMap) {\n        return this.createAlias(s);\n      }\n\n      throw new Error('Merge sources must be Map nodes or their Aliases');\n    });\n    return merge;\n  }\n\n  getName(node) {\n    const {\n      map\n    } = this;\n    return Object.keys(map).find(a => map[a] === node);\n  }\n\n  getNames() {\n    return Object.keys(this.map);\n  }\n\n  getNode(name) {\n    return this.map[name];\n  }\n\n  newName(prefix) {\n    if (!prefix) prefix = this.prefix;\n    const names = Object.keys(this.map);\n\n    for (let i = 1; true; ++i) {\n      const name = `${prefix}${i}`;\n      if (!names.includes(name)) return name;\n    }\n  } // During parsing, map & aliases contain CST nodes\n\n\n  resolveNodes() {\n    const {\n      map,\n      _cstAliases\n    } = this;\n    Object.keys(map).forEach(a => {\n      map[a] = map[a].resolved;\n    });\n\n    _cstAliases.forEach(a => {\n      a.source = a.source.resolved;\n    });\n\n    delete this._cstAliases;\n  }\n\n  setAnchor(node, name) {\n    if (node != null && !Anchors.validAnchorNode(node)) {\n      throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n    }\n\n    if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n      throw new Error('Anchor names must not contain whitespace or control characters');\n    }\n\n    const {\n      map\n    } = this;\n    const prev = node && Object.keys(map).find(a => map[a] === node);\n\n    if (prev) {\n      if (!name) {\n        return prev;\n      } else if (prev !== name) {\n        delete map[prev];\n        map[name] = node;\n      }\n    } else {\n      if (!name) {\n        if (!node) return null;\n        name = this.newName();\n      }\n\n      map[name] = node;\n    }\n\n    return name;\n  }\n\n}\n\nconst visit = (node, tags) => {\n  if (node && typeof node === 'object') {\n    const {\n      tag\n    } = node;\n\n    if (node instanceof resolveSeq.Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(n => visit(n, tags));\n    } else if (node instanceof resolveSeq.Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof resolveSeq.Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nconst listTagNames = node => Object.keys(visit(node, {}));\n\nfunction parseContents(doc, contents) {\n  const comments = {\n    before: [],\n    after: []\n  };\n  let body = undefined;\n  let spaceBefore = false;\n\n  for (const node of contents) {\n    if (node.valueRange) {\n      if (body !== undefined) {\n        const msg = 'Document contains trailing content not separated by a ... or --- line';\n        doc.errors.push(new PlainValue.YAMLSyntaxError(node, msg));\n        break;\n      }\n\n      const res = resolveSeq.resolveNode(doc, node);\n\n      if (spaceBefore) {\n        res.spaceBefore = true;\n        spaceBefore = false;\n      }\n\n      body = res;\n    } else if (node.comment !== null) {\n      const cc = body === undefined ? comments.before : comments.after;\n      cc.push(node.comment);\n    } else if (node.type === PlainValue.Type.BLANK_LINE) {\n      spaceBefore = true;\n\n      if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n        // space-separated comments at start are parsed as document comments\n        doc.commentBefore = comments.before.join('\\n');\n        comments.before = [];\n      }\n    }\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    const cb = comments.before.join('\\n');\n\n    if (cb) {\n      const cbNode = body instanceof resolveSeq.Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? `${cb}\\n${cbNode.commentBefore}` : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective({\n  tagPrefixes\n}, directive) {\n  const [handle, prefix] = directive.parameters;\n\n  if (!handle || !prefix) {\n    const msg = 'Insufficient parameters given for %TAG directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(p => p.handle === handle)) {\n    const msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  return {\n    handle,\n    prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  let [version] = directive.parameters;\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    const msg = 'Insufficient parameters given for %YAML directive';\n    throw new PlainValue.YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    const v0 = doc.version || doc.options.version;\n    const msg = `Document will be parsed as YAML ${v0} rather than YAML ${version}`;\n    doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  const directiveComments = [];\n  let hasDirectives = false;\n\n  for (const directive of directives) {\n    const {\n      comment,\n      name\n    } = directive;\n\n    switch (name) {\n      case 'TAG':\n        try {\n          doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      case 'YAML':\n      case 'YAML:1.0':\n        if (doc.version) {\n          const msg = 'The %YAML directive must only be given at most once per document.';\n          doc.errors.push(new PlainValue.YAMLSemanticError(directive, msg));\n        }\n\n        try {\n          doc.version = resolveYamlDirective(doc, directive);\n        } catch (error) {\n          doc.errors.push(error);\n        }\n\n        hasDirectives = true;\n        break;\n\n      default:\n        if (name) {\n          const msg = `YAML only supports %TAG and %YAML directives, and not %${name}`;\n          doc.warnings.push(new PlainValue.YAMLWarning(directive, msg));\n        }\n\n    }\n\n    if (comment) directiveComments.push(comment);\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    const copyTagPrefix = ({\n      handle,\n      prefix\n    }) => ({\n      handle,\n      prefix\n    });\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof resolveSeq.Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nclass Document {\n  constructor(options) {\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  add(value) {\n    assertCollection(this.contents);\n    return this.contents.add(value);\n  }\n\n  addIn(path, value) {\n    assertCollection(this.contents);\n    this.contents.addIn(path, value);\n  }\n\n  delete(key) {\n    assertCollection(this.contents);\n    return this.contents.delete(key);\n  }\n\n  deleteIn(path) {\n    if (resolveSeq.isEmptyPath(path)) {\n      if (this.contents == null) return false;\n      this.contents = null;\n      return true;\n    }\n\n    assertCollection(this.contents);\n    return this.contents.deleteIn(path);\n  }\n\n  getDefaults() {\n    return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n  }\n\n  get(key, keepScalar) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.get(key, keepScalar) : undefined;\n  }\n\n  getIn(path, keepScalar) {\n    if (resolveSeq.isEmptyPath(path)) return !keepScalar && this.contents instanceof resolveSeq.Scalar ? this.contents.value : this.contents;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.getIn(path, keepScalar) : undefined;\n  }\n\n  has(key) {\n    return this.contents instanceof resolveSeq.Collection ? this.contents.has(key) : false;\n  }\n\n  hasIn(path) {\n    if (resolveSeq.isEmptyPath(path)) return this.contents !== undefined;\n    return this.contents instanceof resolveSeq.Collection ? this.contents.hasIn(path) : false;\n  }\n\n  set(key, value) {\n    assertCollection(this.contents);\n    this.contents.set(key, value);\n  }\n\n  setIn(path, value) {\n    if (resolveSeq.isEmptyPath(path)) this.contents = value;else {\n      assertCollection(this.contents);\n      this.contents.setIn(path, value);\n    }\n  }\n\n  setSchema(id, customTags) {\n    if (!id && !customTags && this.schema) return;\n    if (typeof id === 'number') id = id.toFixed(1);\n\n    if (id === '1.0' || id === '1.1' || id === '1.2') {\n      if (this.version) this.version = id;else this.options.version = id;\n      delete this.options.schema;\n    } else if (id && typeof id === 'string') {\n      this.options.schema = id;\n    }\n\n    if (Array.isArray(customTags)) this.options.customTags = customTags;\n    const opt = Object.assign({}, this.getDefaults(), this.options);\n    this.schema = new Schema.Schema(opt);\n  }\n\n  parse(node, prevDoc) {\n    if (this.options.keepCstNodes) this.cstNode = node;\n    if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n    const {\n      directives = [],\n      contents = [],\n      directivesEndMarker,\n      error,\n      valueRange\n    } = node;\n\n    if (error) {\n      if (!error.source) error.source = this;\n      this.errors.push(error);\n    }\n\n    parseDirectives(this, directives, prevDoc);\n    if (directivesEndMarker) this.directivesEndMarker = true;\n    this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n    this.setSchema();\n    this.anchors._cstAliases = [];\n    parseContents(this, contents);\n    this.anchors.resolveNodes();\n\n    if (this.options.prettyErrors) {\n      for (const error of this.errors) if (error instanceof PlainValue.YAMLError) error.makePretty();\n\n      for (const warn of this.warnings) if (warn instanceof PlainValue.YAMLError) warn.makePretty();\n    }\n\n    return this;\n  }\n\n  listNonDefaultTags() {\n    return listTagNames(this.contents).filter(t => t.indexOf(Schema.Schema.defaultPrefix) !== 0);\n  }\n\n  setTagPrefix(handle, prefix) {\n    if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n    if (prefix) {\n      const prev = this.tagPrefixes.find(p => p.handle === handle);\n      if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n        handle,\n        prefix\n      });\n    } else {\n      this.tagPrefixes = this.tagPrefixes.filter(p => p.handle !== handle);\n    }\n  }\n\n  toJSON(arg, onAnchor) {\n    const {\n      keepBlobsInJSON,\n      mapAsMap,\n      maxAliasCount\n    } = this.options;\n    const keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof resolveSeq.Scalar));\n    const ctx = {\n      doc: this,\n      indentStep: '  ',\n      keep,\n      mapAsMap: keep && !!mapAsMap,\n      maxAliasCount,\n      stringify // Requiring directly in Pair would create circular dependencies\n\n    };\n    const anchorNames = Object.keys(this.anchors.map);\n    if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(name => [this.anchors.map[name], {\n      alias: [],\n      aliasCount: 0,\n      count: 1\n    }]));\n    const res = resolveSeq.toJSON(this.contents, arg, ctx);\n    if (typeof onAnchor === 'function' && ctx.anchors) for (const {\n      count,\n      res\n    } of ctx.anchors.values()) onAnchor(res, count);\n    return res;\n  }\n\n  toString() {\n    if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n    const indentSize = this.options.indent;\n\n    if (!Number.isInteger(indentSize) || indentSize <= 0) {\n      const s = JSON.stringify(indentSize);\n      throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n    }\n\n    this.setSchema();\n    const lines = [];\n    let hasDirectives = false;\n\n    if (this.version) {\n      let vd = '%YAML 1.2';\n\n      if (this.schema.name === 'yaml-1.1') {\n        if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n      }\n\n      lines.push(vd);\n      hasDirectives = true;\n    }\n\n    const tagNames = this.listNonDefaultTags();\n    this.tagPrefixes.forEach(({\n      handle,\n      prefix\n    }) => {\n      if (tagNames.some(t => t.indexOf(prefix) === 0)) {\n        lines.push(`%TAG ${handle} ${prefix}`);\n        hasDirectives = true;\n      }\n    });\n    if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n    if (this.commentBefore) {\n      if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n      lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n    }\n\n    const ctx = {\n      anchors: Object.create(null),\n      doc: this,\n      indent: '',\n      indentStep: ' '.repeat(indentSize),\n      stringify // Requiring directly in nodes would create circular dependencies\n\n    };\n    let chompKeep = false;\n    let contentComment = null;\n\n    if (this.contents) {\n      if (this.contents instanceof resolveSeq.Node) {\n        if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n        if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n        ctx.forceBlockIndent = !!this.comment;\n        contentComment = this.contents.comment;\n      }\n\n      const onChompKeep = contentComment ? null : () => chompKeep = true;\n      const body = stringify(this.contents, ctx, () => contentComment = null, onChompKeep);\n      lines.push(resolveSeq.addComment(body, '', contentComment));\n    } else if (this.contents !== undefined) {\n      lines.push(stringify(this.contents, ctx));\n    }\n\n    if (this.comment) {\n      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n      lines.push(this.comment.replace(/^/gm, '#'));\n    }\n\n    return lines.join('\\n') + '\\n';\n  }\n\n}\n\nPlainValue._defineProperty(Document, \"defaults\", documentOptions);\n\nexports.Document = Document;\nexports.defaultOptions = defaultOptions;\nexports.scalarOptions = scalarOptions;\n"]},"metadata":{},"sourceType":"script"}