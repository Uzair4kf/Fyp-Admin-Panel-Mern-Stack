{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst {\n  matchPart\n} = require('webpack').ModuleFilenameHelpers;\n\nconst transformManifest = require('workbox-build/build/lib/transform-manifest');\n\nconst getAssetHash = require('./get-asset-hash');\n\nconst resolveWebpackURL = require('./resolve-webpack-url');\n/**\n * For a given asset, checks whether at least one of the conditions matches.\n *\n * @param {Asset} asset The webpack asset in question. This will be passed\n * to any functions that are listed as conditions.\n * @param {Compilation} compilation The webpack compilation. This will be passed\n * to any functions that are listed as conditions.\n * @param {Array<string|RegExp|Function>} conditions\n * @return {boolean} Whether or not at least one condition matches.\n * @private\n */\n\n\nfunction checkConditions(asset, compilation, conditions = []) {\n  for (const condition of conditions) {\n    if (typeof condition === 'function') {\n      if (condition({\n        asset,\n        compilation\n      })) {\n        return true;\n      }\n    } else {\n      if (matchPart(asset.name, condition)) {\n        return true;\n      }\n    }\n  } // We'll only get here if none of the conditions applied.\n\n\n  return false;\n}\n/**\n * Creates a mapping of an asset name to an Set of zero or more chunk names\n * that the asset is associated with.\n *\n * Those chunk names come from a combination of the `chunkName` property on the\n * asset, as well as the `stats.namedChunkGroups` property. That is the only\n * way to find out if an asset has an implicit descendent relationship with a\n * chunk, if it was, e.g., created by `SplitChunksPlugin`.\n *\n * See https://github.com/GoogleChrome/workbox/issues/1859\n * See https://github.com/webpack/webpack/issues/7073\n *\n * @param {Object} stats The webpack compilation stats.\n * @return {object<string, Set<string>>}\n * @private\n */\n\n\nfunction assetToChunkNameMapping(stats) {\n  const mapping = {};\n\n  for (const asset of stats.assets) {\n    mapping[asset.name] = new Set(asset.chunkNames);\n  }\n\n  for (const [chunkName, {\n    assets\n  }] of Object.entries(stats.namedChunkGroups)) {\n    for (const assetName of assets) {\n      // See https://github.com/GoogleChrome/workbox/issues/2194\n      if (mapping[assetName]) {\n        mapping[assetName].add(chunkName);\n      }\n    }\n  }\n\n  return mapping;\n}\n/**\n * Filters the set of assets out, based on the configuration options provided:\n * - chunks and excludeChunks, for chunkName-based criteria.\n * - include and exclude, for more general criteria.\n *\n * @param {Compilation} compilation The webpack compilation.\n * @param {Object} config The validated configuration, obtained from the plugin.\n * @return {Set<Asset>} The assets that should be included in the manifest,\n * based on the criteria provided.\n * @private\n */\n\n\nfunction filterAssets(compilation, config) {\n  const filteredAssets = new Set(); // See https://webpack.js.org/configuration/stats/#stats\n  // We only need assets and chunkGroups here.\n\n  const stats = compilation.getStats().toJson({\n    assets: true,\n    chunkGroups: true\n  });\n  const assetNameToChunkNames = assetToChunkNameMapping(stats); // See https://github.com/GoogleChrome/workbox/issues/1287\n\n  if (Array.isArray(config.chunks)) {\n    for (const chunk of config.chunks) {\n      if (!(chunk in stats.namedChunkGroups)) {\n        compilation.warnings.push(`The chunk '${chunk}' was provided in ` + `your Workbox chunks config, but was not found in the compilation.`);\n      }\n    }\n  } // See https://webpack.js.org/api/stats/#asset-objects\n\n\n  for (const asset of stats.assets) {\n    // chunkName based filtering is funky because:\n    // - Each asset might belong to one or more chunkNames.\n    // - If *any* of those chunk names match our config.excludeChunks,\n    //   then we skip that asset.\n    // - If the config.chunks is defined *and* there's no match\n    //   between at least one of the chunkNames and one entry, then\n    //   we skip that assets as well.\n    const isExcludedChunk = Array.isArray(config.excludeChunks) && config.excludeChunks.some(chunkName => {\n      return assetNameToChunkNames[asset.name].has(chunkName);\n    });\n\n    if (isExcludedChunk) {\n      continue;\n    }\n\n    const isIncludedChunk = !Array.isArray(config.chunks) || config.chunks.some(chunkName => {\n      return assetNameToChunkNames[asset.name].has(chunkName);\n    });\n\n    if (!isIncludedChunk) {\n      continue;\n    } // Next, check asset-level checks via includes/excludes:\n\n\n    const isExcluded = checkConditions(asset, compilation, config.exclude);\n\n    if (isExcluded) {\n      continue;\n    } // Treat an empty config.includes as an implicit inclusion.\n\n\n    const isIncluded = !Array.isArray(config.include) || checkConditions(asset, compilation, config.include);\n\n    if (!isIncluded) {\n      continue;\n    } // If we've gotten this far, then add the asset.\n\n\n    filteredAssets.add(asset);\n  }\n\n  return filteredAssets;\n}\n\nmodule.exports = async (compilation, config) => {\n  const filteredAssets = filterAssets(compilation, config);\n  const {\n    publicPath\n  } = compilation.options.output;\n  const fileDetails = [];\n\n  for (const asset of filteredAssets) {\n    // Not sure why this would be false, but checking just in case, since\n    // our original list of assets comes from compilation.getStats().toJson(),\n    // not from compilation.assets.\n    if (asset.name in compilation.assets) {\n      // This matches the format expected by transformManifest().\n      fileDetails.push({\n        file: resolveWebpackURL(publicPath, asset.name),\n        hash: getAssetHash(compilation.assets[asset.name]),\n        size: asset.size || 0\n      });\n    } else {\n      compilation.warnings.push(`Could not precache ${asset.name}, as it's ` + `missing from compilation.assets. Please open a bug against Workbox ` + `with details about your webpack config.`);\n    }\n  } // We also get back `size` and `count`, and it would be nice to log that\n  // somewhere, but... webpack doesn't offer info-level logs?\n  // https://github.com/webpack/webpack/issues/3996\n\n\n  const {\n    manifestEntries,\n    warnings\n  } = await transformManifest({\n    fileDetails,\n    additionalManifestEntries: config.additionalManifestEntries,\n    dontCacheBustURLsMatching: config.dontCacheBustURLsMatching,\n    manifestTransforms: config.manifestTransforms,\n    maximumFileSizeToCacheInBytes: config.maximumFileSizeToCacheInBytes,\n    modifyURLPrefix: config.modifyURLPrefix,\n    transformParam: compilation\n  });\n  compilation.warnings = compilation.warnings.concat(warnings || []); // Ensure that the entries are properly sorted by URL.\n\n  const sortedEntries = manifestEntries.sort((a, b) => a.url === b.url ? 0 : a.url > b.url ? 1 : -1);\n  return sortedEntries;\n};","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/workbox-webpack-plugin/build/lib/get-manifest-entries-from-compilation.js"],"names":["matchPart","require","ModuleFilenameHelpers","transformManifest","getAssetHash","resolveWebpackURL","checkConditions","asset","compilation","conditions","condition","name","assetToChunkNameMapping","stats","mapping","assets","Set","chunkNames","chunkName","Object","entries","namedChunkGroups","assetName","add","filterAssets","config","filteredAssets","getStats","toJson","chunkGroups","assetNameToChunkNames","Array","isArray","chunks","chunk","warnings","push","isExcludedChunk","excludeChunks","some","has","isIncludedChunk","isExcluded","exclude","isIncluded","include","module","exports","publicPath","options","output","fileDetails","file","hash","size","manifestEntries","additionalManifestEntries","dontCacheBustURLsMatching","manifestTransforms","maximumFileSizeToCacheInBytes","modifyURLPrefix","transformParam","concat","sortedEntries","sort","a","b","url"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst {\n  matchPart\n} = require('webpack').ModuleFilenameHelpers;\n\nconst transformManifest = require('workbox-build/build/lib/transform-manifest');\n\nconst getAssetHash = require('./get-asset-hash');\n\nconst resolveWebpackURL = require('./resolve-webpack-url');\n/**\n * For a given asset, checks whether at least one of the conditions matches.\n *\n * @param {Asset} asset The webpack asset in question. This will be passed\n * to any functions that are listed as conditions.\n * @param {Compilation} compilation The webpack compilation. This will be passed\n * to any functions that are listed as conditions.\n * @param {Array<string|RegExp|Function>} conditions\n * @return {boolean} Whether or not at least one condition matches.\n * @private\n */\n\n\nfunction checkConditions(asset, compilation, conditions = []) {\n  for (const condition of conditions) {\n    if (typeof condition === 'function') {\n      if (condition({\n        asset,\n        compilation\n      })) {\n        return true;\n      }\n    } else {\n      if (matchPart(asset.name, condition)) {\n        return true;\n      }\n    }\n  } // We'll only get here if none of the conditions applied.\n\n\n  return false;\n}\n/**\n * Creates a mapping of an asset name to an Set of zero or more chunk names\n * that the asset is associated with.\n *\n * Those chunk names come from a combination of the `chunkName` property on the\n * asset, as well as the `stats.namedChunkGroups` property. That is the only\n * way to find out if an asset has an implicit descendent relationship with a\n * chunk, if it was, e.g., created by `SplitChunksPlugin`.\n *\n * See https://github.com/GoogleChrome/workbox/issues/1859\n * See https://github.com/webpack/webpack/issues/7073\n *\n * @param {Object} stats The webpack compilation stats.\n * @return {object<string, Set<string>>}\n * @private\n */\n\n\nfunction assetToChunkNameMapping(stats) {\n  const mapping = {};\n\n  for (const asset of stats.assets) {\n    mapping[asset.name] = new Set(asset.chunkNames);\n  }\n\n  for (const [chunkName, {\n    assets\n  }] of Object.entries(stats.namedChunkGroups)) {\n    for (const assetName of assets) {\n      // See https://github.com/GoogleChrome/workbox/issues/2194\n      if (mapping[assetName]) {\n        mapping[assetName].add(chunkName);\n      }\n    }\n  }\n\n  return mapping;\n}\n/**\n * Filters the set of assets out, based on the configuration options provided:\n * - chunks and excludeChunks, for chunkName-based criteria.\n * - include and exclude, for more general criteria.\n *\n * @param {Compilation} compilation The webpack compilation.\n * @param {Object} config The validated configuration, obtained from the plugin.\n * @return {Set<Asset>} The assets that should be included in the manifest,\n * based on the criteria provided.\n * @private\n */\n\n\nfunction filterAssets(compilation, config) {\n  const filteredAssets = new Set(); // See https://webpack.js.org/configuration/stats/#stats\n  // We only need assets and chunkGroups here.\n\n  const stats = compilation.getStats().toJson({\n    assets: true,\n    chunkGroups: true\n  });\n  const assetNameToChunkNames = assetToChunkNameMapping(stats); // See https://github.com/GoogleChrome/workbox/issues/1287\n\n  if (Array.isArray(config.chunks)) {\n    for (const chunk of config.chunks) {\n      if (!(chunk in stats.namedChunkGroups)) {\n        compilation.warnings.push(`The chunk '${chunk}' was provided in ` + `your Workbox chunks config, but was not found in the compilation.`);\n      }\n    }\n  } // See https://webpack.js.org/api/stats/#asset-objects\n\n\n  for (const asset of stats.assets) {\n    // chunkName based filtering is funky because:\n    // - Each asset might belong to one or more chunkNames.\n    // - If *any* of those chunk names match our config.excludeChunks,\n    //   then we skip that asset.\n    // - If the config.chunks is defined *and* there's no match\n    //   between at least one of the chunkNames and one entry, then\n    //   we skip that assets as well.\n    const isExcludedChunk = Array.isArray(config.excludeChunks) && config.excludeChunks.some(chunkName => {\n      return assetNameToChunkNames[asset.name].has(chunkName);\n    });\n\n    if (isExcludedChunk) {\n      continue;\n    }\n\n    const isIncludedChunk = !Array.isArray(config.chunks) || config.chunks.some(chunkName => {\n      return assetNameToChunkNames[asset.name].has(chunkName);\n    });\n\n    if (!isIncludedChunk) {\n      continue;\n    } // Next, check asset-level checks via includes/excludes:\n\n\n    const isExcluded = checkConditions(asset, compilation, config.exclude);\n\n    if (isExcluded) {\n      continue;\n    } // Treat an empty config.includes as an implicit inclusion.\n\n\n    const isIncluded = !Array.isArray(config.include) || checkConditions(asset, compilation, config.include);\n\n    if (!isIncluded) {\n      continue;\n    } // If we've gotten this far, then add the asset.\n\n\n    filteredAssets.add(asset);\n  }\n\n  return filteredAssets;\n}\n\nmodule.exports = async (compilation, config) => {\n  const filteredAssets = filterAssets(compilation, config);\n  const {\n    publicPath\n  } = compilation.options.output;\n  const fileDetails = [];\n\n  for (const asset of filteredAssets) {\n    // Not sure why this would be false, but checking just in case, since\n    // our original list of assets comes from compilation.getStats().toJson(),\n    // not from compilation.assets.\n    if (asset.name in compilation.assets) {\n      // This matches the format expected by transformManifest().\n      fileDetails.push({\n        file: resolveWebpackURL(publicPath, asset.name),\n        hash: getAssetHash(compilation.assets[asset.name]),\n        size: asset.size || 0\n      });\n    } else {\n      compilation.warnings.push(`Could not precache ${asset.name}, as it's ` + `missing from compilation.assets. Please open a bug against Workbox ` + `with details about your webpack config.`);\n    }\n  } // We also get back `size` and `count`, and it would be nice to log that\n  // somewhere, but... webpack doesn't offer info-level logs?\n  // https://github.com/webpack/webpack/issues/3996\n\n\n  const {\n    manifestEntries,\n    warnings\n  } = await transformManifest({\n    fileDetails,\n    additionalManifestEntries: config.additionalManifestEntries,\n    dontCacheBustURLsMatching: config.dontCacheBustURLsMatching,\n    manifestTransforms: config.manifestTransforms,\n    maximumFileSizeToCacheInBytes: config.maximumFileSizeToCacheInBytes,\n    modifyURLPrefix: config.modifyURLPrefix,\n    transformParam: compilation\n  });\n  compilation.warnings = compilation.warnings.concat(warnings || []); // Ensure that the entries are properly sorted by URL.\n\n  const sortedEntries = manifestEntries.sort((a, b) => a.url === b.url ? 0 : a.url > b.url ? 1 : -1);\n  return sortedEntries;\n};"]},"metadata":{},"sourceType":"script"}