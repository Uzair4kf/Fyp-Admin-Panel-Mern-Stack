{"ast":null,"code":"this.workbox = this.workbox || {};\n\nthis.workbox.streams = function (exports, logger_js, assert_js, Deferred_js, canConstructReadableStream_js) {\n  'use strict';\n\n  try {\n    self['workbox:streams:5.1.4'] && _();\n  } catch (e) {}\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Takes either a Response, a ReadableStream, or a\n   * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n   * ReadableStreamReader object associated with it.\n   *\n   * @param {module:workbox-streams.StreamSource} source\n   * @return {ReadableStreamReader}\n   * @private\n   */\n\n\n  function _getReaderFromSource(source) {\n    if (source instanceof Response) {\n      return source.body.getReader();\n    }\n\n    if (source instanceof ReadableStream) {\n      return source.getReader();\n    }\n\n    return new Response(source).body.getReader();\n  }\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n   *\n   * Returns an object exposing a ReadableStream with each individual stream's\n   * data returned in sequence, along with a Promise which signals when the\n   * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n   * @return {Object<{done: Promise, stream: ReadableStream}>}\n   *\n   * @memberof module:workbox-streams\n   */\n\n\n  function concatenate(sourcePromises) {\n    {\n      assert_js.assert.isArray(sourcePromises, {\n        moduleName: 'workbox-streams',\n        funcName: 'concatenate',\n        paramName: 'sourcePromises'\n      });\n    }\n    const readerPromises = sourcePromises.map(sourcePromise => {\n      return Promise.resolve(sourcePromise).then(source => {\n        return _getReaderFromSource(source);\n      });\n    });\n    const streamDeferred = new Deferred_js.Deferred();\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n      pull(controller) {\n        return readerPromises[i].then(reader => reader.read()).then(result => {\n          if (result.done) {\n            {\n              logMessages.push(['Reached the end of source:', sourcePromises[i]]);\n            }\n            i++;\n\n            if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n              {\n                logger_js.logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n\n                for (const message of logMessages) {\n                  if (Array.isArray(message)) {\n                    logger_js.logger.log(...message);\n                  } else {\n                    logger_js.logger.log(message);\n                  }\n                }\n\n                logger_js.logger.log('Finished reading all sources.');\n                logger_js.logger.groupEnd();\n              }\n              controller.close();\n              streamDeferred.resolve();\n              return;\n            } // The `pull` method is defined because we're inside it.\n\n\n            return this.pull(controller);\n          } else {\n            controller.enqueue(result.value);\n          }\n        }).catch(error => {\n          {\n            logger_js.logger.error('An error occurred:', error);\n          }\n          streamDeferred.reject(error);\n          throw error;\n        });\n      },\n\n      cancel() {\n        {\n          logger_js.logger.warn('The ReadableStream was cancelled.');\n        }\n        streamDeferred.resolve();\n      }\n\n    });\n    return {\n      done: streamDeferred.promise,\n      stream\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * is available.\n   *\n   * @private\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof module:workbox-streams\n   */\n\n\n  function createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n\n    if (!headers.has('content-type')) {\n      headers.set('content-type', 'text/html');\n    }\n\n    return headers;\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n   * along with a\n   * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n   *\n   * Returns an object exposing a Response whose body consists of each individual\n   * stream's data returned in sequence, along with a Promise which signals when\n   * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {Object<{done: Promise, response: Response}>}\n   *\n   * @memberof module:workbox-streams\n   */\n\n\n  function concatenateToResponse(sourcePromises, headersInit) {\n    const {\n      done,\n      stream\n    } = concatenate(sourcePromises);\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, {\n      headers\n    });\n    return {\n      done,\n      response\n    };\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * can be created.\n   *\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof module:workbox-streams\n   */\n\n\n  function isSupported() {\n    return canConstructReadableStream_js.canConstructReadableStream();\n  }\n  /*\n    Copyright 2018 Google LLC\n     Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /**\n   * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n   *\n   * On browsers that do not support constructing new `ReadableStream`s, this\n   * strategy will automatically wait for all the `sourceFunctions` to complete,\n   * and create a final response that concatenates their values together.\n   *\n   * @param {Array<function({event, request, url, params})>} sourceFunctions\n   * An array of functions similar to {@link module:workbox-routing~handlerCallback}\n   * but that instead return a {@link module:workbox-streams.StreamSource} (or a\n   * Promise which resolves to one).\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {module:workbox-routing~handlerCallback}\n   * @memberof module:workbox-streams\n   */\n\n\n  function strategy(sourceFunctions, headersInit) {\n    return async ({\n      event,\n      request,\n      url,\n      params\n    }) => {\n      const sourcePromises = sourceFunctions.map(fn => {\n        // Ensure the return value of the function is always a promise.\n        return Promise.resolve(fn({\n          event,\n          request,\n          url,\n          params\n        }));\n      });\n\n      if (isSupported()) {\n        const {\n          done,\n          response\n        } = concatenateToResponse(sourcePromises, headersInit);\n\n        if (event) {\n          event.waitUntil(done);\n        }\n\n        return response;\n      }\n\n      {\n        logger_js.logger.log(`The current browser doesn't support creating response ` + `streams. Falling back to non-streaming response instead.`);\n      } // Fallback to waiting for everything to finish, and concatenating the\n      // responses.\n\n      const blobPartsPromises = sourcePromises.map(async sourcePromise => {\n        const source = await sourcePromise;\n\n        if (source instanceof Response) {\n          return source.blob();\n        } else {\n          // Technically, a `StreamSource` object can include any valid\n          // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n          // cannot be passed to the Blob constructor directly, so we have to\n          // convert them to actual Blobs first.\n          return new Response(source).blob();\n        }\n      });\n      const blobParts = await Promise.all(blobPartsPromises);\n      const headers = createHeaders(headersInit); // Constructing a new Response from a Blob source is well-supported.\n      // So is constructing a new Blob from multiple source Blobs or strings.\n\n      return new Response(new Blob(blobParts), {\n        headers\n      });\n    };\n  }\n\n  exports.concatenate = concatenate;\n  exports.concatenateToResponse = concatenateToResponse;\n  exports.isSupported = isSupported;\n  exports.strategy = strategy;\n  return exports;\n}({}, workbox.core._private, workbox.core._private, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.js","../concatenate.js","../utils/createHeaders.js","../concatenateToResponse.js","../isSupported.js","../strategy.js"],"names":["self","_","source","assert","moduleName","funcName","paramName","readerPromises","sourcePromise","_getReaderFromSource","streamDeferred","Deferred","i","logMessages","stream","pull","reader","result","sourcePromises","logger","length","Array","controller","error","cancel","done","headersInit","headers","concatenate","createHeaders","response","canConstructReadableStream","params","fn","isSupported","concatenateToResponse","event","blobPartsPromises","blobParts","Promise"],"mappings":"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","sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:streams:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport './_version.js';\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {module:workbox-streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n    if (source instanceof Response) {\n        return source.body.getReader();\n    }\n    if (source instanceof ReadableStream) {\n        return source.getReader();\n    }\n    return new Response(source).body.getReader();\n}\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof module:workbox-streams\n */\nfunction concatenate(sourcePromises) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(sourcePromises, {\n            moduleName: 'workbox-streams',\n            funcName: 'concatenate',\n            paramName: 'sourcePromises',\n        });\n    }\n    const readerPromises = sourcePromises.map((sourcePromise) => {\n        return Promise.resolve(sourcePromise).then((source) => {\n            return _getReaderFromSource(source);\n        });\n    });\n    const streamDeferred = new Deferred();\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n        pull(controller) {\n            return readerPromises[i]\n                .then((reader) => reader.read())\n                .then((result) => {\n                if (result.done) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logMessages.push(['Reached the end of source:',\n                            sourcePromises[i]]);\n                    }\n                    i++;\n                    if (i >= readerPromises.length) {\n                        // Log all the messages in the group at once in a single group.\n                        if (process.env.NODE_ENV !== 'production') {\n                            logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n                            for (const message of logMessages) {\n                                if (Array.isArray(message)) {\n                                    logger.log(...message);\n                                }\n                                else {\n                                    logger.log(message);\n                                }\n                            }\n                            logger.log('Finished reading all sources.');\n                            logger.groupEnd();\n                        }\n                        controller.close();\n                        streamDeferred.resolve();\n                        return;\n                    }\n                    // The `pull` method is defined because we're inside it.\n                    return this.pull(controller);\n                }\n                else {\n                    controller.enqueue(result.value);\n                }\n            }).catch((error) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.error('An error occurred:', error);\n                }\n                streamDeferred.reject(error);\n                throw error;\n            });\n        },\n        cancel() {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn('The ReadableStream was cancelled.');\n            }\n            streamDeferred.resolve();\n        },\n    });\n    return { done: streamDeferred.promise, stream };\n}\nexport { concatenate };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * is available.\n *\n * @private\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof module:workbox-streams\n */\nfunction createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n    if (!headers.has('content-type')) {\n        headers.set('content-type', 'text/html');\n    }\n    return headers;\n}\nexport { createHeaders };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenate } from './concatenate.js';\nimport './_version.js';\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n * along with a\n * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n *\n * Returns an object exposing a Response whose body consists of each individual\n * stream's data returned in sequence, along with a Promise which signals when\n * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {Object<{done: Promise, response: Response}>}\n *\n * @memberof module:workbox-streams\n */\nfunction concatenateToResponse(sourcePromises, headersInit) {\n    const { done, stream } = concatenate(sourcePromises);\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, { headers });\n    return { done, response };\n}\nexport { concatenateToResponse };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructReadableStream } from 'workbox-core/_private/canConstructReadableStream.js';\nimport './_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * can be created.\n *\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof module:workbox-streams\n */\nfunction isSupported() {\n    return canConstructReadableStream();\n}\nexport { isSupported };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenateToResponse } from './concatenateToResponse.js';\nimport { isSupported } from './isSupported.js';\nimport './_version.js';\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {Array<function({event, request, url, params})>} sourceFunctions\n * An array of functions similar to {@link module:workbox-routing~handlerCallback}\n * but that instead return a {@link module:workbox-streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {module:workbox-routing~handlerCallback}\n * @memberof module:workbox-streams\n */\nfunction strategy(sourceFunctions, headersInit) {\n    return async ({ event, request, url, params }) => {\n        const sourcePromises = sourceFunctions.map((fn) => {\n            // Ensure the return value of the function is always a promise.\n            return Promise.resolve(fn({ event, request, url, params }));\n        });\n        if (isSupported()) {\n            const { done, response } = concatenateToResponse(sourcePromises, headersInit);\n            if (event) {\n                event.waitUntil(done);\n            }\n            return response;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log(`The current browser doesn't support creating response ` +\n                `streams. Falling back to non-streaming response instead.`);\n        }\n        // Fallback to waiting for everything to finish, and concatenating the\n        // responses.\n        const blobPartsPromises = sourcePromises.map(async (sourcePromise) => {\n            const source = await sourcePromise;\n            if (source instanceof Response) {\n                return source.blob();\n            }\n            else {\n                // Technically, a `StreamSource` object can include any valid\n                // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n                // cannot be passed to the Blob constructor directly, so we have to\n                // convert them to actual Blobs first.\n                return new Response(source).blob();\n            }\n        });\n        const blobParts = await Promise.all(blobPartsPromises);\n        const headers = createHeaders(headersInit);\n        // Constructing a new Response from a Blob source is well-supported.\n        // So is constructing a new Blob from multiple source Blobs or strings.\n        return new Response(new Blob(blobParts), { headers });\n    };\n}\nexport { strategy };\n"]},"metadata":{},"sourceType":"script"}