{"ast":null,"code":"this.workbox = this.workbox || {}, this.workbox.streams = function (e, n, t) {\n  \"use strict\";\n\n  try {\n    self[\"workbox:streams:5.1.4\"] && _();\n  } catch (e) {}\n\n  function s(e) {\n    const t = e.map(e => Promise.resolve(e).then(e => function (e) {\n      return e instanceof Response ? e.body.getReader() : e instanceof ReadableStream ? e.getReader() : new Response(e).body.getReader();\n    }(e))),\n          s = new n.Deferred();\n    let r = 0;\n    const o = new ReadableStream({\n      pull(e) {\n        return t[r].then(e => e.read()).then(n => {\n          if (n.done) return r++, r >= t.length ? (e.close(), void s.resolve()) : this.pull(e);\n          e.enqueue(n.value);\n        }).catch(e => {\n          throw s.reject(e), e;\n        });\n      },\n\n      cancel() {\n        s.resolve();\n      }\n\n    });\n    return {\n      done: s.promise,\n      stream: o\n    };\n  }\n\n  function r(e = {}) {\n    const n = new Headers(e);\n    return n.has(\"content-type\") || n.set(\"content-type\", \"text/html\"), n;\n  }\n\n  function o(e, n) {\n    const {\n      done: t,\n      stream: o\n    } = s(e),\n          c = r(n);\n    return {\n      done: t,\n      response: new Response(o, {\n        headers: c\n      })\n    };\n  }\n\n  function c() {\n    return t.canConstructReadableStream();\n  }\n\n  return e.concatenate = s, e.concatenateToResponse = o, e.isSupported = c, e.strategy = function (e, n) {\n    return async ({\n      event: t,\n      request: s,\n      url: a,\n      params: u\n    }) => {\n      const i = e.map(e => Promise.resolve(e({\n        event: t,\n        request: s,\n        url: a,\n        params: u\n      })));\n\n      if (c()) {\n        const {\n          done: e,\n          response: s\n        } = o(i, n);\n        return t && t.waitUntil(e), s;\n      }\n\n      const f = i.map(async e => {\n        const n = await e;\n        return n instanceof Response ? n.blob() : new Response(n).blob();\n      }),\n            p = await Promise.all(f),\n            w = r(n);\n      return new Response(new Blob(p), {\n        headers: w\n      });\n    };\n  }, e;\n}({}, workbox.core._private, workbox.core._private);","map":{"version":3,"sources":["../_version.js","../concatenate.js","../utils/createHeaders.js","../concatenateToResponse.js","../isSupported.js","../strategy.js"],"names":["self","_","e","source","Response","body","getReader","ReadableStream","concatenate","sourcePromises","readerPromises","map","sourcePromise","Promise","resolve","then","_getReaderFromSource","streamDeferred","Deferred","i","stream","pull","controller","reader","read","result","done","length","close","this","enqueue","value","catch","error","reject","cancel","promise","createHeaders","headersInit","headers","Headers","has","set","concatenateToResponse","response","isSupported","canConstructReadableStream","sourceFunctions","async","event","request","url","params","fn","waitUntil","blobPartsPromises","blob","blobParts","all","Blob"],"mappings":"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","sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:streams:5.1.4'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport './_version.js';\n/**\n * Takes either a Response, a ReadableStream, or a\n * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n * ReadableStreamReader object associated with it.\n *\n * @param {module:workbox-streams.StreamSource} source\n * @return {ReadableStreamReader}\n * @private\n */\nfunction _getReaderFromSource(source) {\n    if (source instanceof Response) {\n        return source.body.getReader();\n    }\n    if (source instanceof ReadableStream) {\n        return source.getReader();\n    }\n    return new Response(source).body.getReader();\n}\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n *\n * Returns an object exposing a ReadableStream with each individual stream's\n * data returned in sequence, along with a Promise which signals when the\n * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @return {Object<{done: Promise, stream: ReadableStream}>}\n *\n * @memberof module:workbox-streams\n */\nfunction concatenate(sourcePromises) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(sourcePromises, {\n            moduleName: 'workbox-streams',\n            funcName: 'concatenate',\n            paramName: 'sourcePromises',\n        });\n    }\n    const readerPromises = sourcePromises.map((sourcePromise) => {\n        return Promise.resolve(sourcePromise).then((source) => {\n            return _getReaderFromSource(source);\n        });\n    });\n    const streamDeferred = new Deferred();\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n        pull(controller) {\n            return readerPromises[i]\n                .then((reader) => reader.read())\n                .then((result) => {\n                if (result.done) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logMessages.push(['Reached the end of source:',\n                            sourcePromises[i]]);\n                    }\n                    i++;\n                    if (i >= readerPromises.length) {\n                        // Log all the messages in the group at once in a single group.\n                        if (process.env.NODE_ENV !== 'production') {\n                            logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n                            for (const message of logMessages) {\n                                if (Array.isArray(message)) {\n                                    logger.log(...message);\n                                }\n                                else {\n                                    logger.log(message);\n                                }\n                            }\n                            logger.log('Finished reading all sources.');\n                            logger.groupEnd();\n                        }\n                        controller.close();\n                        streamDeferred.resolve();\n                        return;\n                    }\n                    // The `pull` method is defined because we're inside it.\n                    return this.pull(controller);\n                }\n                else {\n                    controller.enqueue(result.value);\n                }\n            }).catch((error) => {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.error('An error occurred:', error);\n                }\n                streamDeferred.reject(error);\n                throw error;\n            });\n        },\n        cancel() {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn('The ReadableStream was cancelled.');\n            }\n            streamDeferred.resolve();\n        },\n    });\n    return { done: streamDeferred.promise, stream };\n}\nexport { concatenate };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * is available.\n *\n * @private\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof module:workbox-streams\n */\nfunction createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n    if (!headers.has('content-type')) {\n        headers.set('content-type', 'text/html');\n    }\n    return headers;\n}\nexport { createHeaders };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenate } from './concatenate.js';\nimport './_version.js';\n/**\n * Takes multiple source Promises, each of which could resolve to a Response, a\n * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n * along with a\n * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n *\n * Returns an object exposing a Response whose body consists of each individual\n * stream's data returned in sequence, along with a Promise which signals when\n * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n *\n * @param {Array<Promise<module:workbox-streams.StreamSource>>} sourcePromises\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {Object<{done: Promise, response: Response}>}\n *\n * @memberof module:workbox-streams\n */\nfunction concatenateToResponse(sourcePromises, headersInit) {\n    const { done, stream } = concatenate(sourcePromises);\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, { headers });\n    return { done, response };\n}\nexport { concatenateToResponse };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { canConstructReadableStream } from 'workbox-core/_private/canConstructReadableStream.js';\nimport './_version.js';\n/**\n * This is a utility method that determines whether the current browser supports\n * the features required to create streamed responses. Currently, it checks if\n * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * can be created.\n *\n * @return {boolean} `true`, if the current browser meets the requirements for\n * streaming responses, and `false` otherwise.\n *\n * @memberof module:workbox-streams\n */\nfunction isSupported() {\n    return canConstructReadableStream();\n}\nexport { isSupported };\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { createHeaders } from './utils/createHeaders.js';\nimport { concatenateToResponse } from './concatenateToResponse.js';\nimport { isSupported } from './isSupported.js';\nimport './_version.js';\n/**\n * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n *\n * On browsers that do not support constructing new `ReadableStream`s, this\n * strategy will automatically wait for all the `sourceFunctions` to complete,\n * and create a final response that concatenates their values together.\n *\n * @param {Array<function({event, request, url, params})>} sourceFunctions\n * An array of functions similar to {@link module:workbox-routing~handlerCallback}\n * but that instead return a {@link module:workbox-streams.StreamSource} (or a\n * Promise which resolves to one).\n * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n * `'text/html'` will be used by default.\n * @return {module:workbox-routing~handlerCallback}\n * @memberof module:workbox-streams\n */\nfunction strategy(sourceFunctions, headersInit) {\n    return async ({ event, request, url, params }) => {\n        const sourcePromises = sourceFunctions.map((fn) => {\n            // Ensure the return value of the function is always a promise.\n            return Promise.resolve(fn({ event, request, url, params }));\n        });\n        if (isSupported()) {\n            const { done, response } = concatenateToResponse(sourcePromises, headersInit);\n            if (event) {\n                event.waitUntil(done);\n            }\n            return response;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log(`The current browser doesn't support creating response ` +\n                `streams. Falling back to non-streaming response instead.`);\n        }\n        // Fallback to waiting for everything to finish, and concatenating the\n        // responses.\n        const blobPartsPromises = sourcePromises.map(async (sourcePromise) => {\n            const source = await sourcePromise;\n            if (source instanceof Response) {\n                return source.blob();\n            }\n            else {\n                // Technically, a `StreamSource` object can include any valid\n                // `BodyInit` type, including `FormData` and `URLSearchParams`, which\n                // cannot be passed to the Blob constructor directly, so we have to\n                // convert them to actual Blobs first.\n                return new Response(source).blob();\n            }\n        });\n        const blobParts = await Promise.all(blobPartsPromises);\n        const headers = createHeaders(headersInit);\n        // Constructing a new Response from a Blob source is well-supported.\n        // So is constructing a new Blob from multiple source Blobs or strings.\n        return new Response(new Blob(blobParts), { headers });\n    };\n}\nexport { strategy };\n"]},"metadata":{},"sourceType":"script"}