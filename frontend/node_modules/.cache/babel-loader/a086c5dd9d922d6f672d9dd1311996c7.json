{"ast":null,"code":"\"use strict\";\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst {\n  RawSource\n} = require('webpack-sources');\n\nconst {\n  SingleEntryPlugin\n} = require('webpack');\n\nconst replaceAndUpdateSourceMap = require('workbox-build/build/lib/replace-and-update-source-map');\n\nconst stringify = require('fast-json-stable-stringify');\n\nconst upath = require('upath');\n\nconst validate = require('workbox-build/build/lib/validate-options');\n\nconst webpackInjectManifestSchema = require('workbox-build/build/options/schema/webpack-inject-manifest');\n\nconst getManifestEntriesFromCompilation = require('./lib/get-manifest-entries-from-compilation');\n\nconst getSourcemapAssetName = require('./lib/get-sourcemap-asset-name');\n\nconst relativeToOutputPath = require('./lib/relative-to-output-path'); // Used to keep track of swDest files written by *any* instance of this plugin.\n// See https://github.com/GoogleChrome/workbox/issues/2181\n\n\nconst _generatedAssetNames = new Set();\n/**\n * This class supports compiling a service worker file provided via `swSrc`,\n * and injecting into that service worker a list of URLs and revision\n * information for precaching based on the webpack asset pipeline.\n *\n * Use an instance of `InjectManifest` in the\n * [`plugins` array](https://webpack.js.org/concepts/plugins/#usage) of a\n * webpack config.\n *\n * @memberof module:workbox-webpack-plugin\n */\n\n\nclass InjectManifest {\n  // eslint-disable-next-line jsdoc/newline-after-description\n\n  /**\n   * Creates an instance of InjectManifest.\n   *\n   * @param {Object} config The configuration to use.\n   *\n   * @param {string} config.swSrc An existing service worker file that will be\n   * compiled and have a precache manifest injected into it.\n   *\n   * @param {Array<module:workbox-build.ManifestEntry>} [config.additionalManifestEntries]\n   * A list of entries to be precached, in addition to any entries that are\n   * generated as part of the build configuration.\n   *\n   * @param {Array<string>} [config.chunks] One or more chunk names whose corresponding\n   * output files should be included in the precache manifest.\n   *\n   * @param {boolean} [config.compileSrc=true] When `true` (the default), the\n   * `swSrc` file will be compiled by webpack. When `false`, compilation will\n   * not occur (and `webpackCompilationPlugins` can't be used.) Set to `false`\n   * if you want to inject the manifest into, e.g., a JSON file.\n   *\n   * @param {RegExp} [config.dontCacheBustURLsMatching] Assets that match this will be\n   * assumed to be uniquely versioned via their URL, and exempted from the normal\n   * HTTP cache-busting that's done when populating the precache. While not\n   * required, it's recommended that if your existing build process already\n   * inserts a `[hash]` value into each filename, you provide a RegExp that will\n   * detect that, as it will reduce the bandwidth consumed when precaching.\n   *\n   * @param {Array<string|RegExp|Function>} [config.exclude=[/\\.map$/, /^manifest.*\\.js$]]\n   * One or more specifiers used to exclude assets from the precache manifest.\n   * This is interpreted following\n   * [the same rules](https://webpack.js.org/configuration/module/#condition)\n   * as `webpack`'s standard `exclude` option.\n   *\n   * @param {Array<string>} [config.importScriptsViaChunks] One or more names of\n   * webpack chunks. The content of those chunks will be included in the\n   * generated service worker, via a call to `importScripts()`.\n   *\n   * @param {Array<string>} [config.excludeChunks] One or more chunk names whose\n   * corresponding output files should be excluded from the precache manifest.\n   *\n   * @param {Array<string|RegExp|Function>} [config.include]\n   * One or more specifiers used to include assets in the precache manifest.\n   * This is interpreted following\n   * [the same rules](https://webpack.js.org/configuration/module/#condition)\n   * as `webpack`'s standard `include` option.\n   *\n   * @param  {string} [config.injectionPoint='self.__WB_MANIFEST'] The string to\n   * find inside of the `swSrc` file. Once found, it will be replaced by the\n   * generated precache manifest.\n   *\n   * @param {Array<module:workbox-build.ManifestTransform>} [config.manifestTransforms]\n   * One or more functions which will be applied sequentially against the\n   * generated manifest. If `modifyURLPrefix` or `dontCacheBustURLsMatching` are\n   * also specified, their corresponding transformations will be applied first.\n   *\n   * @param {number} [config.maximumFileSizeToCacheInBytes=2097152] This value can be\n   * used to determine the maximum size of files that will be precached. This\n   * prevents you from inadvertently precaching very large files that might have\n   * accidentally matched one of your patterns.\n   *\n   * @param {string} [config.mode] If set to 'production', then an optimized service\n   * worker bundle that excludes debugging info will be produced. If not explicitly\n   * configured here, the `mode` value configured in the current `webpack`\n   * compilation will be used.\n   *\n   * @param {object<string, string>} [config.modifyURLPrefix] A mapping of prefixes\n   * that, if present in an entry in the precache manifest, will be replaced with\n   * the corresponding value. This can be used to, for example, remove or add a\n   * path prefix from a manifest entry if your web hosting setup doesn't match\n   * your local filesystem setup. As an alternative with more flexibility, you can\n   * use the `manifestTransforms` option and provide a function that modifies the\n   * entries in the manifest using whatever logic you provide.\n   *\n   * @param {string} [config.swDest] The asset name of the\n   * service worker file that will be created by this plugin. If omitted, the\n   * name will be based on the `swSrc` name.\n   *\n   * @param {Array<Object>} [config.webpackCompilationPlugins] Optional `webpack`\n   * plugins that will be used when compiling the `swSrc` input file.\n   */\n  constructor(config = {}) {\n    this.config = config;\n    this.alreadyCalled = false;\n  }\n  /**\n   * @param {Object} [compiler] default compiler object passed from webpack\n   *\n   * @private\n   */\n\n\n  propagateWebpackConfig(compiler) {\n    // Because this.config is listed last, properties that are already set\n    // there take precedence over derived properties from the compiler.\n    this.config = Object.assign({\n      mode: compiler.mode\n    }, this.config);\n  }\n  /**\n   * @param {Object} [compiler] default compiler object passed from webpack\n   *\n   * @private\n   */\n\n\n  apply(compiler) {\n    this.propagateWebpackConfig(compiler);\n    compiler.hooks.make.tapPromise(this.constructor.name, compilation => this.handleMake(compilation, compiler).catch(error => compilation.errors.push(error)));\n    compiler.hooks.emit.tapPromise(this.constructor.name, compilation => this.handleEmit(compilation).catch(error => compilation.errors.push(error)));\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Object} parentCompiler The webpack parent compiler.\n   *\n   * @private\n   */\n\n\n  async performChildCompilation(compilation, parentCompiler) {\n    const outputOptions = {\n      path: parentCompiler.options.output.path,\n      filename: this.config.swDest\n    };\n    const childCompiler = compilation.createChildCompiler(this.constructor.name, outputOptions);\n    childCompiler.context = parentCompiler.context;\n    childCompiler.inputFileSystem = parentCompiler.inputFileSystem;\n    childCompiler.outputFileSystem = parentCompiler.outputFileSystem;\n\n    if (Array.isArray(this.config.webpackCompilationPlugins)) {\n      for (const plugin of this.config.webpackCompilationPlugins) {\n        plugin.apply(childCompiler);\n      }\n    }\n\n    new SingleEntryPlugin(parentCompiler.context, this.config.swSrc, this.constructor.name).apply(childCompiler);\n    await new Promise((resolve, reject) => {\n      childCompiler.runAsChild((error, entries, childCompilation) => {\n        if (error) {\n          reject(error);\n        } else {\n          compilation.warnings = compilation.warnings.concat(childCompilation.warnings);\n          compilation.errors = compilation.errors.concat(childCompilation.errors);\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Object} parentCompiler The webpack parent compiler.\n   *\n   * @private\n   */\n\n\n  addSrcToAssets(compilation, parentCompiler) {\n    const source = parentCompiler.inputFileSystem.readFileSync(this.config.swSrc).toString();\n    compilation.assets[this.config.swDest] = new RawSource(source);\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Object} parentCompiler The webpack parent compiler.\n   *\n   * @private\n   */\n\n\n  async handleMake(compilation, parentCompiler) {\n    try {\n      this.config = validate(this.config, webpackInjectManifestSchema);\n    } catch (error) {\n      throw new Error(`Please check your ${this.constructor.name} plugin ` + `configuration:\\n${error.message}`);\n    }\n\n    this.config.swDest = relativeToOutputPath(compilation, this.config.swDest);\n\n    _generatedAssetNames.add(this.config.swDest);\n\n    if (this.config.compileSrc) {\n      await this.performChildCompilation(compilation, parentCompiler);\n    } else {\n      this.addSrcToAssets(compilation, parentCompiler);\n    }\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   *\n   * @private\n   */\n\n\n  async handleEmit(compilation) {\n    // See https://github.com/GoogleChrome/workbox/issues/1790\n    if (this.alreadyCalled) {\n      compilation.warnings.push(`${this.constructor.name} has been called ` + `multiple times, perhaps due to running webpack in --watch mode. The ` + `precache manifest generated after the first call may be inaccurate! ` + `Please see https://github.com/GoogleChrome/workbox/issues/1790 for ` + `more information.`);\n    } else {\n      this.alreadyCalled = true;\n    }\n\n    const config = Object.assign({}, this.config); // Ensure that we don't precache any of the assets generated by *any*\n    // instance of this plugin.\n\n    config.exclude.push(({\n      asset\n    }) => _generatedAssetNames.has(asset.name)); // See https://webpack.js.org/contribute/plugin-patterns/#monitoring-the-watch-graph\n\n    const absoluteSwSrc = upath.resolve(this.config.swSrc);\n    compilation.fileDependencies.add(absoluteSwSrc);\n    const swAsset = compilation.assets[config.swDest];\n    const initialSWAssetString = swAsset.source();\n\n    if (!initialSWAssetString.includes(config.injectionPoint)) {\n      throw new Error(`Can't find ${config.injectionPoint} in your SW source.`);\n    }\n\n    const manifestEntries = await getManifestEntriesFromCompilation(compilation, config);\n    let manifestString = stringify(manifestEntries);\n\n    if (this.config.compileSrc) {\n      // See https://github.com/GoogleChrome/workbox/issues/2263\n      manifestString = manifestString.replace(/\"/g, `'`);\n    }\n\n    const sourcemapAssetName = getSourcemapAssetName(compilation, initialSWAssetString, config.swDest);\n\n    if (sourcemapAssetName) {\n      const sourcemapAsset = compilation.assets[sourcemapAssetName];\n      const {\n        source,\n        map\n      } = await replaceAndUpdateSourceMap({\n        jsFilename: config.swDest,\n        originalMap: JSON.parse(sourcemapAsset.source()),\n        originalSource: initialSWAssetString,\n        replaceString: manifestString,\n        searchString: config.injectionPoint\n      });\n      compilation.assets[sourcemapAssetName] = new RawSource(map);\n      compilation.assets[config.swDest] = new RawSource(source);\n    } else {\n      // If there's no sourcemap associated with swDest, a simple string\n      // replacement will suffice.\n      compilation.assets[config.swDest] = new RawSource(initialSWAssetString.replace(config.injectionPoint, manifestString));\n    }\n  }\n\n}\n\nmodule.exports = InjectManifest;","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/frontend/node_modules/workbox-webpack-plugin/build/inject-manifest.js"],"names":["RawSource","require","SingleEntryPlugin","replaceAndUpdateSourceMap","stringify","upath","validate","webpackInjectManifestSchema","getManifestEntriesFromCompilation","getSourcemapAssetName","relativeToOutputPath","_generatedAssetNames","Set","InjectManifest","constructor","config","alreadyCalled","propagateWebpackConfig","compiler","Object","assign","mode","apply","hooks","make","tapPromise","name","compilation","handleMake","catch","error","errors","push","emit","handleEmit","performChildCompilation","parentCompiler","outputOptions","path","options","output","filename","swDest","childCompiler","createChildCompiler","context","inputFileSystem","outputFileSystem","Array","isArray","webpackCompilationPlugins","plugin","swSrc","Promise","resolve","reject","runAsChild","entries","childCompilation","warnings","concat","addSrcToAssets","source","readFileSync","toString","assets","Error","message","add","compileSrc","exclude","asset","has","absoluteSwSrc","fileDependencies","swAsset","initialSWAssetString","includes","injectionPoint","manifestEntries","manifestString","replace","sourcemapAssetName","sourcemapAsset","map","jsFilename","originalMap","JSON","parse","originalSource","replaceString","searchString","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAM;AACJA,EAAAA;AADI,IAEFC,OAAO,CAAC,iBAAD,CAFX;;AAIA,MAAM;AACJC,EAAAA;AADI,IAEFD,OAAO,CAAC,SAAD,CAFX;;AAIA,MAAME,yBAAyB,GAAGF,OAAO,CAAC,uDAAD,CAAzC;;AAEA,MAAMG,SAAS,GAAGH,OAAO,CAAC,4BAAD,CAAzB;;AAEA,MAAMI,KAAK,GAAGJ,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,0CAAD,CAAxB;;AAEA,MAAMM,2BAA2B,GAAGN,OAAO,CAAC,4DAAD,CAA3C;;AAEA,MAAMO,iCAAiC,GAAGP,OAAO,CAAC,6CAAD,CAAjD;;AAEA,MAAMQ,qBAAqB,GAAGR,OAAO,CAAC,gCAAD,CAArC;;AAEA,MAAMS,oBAAoB,GAAGT,OAAO,CAAC,+BAAD,CAApC,C,CAAuE;AACvE;;;AAGA,MAAMU,oBAAoB,GAAG,IAAIC,GAAJ,EAA7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAMC,cAAN,CAAqB;AACnB;;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,CAACC,MAAM,GAAG,EAAV,EAAc;AACvB,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,aAAL,GAAqB,KAArB;AACD;AACD;AACF;AACA;AACA;AACA;;;AAGEC,EAAAA,sBAAsB,CAACC,QAAD,EAAW;AAC/B;AACA;AACA,SAAKH,MAAL,GAAcI,MAAM,CAACC,MAAP,CAAc;AAC1BC,MAAAA,IAAI,EAAEH,QAAQ,CAACG;AADW,KAAd,EAEX,KAAKN,MAFM,CAAd;AAGD;AACD;AACF;AACA;AACA;AACA;;;AAGEO,EAAAA,KAAK,CAACJ,QAAD,EAAW;AACd,SAAKD,sBAAL,CAA4BC,QAA5B;AACAA,IAAAA,QAAQ,CAACK,KAAT,CAAeC,IAAf,CAAoBC,UAApB,CAA+B,KAAKX,WAAL,CAAiBY,IAAhD,EAAsDC,WAAW,IAAI,KAAKC,UAAL,CAAgBD,WAAhB,EAA6BT,QAA7B,EAAuCW,KAAvC,CAA6CC,KAAK,IAAIH,WAAW,CAACI,MAAZ,CAAmBC,IAAnB,CAAwBF,KAAxB,CAAtD,CAArE;AACAZ,IAAAA,QAAQ,CAACK,KAAT,CAAeU,IAAf,CAAoBR,UAApB,CAA+B,KAAKX,WAAL,CAAiBY,IAAhD,EAAsDC,WAAW,IAAI,KAAKO,UAAL,CAAgBP,WAAhB,EAA6BE,KAA7B,CAAmCC,KAAK,IAAIH,WAAW,CAACI,MAAZ,CAAmBC,IAAnB,CAAwBF,KAAxB,CAA5C,CAArE;AACD;AACD;AACF;AACA;AACA;AACA;AACA;;;AAG+B,QAAvBK,uBAAuB,CAACR,WAAD,EAAcS,cAAd,EAA8B;AACzD,UAAMC,aAAa,GAAG;AACpBC,MAAAA,IAAI,EAAEF,cAAc,CAACG,OAAf,CAAuBC,MAAvB,CAA8BF,IADhB;AAEpBG,MAAAA,QAAQ,EAAE,KAAK1B,MAAL,CAAY2B;AAFF,KAAtB;AAIA,UAAMC,aAAa,GAAGhB,WAAW,CAACiB,mBAAZ,CAAgC,KAAK9B,WAAL,CAAiBY,IAAjD,EAAuDW,aAAvD,CAAtB;AACAM,IAAAA,aAAa,CAACE,OAAd,GAAwBT,cAAc,CAACS,OAAvC;AACAF,IAAAA,aAAa,CAACG,eAAd,GAAgCV,cAAc,CAACU,eAA/C;AACAH,IAAAA,aAAa,CAACI,gBAAd,GAAiCX,cAAc,CAACW,gBAAhD;;AAEA,QAAIC,KAAK,CAACC,OAAN,CAAc,KAAKlC,MAAL,CAAYmC,yBAA1B,CAAJ,EAA0D;AACxD,WAAK,MAAMC,MAAX,IAAqB,KAAKpC,MAAL,CAAYmC,yBAAjC,EAA4D;AAC1DC,QAAAA,MAAM,CAAC7B,KAAP,CAAaqB,aAAb;AACD;AACF;;AAED,QAAIzC,iBAAJ,CAAsBkC,cAAc,CAACS,OAArC,EAA8C,KAAK9B,MAAL,CAAYqC,KAA1D,EAAiE,KAAKtC,WAAL,CAAiBY,IAAlF,EAAwFJ,KAAxF,CAA8FqB,aAA9F;AACA,UAAM,IAAIU,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACrCZ,MAAAA,aAAa,CAACa,UAAd,CAAyB,CAAC1B,KAAD,EAAQ2B,OAAR,EAAiBC,gBAAjB,KAAsC;AAC7D,YAAI5B,KAAJ,EAAW;AACTyB,UAAAA,MAAM,CAACzB,KAAD,CAAN;AACD,SAFD,MAEO;AACLH,UAAAA,WAAW,CAACgC,QAAZ,GAAuBhC,WAAW,CAACgC,QAAZ,CAAqBC,MAArB,CAA4BF,gBAAgB,CAACC,QAA7C,CAAvB;AACAhC,UAAAA,WAAW,CAACI,MAAZ,GAAqBJ,WAAW,CAACI,MAAZ,CAAmB6B,MAAnB,CAA0BF,gBAAgB,CAAC3B,MAA3C,CAArB;AACAuB,UAAAA,OAAO;AACR;AACF,OARD;AASD,KAVK,CAAN;AAWD;AACD;AACF;AACA;AACA;AACA;AACA;;;AAGEO,EAAAA,cAAc,CAAClC,WAAD,EAAcS,cAAd,EAA8B;AAC1C,UAAM0B,MAAM,GAAG1B,cAAc,CAACU,eAAf,CAA+BiB,YAA/B,CAA4C,KAAKhD,MAAL,CAAYqC,KAAxD,EAA+DY,QAA/D,EAAf;AACArC,IAAAA,WAAW,CAACsC,MAAZ,CAAmB,KAAKlD,MAAL,CAAY2B,MAA/B,IAAyC,IAAI1C,SAAJ,CAAc8D,MAAd,CAAzC;AACD;AACD;AACF;AACA;AACA;AACA;AACA;;;AAGkB,QAAVlC,UAAU,CAACD,WAAD,EAAcS,cAAd,EAA8B;AAC5C,QAAI;AACF,WAAKrB,MAAL,GAAcT,QAAQ,CAAC,KAAKS,MAAN,EAAcR,2BAAd,CAAtB;AACD,KAFD,CAEE,OAAOuB,KAAP,EAAc;AACd,YAAM,IAAIoC,KAAJ,CAAW,qBAAoB,KAAKpD,WAAL,CAAiBY,IAAK,UAA3C,GAAwD,mBAAkBI,KAAK,CAACqC,OAAQ,EAAlG,CAAN;AACD;;AAED,SAAKpD,MAAL,CAAY2B,MAAZ,GAAqBhC,oBAAoB,CAACiB,WAAD,EAAc,KAAKZ,MAAL,CAAY2B,MAA1B,CAAzC;;AAEA/B,IAAAA,oBAAoB,CAACyD,GAArB,CAAyB,KAAKrD,MAAL,CAAY2B,MAArC;;AAEA,QAAI,KAAK3B,MAAL,CAAYsD,UAAhB,EAA4B;AAC1B,YAAM,KAAKlC,uBAAL,CAA6BR,WAA7B,EAA0CS,cAA1C,CAAN;AACD,KAFD,MAEO;AACL,WAAKyB,cAAL,CAAoBlC,WAApB,EAAiCS,cAAjC;AACD;AACF;AACD;AACF;AACA;AACA;AACA;;;AAGkB,QAAVF,UAAU,CAACP,WAAD,EAAc;AAC5B;AACA,QAAI,KAAKX,aAAT,EAAwB;AACtBW,MAAAA,WAAW,CAACgC,QAAZ,CAAqB3B,IAArB,CAA2B,GAAE,KAAKlB,WAAL,CAAiBY,IAAK,mBAAzB,GAA+C,sEAA/C,GAAwH,sEAAxH,GAAiM,qEAAjM,GAAyQ,mBAAnS;AACD,KAFD,MAEO;AACL,WAAKV,aAAL,GAAqB,IAArB;AACD;;AAED,UAAMD,MAAM,GAAGI,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKL,MAAvB,CAAf,CAR4B,CAQmB;AAC/C;;AAEAA,IAAAA,MAAM,CAACuD,OAAP,CAAetC,IAAf,CAAoB,CAAC;AACnBuC,MAAAA;AADmB,KAAD,KAEd5D,oBAAoB,CAAC6D,GAArB,CAAyBD,KAAK,CAAC7C,IAA/B,CAFN,EAX4B,CAaiB;;AAE7C,UAAM+C,aAAa,GAAGpE,KAAK,CAACiD,OAAN,CAAc,KAAKvC,MAAL,CAAYqC,KAA1B,CAAtB;AACAzB,IAAAA,WAAW,CAAC+C,gBAAZ,CAA6BN,GAA7B,CAAiCK,aAAjC;AACA,UAAME,OAAO,GAAGhD,WAAW,CAACsC,MAAZ,CAAmBlD,MAAM,CAAC2B,MAA1B,CAAhB;AACA,UAAMkC,oBAAoB,GAAGD,OAAO,CAACb,MAAR,EAA7B;;AAEA,QAAI,CAACc,oBAAoB,CAACC,QAArB,CAA8B9D,MAAM,CAAC+D,cAArC,CAAL,EAA2D;AACzD,YAAM,IAAIZ,KAAJ,CAAW,cAAanD,MAAM,CAAC+D,cAAe,qBAA9C,CAAN;AACD;;AAED,UAAMC,eAAe,GAAG,MAAMvE,iCAAiC,CAACmB,WAAD,EAAcZ,MAAd,CAA/D;AACA,QAAIiE,cAAc,GAAG5E,SAAS,CAAC2E,eAAD,CAA9B;;AAEA,QAAI,KAAKhE,MAAL,CAAYsD,UAAhB,EAA4B;AAC1B;AACAW,MAAAA,cAAc,GAAGA,cAAc,CAACC,OAAf,CAAuB,IAAvB,EAA8B,GAA9B,CAAjB;AACD;;AAED,UAAMC,kBAAkB,GAAGzE,qBAAqB,CAACkB,WAAD,EAAciD,oBAAd,EAAoC7D,MAAM,CAAC2B,MAA3C,CAAhD;;AAEA,QAAIwC,kBAAJ,EAAwB;AACtB,YAAMC,cAAc,GAAGxD,WAAW,CAACsC,MAAZ,CAAmBiB,kBAAnB,CAAvB;AACA,YAAM;AACJpB,QAAAA,MADI;AAEJsB,QAAAA;AAFI,UAGF,MAAMjF,yBAAyB,CAAC;AAClCkF,QAAAA,UAAU,EAAEtE,MAAM,CAAC2B,MADe;AAElC4C,QAAAA,WAAW,EAAEC,IAAI,CAACC,KAAL,CAAWL,cAAc,CAACrB,MAAf,EAAX,CAFqB;AAGlC2B,QAAAA,cAAc,EAAEb,oBAHkB;AAIlCc,QAAAA,aAAa,EAAEV,cAJmB;AAKlCW,QAAAA,YAAY,EAAE5E,MAAM,CAAC+D;AALa,OAAD,CAHnC;AAUAnD,MAAAA,WAAW,CAACsC,MAAZ,CAAmBiB,kBAAnB,IAAyC,IAAIlF,SAAJ,CAAcoF,GAAd,CAAzC;AACAzD,MAAAA,WAAW,CAACsC,MAAZ,CAAmBlD,MAAM,CAAC2B,MAA1B,IAAoC,IAAI1C,SAAJ,CAAc8D,MAAd,CAApC;AACD,KAdD,MAcO;AACL;AACA;AACAnC,MAAAA,WAAW,CAACsC,MAAZ,CAAmBlD,MAAM,CAAC2B,MAA1B,IAAoC,IAAI1C,SAAJ,CAAc4E,oBAAoB,CAACK,OAArB,CAA6BlE,MAAM,CAAC+D,cAApC,EAAoDE,cAApD,CAAd,CAApC;AACD;AACF;;AAvPkB;;AA2PrBY,MAAM,CAACC,OAAP,GAAiBhF,cAAjB","sourcesContent":["\"use strict\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nconst {\n  RawSource\n} = require('webpack-sources');\n\nconst {\n  SingleEntryPlugin\n} = require('webpack');\n\nconst replaceAndUpdateSourceMap = require('workbox-build/build/lib/replace-and-update-source-map');\n\nconst stringify = require('fast-json-stable-stringify');\n\nconst upath = require('upath');\n\nconst validate = require('workbox-build/build/lib/validate-options');\n\nconst webpackInjectManifestSchema = require('workbox-build/build/options/schema/webpack-inject-manifest');\n\nconst getManifestEntriesFromCompilation = require('./lib/get-manifest-entries-from-compilation');\n\nconst getSourcemapAssetName = require('./lib/get-sourcemap-asset-name');\n\nconst relativeToOutputPath = require('./lib/relative-to-output-path'); // Used to keep track of swDest files written by *any* instance of this plugin.\n// See https://github.com/GoogleChrome/workbox/issues/2181\n\n\nconst _generatedAssetNames = new Set();\n/**\n * This class supports compiling a service worker file provided via `swSrc`,\n * and injecting into that service worker a list of URLs and revision\n * information for precaching based on the webpack asset pipeline.\n *\n * Use an instance of `InjectManifest` in the\n * [`plugins` array](https://webpack.js.org/concepts/plugins/#usage) of a\n * webpack config.\n *\n * @memberof module:workbox-webpack-plugin\n */\n\n\nclass InjectManifest {\n  // eslint-disable-next-line jsdoc/newline-after-description\n\n  /**\n   * Creates an instance of InjectManifest.\n   *\n   * @param {Object} config The configuration to use.\n   *\n   * @param {string} config.swSrc An existing service worker file that will be\n   * compiled and have a precache manifest injected into it.\n   *\n   * @param {Array<module:workbox-build.ManifestEntry>} [config.additionalManifestEntries]\n   * A list of entries to be precached, in addition to any entries that are\n   * generated as part of the build configuration.\n   *\n   * @param {Array<string>} [config.chunks] One or more chunk names whose corresponding\n   * output files should be included in the precache manifest.\n   *\n   * @param {boolean} [config.compileSrc=true] When `true` (the default), the\n   * `swSrc` file will be compiled by webpack. When `false`, compilation will\n   * not occur (and `webpackCompilationPlugins` can't be used.) Set to `false`\n   * if you want to inject the manifest into, e.g., a JSON file.\n   *\n   * @param {RegExp} [config.dontCacheBustURLsMatching] Assets that match this will be\n   * assumed to be uniquely versioned via their URL, and exempted from the normal\n   * HTTP cache-busting that's done when populating the precache. While not\n   * required, it's recommended that if your existing build process already\n   * inserts a `[hash]` value into each filename, you provide a RegExp that will\n   * detect that, as it will reduce the bandwidth consumed when precaching.\n   *\n   * @param {Array<string|RegExp|Function>} [config.exclude=[/\\.map$/, /^manifest.*\\.js$]]\n   * One or more specifiers used to exclude assets from the precache manifest.\n   * This is interpreted following\n   * [the same rules](https://webpack.js.org/configuration/module/#condition)\n   * as `webpack`'s standard `exclude` option.\n   *\n   * @param {Array<string>} [config.importScriptsViaChunks] One or more names of\n   * webpack chunks. The content of those chunks will be included in the\n   * generated service worker, via a call to `importScripts()`.\n   *\n   * @param {Array<string>} [config.excludeChunks] One or more chunk names whose\n   * corresponding output files should be excluded from the precache manifest.\n   *\n   * @param {Array<string|RegExp|Function>} [config.include]\n   * One or more specifiers used to include assets in the precache manifest.\n   * This is interpreted following\n   * [the same rules](https://webpack.js.org/configuration/module/#condition)\n   * as `webpack`'s standard `include` option.\n   *\n   * @param  {string} [config.injectionPoint='self.__WB_MANIFEST'] The string to\n   * find inside of the `swSrc` file. Once found, it will be replaced by the\n   * generated precache manifest.\n   *\n   * @param {Array<module:workbox-build.ManifestTransform>} [config.manifestTransforms]\n   * One or more functions which will be applied sequentially against the\n   * generated manifest. If `modifyURLPrefix` or `dontCacheBustURLsMatching` are\n   * also specified, their corresponding transformations will be applied first.\n   *\n   * @param {number} [config.maximumFileSizeToCacheInBytes=2097152] This value can be\n   * used to determine the maximum size of files that will be precached. This\n   * prevents you from inadvertently precaching very large files that might have\n   * accidentally matched one of your patterns.\n   *\n   * @param {string} [config.mode] If set to 'production', then an optimized service\n   * worker bundle that excludes debugging info will be produced. If not explicitly\n   * configured here, the `mode` value configured in the current `webpack`\n   * compilation will be used.\n   *\n   * @param {object<string, string>} [config.modifyURLPrefix] A mapping of prefixes\n   * that, if present in an entry in the precache manifest, will be replaced with\n   * the corresponding value. This can be used to, for example, remove or add a\n   * path prefix from a manifest entry if your web hosting setup doesn't match\n   * your local filesystem setup. As an alternative with more flexibility, you can\n   * use the `manifestTransforms` option and provide a function that modifies the\n   * entries in the manifest using whatever logic you provide.\n   *\n   * @param {string} [config.swDest] The asset name of the\n   * service worker file that will be created by this plugin. If omitted, the\n   * name will be based on the `swSrc` name.\n   *\n   * @param {Array<Object>} [config.webpackCompilationPlugins] Optional `webpack`\n   * plugins that will be used when compiling the `swSrc` input file.\n   */\n  constructor(config = {}) {\n    this.config = config;\n    this.alreadyCalled = false;\n  }\n  /**\n   * @param {Object} [compiler] default compiler object passed from webpack\n   *\n   * @private\n   */\n\n\n  propagateWebpackConfig(compiler) {\n    // Because this.config is listed last, properties that are already set\n    // there take precedence over derived properties from the compiler.\n    this.config = Object.assign({\n      mode: compiler.mode\n    }, this.config);\n  }\n  /**\n   * @param {Object} [compiler] default compiler object passed from webpack\n   *\n   * @private\n   */\n\n\n  apply(compiler) {\n    this.propagateWebpackConfig(compiler);\n    compiler.hooks.make.tapPromise(this.constructor.name, compilation => this.handleMake(compilation, compiler).catch(error => compilation.errors.push(error)));\n    compiler.hooks.emit.tapPromise(this.constructor.name, compilation => this.handleEmit(compilation).catch(error => compilation.errors.push(error)));\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Object} parentCompiler The webpack parent compiler.\n   *\n   * @private\n   */\n\n\n  async performChildCompilation(compilation, parentCompiler) {\n    const outputOptions = {\n      path: parentCompiler.options.output.path,\n      filename: this.config.swDest\n    };\n    const childCompiler = compilation.createChildCompiler(this.constructor.name, outputOptions);\n    childCompiler.context = parentCompiler.context;\n    childCompiler.inputFileSystem = parentCompiler.inputFileSystem;\n    childCompiler.outputFileSystem = parentCompiler.outputFileSystem;\n\n    if (Array.isArray(this.config.webpackCompilationPlugins)) {\n      for (const plugin of this.config.webpackCompilationPlugins) {\n        plugin.apply(childCompiler);\n      }\n    }\n\n    new SingleEntryPlugin(parentCompiler.context, this.config.swSrc, this.constructor.name).apply(childCompiler);\n    await new Promise((resolve, reject) => {\n      childCompiler.runAsChild((error, entries, childCompilation) => {\n        if (error) {\n          reject(error);\n        } else {\n          compilation.warnings = compilation.warnings.concat(childCompilation.warnings);\n          compilation.errors = compilation.errors.concat(childCompilation.errors);\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Object} parentCompiler The webpack parent compiler.\n   *\n   * @private\n   */\n\n\n  addSrcToAssets(compilation, parentCompiler) {\n    const source = parentCompiler.inputFileSystem.readFileSync(this.config.swSrc).toString();\n    compilation.assets[this.config.swDest] = new RawSource(source);\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   * @param {Object} parentCompiler The webpack parent compiler.\n   *\n   * @private\n   */\n\n\n  async handleMake(compilation, parentCompiler) {\n    try {\n      this.config = validate(this.config, webpackInjectManifestSchema);\n    } catch (error) {\n      throw new Error(`Please check your ${this.constructor.name} plugin ` + `configuration:\\n${error.message}`);\n    }\n\n    this.config.swDest = relativeToOutputPath(compilation, this.config.swDest);\n\n    _generatedAssetNames.add(this.config.swDest);\n\n    if (this.config.compileSrc) {\n      await this.performChildCompilation(compilation, parentCompiler);\n    } else {\n      this.addSrcToAssets(compilation, parentCompiler);\n    }\n  }\n  /**\n   * @param {Object} compilation The webpack compilation.\n   *\n   * @private\n   */\n\n\n  async handleEmit(compilation) {\n    // See https://github.com/GoogleChrome/workbox/issues/1790\n    if (this.alreadyCalled) {\n      compilation.warnings.push(`${this.constructor.name} has been called ` + `multiple times, perhaps due to running webpack in --watch mode. The ` + `precache manifest generated after the first call may be inaccurate! ` + `Please see https://github.com/GoogleChrome/workbox/issues/1790 for ` + `more information.`);\n    } else {\n      this.alreadyCalled = true;\n    }\n\n    const config = Object.assign({}, this.config); // Ensure that we don't precache any of the assets generated by *any*\n    // instance of this plugin.\n\n    config.exclude.push(({\n      asset\n    }) => _generatedAssetNames.has(asset.name)); // See https://webpack.js.org/contribute/plugin-patterns/#monitoring-the-watch-graph\n\n    const absoluteSwSrc = upath.resolve(this.config.swSrc);\n    compilation.fileDependencies.add(absoluteSwSrc);\n    const swAsset = compilation.assets[config.swDest];\n    const initialSWAssetString = swAsset.source();\n\n    if (!initialSWAssetString.includes(config.injectionPoint)) {\n      throw new Error(`Can't find ${config.injectionPoint} in your SW source.`);\n    }\n\n    const manifestEntries = await getManifestEntriesFromCompilation(compilation, config);\n    let manifestString = stringify(manifestEntries);\n\n    if (this.config.compileSrc) {\n      // See https://github.com/GoogleChrome/workbox/issues/2263\n      manifestString = manifestString.replace(/\"/g, `'`);\n    }\n\n    const sourcemapAssetName = getSourcemapAssetName(compilation, initialSWAssetString, config.swDest);\n\n    if (sourcemapAssetName) {\n      const sourcemapAsset = compilation.assets[sourcemapAssetName];\n      const {\n        source,\n        map\n      } = await replaceAndUpdateSourceMap({\n        jsFilename: config.swDest,\n        originalMap: JSON.parse(sourcemapAsset.source()),\n        originalSource: initialSWAssetString,\n        replaceString: manifestString,\n        searchString: config.injectionPoint\n      });\n      compilation.assets[sourcemapAssetName] = new RawSource(map);\n      compilation.assets[config.swDest] = new RawSource(source);\n    } else {\n      // If there's no sourcemap associated with swDest, a simple string\n      // replacement will suffice.\n      compilation.assets[config.swDest] = new RawSource(initialSWAssetString.replace(config.injectionPoint, manifestString));\n    }\n  }\n\n}\n\nmodule.exports = InjectManifest;"]},"metadata":{},"sourceType":"script"}