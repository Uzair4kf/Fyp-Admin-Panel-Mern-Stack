{"ast":null,"code":"'use strict';\n\nconst {\n  Readable,\n  Writable\n} = require('stream');\n\nconst StreamSearch = require('streamsearch');\n\nconst {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition\n} = require('../utils.js');\n\nconst BUF_CRLF = Buffer.from('\\r\\n');\nconst BUF_CR = Buffer.from('\\r');\nconst BUF_DASH = Buffer.from('-');\n\nfunction noop() {}\n\nconst MAX_HEADER_PAIRS = 2000; // From node\n\nconst MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)\n\nconst HPARSER_NAME = 0;\nconst HPARSER_PRE_OWS = 1;\nconst HPARSER_VALUE = 2;\n\nclass HeaderParser {\n  constructor(cb) {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n    this.cb = cb;\n  }\n\n  reset() {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n  }\n\n  push(chunk, pos, end) {\n    let start = pos;\n\n    while (pos < end) {\n      switch (this.state) {\n        case HPARSER_NAME:\n          {\n            let done = false;\n\n            for (; pos < end; ++pos) {\n              if (this.byteCount === MAX_HEADER_SIZE) return -1;\n              ++this.byteCount;\n              const code = chunk[pos];\n\n              if (TOKEN[code] !== 1) {\n                if (code !== 58\n                /* ':' */\n                ) return -1;\n                this.name += chunk.latin1Slice(start, pos);\n                if (this.name.length === 0) return -1;\n                ++pos;\n                done = true;\n                this.state = HPARSER_PRE_OWS;\n                break;\n              }\n            }\n\n            if (!done) {\n              this.name += chunk.latin1Slice(start, pos);\n              break;\n            } // FALLTHROUGH\n\n          }\n\n        case HPARSER_PRE_OWS:\n          {\n            // Skip optional whitespace\n            let done = false;\n\n            for (; pos < end; ++pos) {\n              if (this.byteCount === MAX_HEADER_SIZE) return -1;\n              ++this.byteCount;\n              const code = chunk[pos];\n\n              if (code !== 32\n              /* ' ' */\n              && code !== 9\n              /* '\\t' */\n              ) {\n                start = pos;\n                done = true;\n                this.state = HPARSER_VALUE;\n                break;\n              }\n            }\n\n            if (!done) break; // FALLTHROUGH\n          }\n\n        case HPARSER_VALUE:\n          switch (this.crlf) {\n            case 0:\n              // Nothing yet\n              for (; pos < end; ++pos) {\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                const code = chunk[pos];\n\n                if (FIELD_VCHAR[code] !== 1) {\n                  if (code !== 13\n                  /* '\\r' */\n                  ) return -1;\n                  ++this.crlf;\n                  break;\n                }\n              }\n\n              this.value += chunk.latin1Slice(start, pos++);\n              break;\n\n            case 1:\n              // Received CR\n              if (this.byteCount === MAX_HEADER_SIZE) return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10\n              /* '\\n' */\n              ) return -1;\n              ++this.crlf;\n              break;\n\n            case 2:\n              {\n                // Received CR LF\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                const code = chunk[pos];\n\n                if (code === 32\n                /* ' ' */\n                || code === 9\n                /* '\\t' */\n                ) {\n                  // Folded value\n                  start = pos;\n                  this.crlf = 0;\n                } else {\n                  if (++this.pairCount < MAX_HEADER_PAIRS) {\n                    this.name = this.name.toLowerCase();\n                    if (this.header[this.name] === undefined) this.header[this.name] = [this.value];else this.header[this.name].push(this.value);\n                  }\n\n                  if (code === 13\n                  /* '\\r' */\n                  ) {\n                    ++this.crlf;\n                    ++pos;\n                  } else {\n                    // Assume start of next header field name\n                    start = pos;\n                    this.crlf = 0;\n                    this.state = HPARSER_NAME;\n                    this.name = '';\n                    this.value = '';\n                  }\n                }\n\n                break;\n              }\n\n            case 3:\n              {\n                // Received CR LF CR\n                if (this.byteCount === MAX_HEADER_SIZE) return -1;\n                ++this.byteCount;\n                if (chunk[pos++] !== 10\n                /* '\\n' */\n                ) return -1; // End of header\n\n                const header = this.header;\n                this.reset();\n                this.cb(header);\n                return pos;\n              }\n          }\n\n          break;\n      }\n    }\n\n    return pos;\n  }\n\n}\n\nclass FileStream extends Readable {\n  constructor(opts, owner) {\n    super(opts);\n    this.truncated = false;\n    this._readcb = null;\n    this.once('end', () => {\n      // We need to make sure that we call any outstanding _writecb() that is\n      // associated with this file so that processing of the rest of the form\n      // can continue. This may not happen if the file stream ends right after\n      // backpressure kicks in, so we force it here.\n      this._read();\n\n      if (--owner._fileEndsLeft === 0 && owner._finalcb) {\n        const cb = owner._finalcb;\n        owner._finalcb = null; // Make sure other 'end' event handlers get a chance to be executed\n        // before busboy's 'finish' event is emitted\n\n        process.nextTick(cb);\n      }\n    });\n  }\n\n  _read(n) {\n    const cb = this._readcb;\n\n    if (cb) {\n      this._readcb = null;\n      cb();\n    }\n  }\n\n}\n\nconst ignoreData = {\n  push: (chunk, pos) => {},\n  destroy: () => {}\n};\n\nfunction callAndUnsetCb(self, err) {\n  const cb = self._writecb;\n  self._writecb = null;\n  if (err) self.destroy(err);else if (cb) cb();\n}\n\nfunction nullDecoder(val, hint) {\n  return val;\n}\n\nclass Multipart extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined\n    };\n    super(streamOpts);\n    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string') throw new Error('Multipart: Boundary not found');\n    const boundary = cfg.conType.params.boundary;\n    const paramDecoder = typeof cfg.defParamCharset === 'string' && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;\n    const defCharset = cfg.defCharset || 'utf8';\n    const preservePath = cfg.preservePath;\n    const fileOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.fileHwm === 'number' ? cfg.fileHwm : undefined\n    };\n    const limits = cfg.limits;\n    const fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;\n    const fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity;\n    const filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity;\n    const fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;\n    const partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;\n    let parts = -1; // Account for initial boundary\n\n    let fields = 0;\n    let files = 0;\n    let skipPart = false;\n    this._fileEndsLeft = 0;\n    this._fileStream = undefined;\n    this._complete = false;\n    let fileSize = 0;\n    let field;\n    let fieldSize = 0;\n    let partCharset;\n    let partEncoding;\n    let partType;\n    let partName;\n    let partTruncated = false;\n    let hitFilesLimit = false;\n    let hitFieldsLimit = false;\n    this._hparser = null;\n    const hparser = new HeaderParser(header => {\n      this._hparser = null;\n      skipPart = false;\n      partType = 'text/plain';\n      partCharset = defCharset;\n      partEncoding = '7bit';\n      partName = undefined;\n      partTruncated = false;\n      let filename;\n\n      if (!header['content-disposition']) {\n        skipPart = true;\n        return;\n      }\n\n      const disp = parseDisposition(header['content-disposition'][0], paramDecoder);\n\n      if (!disp || disp.type !== 'form-data') {\n        skipPart = true;\n        return;\n      }\n\n      if (disp.params) {\n        if (disp.params.name) partName = disp.params.name;\n        if (disp.params['filename*']) filename = disp.params['filename*'];else if (disp.params.filename) filename = disp.params.filename;\n        if (filename !== undefined && !preservePath) filename = basename(filename);\n      }\n\n      if (header['content-type']) {\n        const conType = parseContentType(header['content-type'][0]);\n\n        if (conType) {\n          partType = `${conType.type}/${conType.subtype}`;\n          if (conType.params && typeof conType.params.charset === 'string') partCharset = conType.params.charset.toLowerCase();\n        }\n      }\n\n      if (header['content-transfer-encoding']) partEncoding = header['content-transfer-encoding'][0].toLowerCase();\n\n      if (partType === 'application/octet-stream' || filename !== undefined) {\n        // File\n        if (files === filesLimit) {\n          if (!hitFilesLimit) {\n            hitFilesLimit = true;\n            this.emit('filesLimit');\n          }\n\n          skipPart = true;\n          return;\n        }\n\n        ++files;\n\n        if (this.listenerCount('file') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        fileSize = 0;\n        this._fileStream = new FileStream(fileOpts, this);\n        ++this._fileEndsLeft;\n        this.emit('file', partName, this._fileStream, {\n          filename,\n          encoding: partEncoding,\n          mimeType: partType\n        });\n      } else {\n        // Non-file\n        if (fields === fieldsLimit) {\n          if (!hitFieldsLimit) {\n            hitFieldsLimit = true;\n            this.emit('fieldsLimit');\n          }\n\n          skipPart = true;\n          return;\n        }\n\n        ++fields;\n\n        if (this.listenerCount('field') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        field = [];\n        fieldSize = 0;\n      }\n    });\n    let matchPostBoundary = 0;\n\n    const ssCb = (isMatch, data, start, end, isDataSafe) => {\n      retrydata: while (data) {\n        if (this._hparser !== null) {\n          const ret = this._hparser.push(data, start, end);\n\n          if (ret === -1) {\n            this._hparser = null;\n            hparser.reset();\n            this.emit('error', new Error('Malformed part header'));\n            break;\n          }\n\n          start = ret;\n        }\n\n        if (start === end) break;\n\n        if (matchPostBoundary !== 0) {\n          if (matchPostBoundary === 1) {\n            switch (data[start]) {\n              case 45:\n                // '-'\n                // Try matching '--' after boundary\n                matchPostBoundary = 2;\n                ++start;\n                break;\n\n              case 13:\n                // '\\r'\n                // Try matching CR LF before header\n                matchPostBoundary = 3;\n                ++start;\n                break;\n\n              default:\n                matchPostBoundary = 0;\n            }\n\n            if (start === end) return;\n          }\n\n          if (matchPostBoundary === 2) {\n            matchPostBoundary = 0;\n\n            if (data[start] === 45\n            /* '-' */\n            ) {\n              // End of multipart data\n              this._complete = true;\n              this._bparser = ignoreData;\n              return;\n            } // We saw something other than '-', so put the dash we consumed\n            // \"back\"\n\n\n            const writecb = this._writecb;\n            this._writecb = noop;\n            ssCb(false, BUF_DASH, 0, 1, false);\n            this._writecb = writecb;\n          } else if (matchPostBoundary === 3) {\n            matchPostBoundary = 0;\n\n            if (data[start] === 10\n            /* '\\n' */\n            ) {\n              ++start;\n              if (parts >= partsLimit) break; // Prepare the header parser\n\n              this._hparser = hparser;\n              if (start === end) break; // Process the remaining data as a header\n\n              continue retrydata;\n            } else {\n              // We saw something other than LF, so put the CR we consumed\n              // \"back\"\n              const writecb = this._writecb;\n              this._writecb = noop;\n              ssCb(false, BUF_CR, 0, 1, false);\n              this._writecb = writecb;\n            }\n          }\n        }\n\n        if (!skipPart) {\n          if (this._fileStream) {\n            let chunk;\n            const actualLen = Math.min(end - start, fileSizeLimit - fileSize);\n\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fileSize += chunk.length;\n\n            if (fileSize === fileSizeLimit) {\n              if (chunk.length > 0) this._fileStream.push(chunk);\n\n              this._fileStream.emit('limit');\n\n              this._fileStream.truncated = true;\n              skipPart = true;\n            } else if (!this._fileStream.push(chunk)) {\n              if (this._writecb) this._fileStream._readcb = this._writecb;\n              this._writecb = null;\n            }\n          } else if (field !== undefined) {\n            let chunk;\n            const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);\n\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fieldSize += actualLen;\n            field.push(chunk);\n\n            if (fieldSize === fieldSizeLimit) {\n              skipPart = true;\n              partTruncated = true;\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (isMatch) {\n        matchPostBoundary = 1;\n\n        if (this._fileStream) {\n          // End the active file stream if the previous part was a file\n          this._fileStream.push(null);\n\n          this._fileStream = null;\n        } else if (field !== undefined) {\n          let data;\n\n          switch (field.length) {\n            case 0:\n              data = '';\n              break;\n\n            case 1:\n              data = convertToUTF8(field[0], partCharset, 0);\n              break;\n\n            default:\n              data = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);\n          }\n\n          field = undefined;\n          fieldSize = 0;\n          this.emit('field', partName, data, {\n            nameTruncated: false,\n            valueTruncated: partTruncated,\n            encoding: partEncoding,\n            mimeType: partType\n          });\n        }\n\n        if (++parts === partsLimit) this.emit('partsLimit');\n      }\n    };\n\n    this._bparser = new StreamSearch(`\\r\\n--${boundary}`, ssCb);\n    this._writecb = null;\n    this._finalcb = null; // Just in case there is no preamble\n\n    this.write(BUF_CRLF);\n  }\n\n  static detect(conType) {\n    return conType.type === 'multipart' && conType.subtype === 'form-data';\n  }\n\n  _write(chunk, enc, cb) {\n    this._writecb = cb;\n\n    this._bparser.push(chunk, 0);\n\n    if (this._writecb) callAndUnsetCb(this);\n  }\n\n  _destroy(err, cb) {\n    this._hparser = null;\n    this._bparser = ignoreData;\n    if (!err) err = checkEndState(this);\n    const fileStream = this._fileStream;\n\n    if (fileStream) {\n      this._fileStream = null;\n      fileStream.destroy(err);\n    }\n\n    cb(err);\n  }\n\n  _final(cb) {\n    this._bparser.destroy();\n\n    if (!this._complete) return cb(new Error('Unexpected end of form'));\n    if (this._fileEndsLeft) this._finalcb = finalcb.bind(null, this, cb);else finalcb(this, cb);\n  }\n\n}\n\nfunction finalcb(self, cb, err) {\n  if (err) return cb(err);\n  err = checkEndState(self);\n  cb(err);\n}\n\nfunction checkEndState(self) {\n  if (self._hparser) return new Error('Malformed part header');\n  const fileStream = self._fileStream;\n\n  if (fileStream) {\n    self._fileStream = null;\n    fileStream.destroy(new Error('Unexpected end of file'));\n  }\n\n  if (!self._complete) return new Error('Unexpected end of form');\n}\n\nconst TOKEN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst FIELD_VCHAR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nmodule.exports = Multipart;","map":{"version":3,"sources":["/Users/limia/Desktop/Dummy Admin Temp/package/node_modules/busboy/lib/types/multipart.js"],"names":["Readable","Writable","require","StreamSearch","basename","convertToUTF8","getDecoder","parseContentType","parseDisposition","BUF_CRLF","Buffer","from","BUF_CR","BUF_DASH","noop","MAX_HEADER_PAIRS","MAX_HEADER_SIZE","HPARSER_NAME","HPARSER_PRE_OWS","HPARSER_VALUE","HeaderParser","constructor","cb","header","Object","create","pairCount","byteCount","state","name","value","crlf","reset","push","chunk","pos","end","start","done","code","TOKEN","latin1Slice","length","FIELD_VCHAR","toLowerCase","undefined","FileStream","opts","owner","truncated","_readcb","once","_read","_fileEndsLeft","_finalcb","process","nextTick","n","ignoreData","destroy","callAndUnsetCb","self","err","_writecb","nullDecoder","val","hint","Multipart","cfg","streamOpts","autoDestroy","emitClose","highWaterMark","conType","params","boundary","Error","paramDecoder","defParamCharset","defCharset","preservePath","fileOpts","fileHwm","limits","fieldSizeLimit","fieldSize","fileSizeLimit","fileSize","Infinity","filesLimit","files","fieldsLimit","fields","partsLimit","parts","skipPart","_fileStream","_complete","field","partCharset","partEncoding","partType","partName","partTruncated","hitFilesLimit","hitFieldsLimit","_hparser","hparser","filename","disp","type","subtype","charset","emit","listenerCount","encoding","mimeType","matchPostBoundary","ssCb","isMatch","data","isDataSafe","retrydata","ret","_bparser","writecb","actualLen","Math","min","allocUnsafe","copy","slice","concat","nameTruncated","valueTruncated","write","detect","_write","enc","_destroy","checkEndState","fileStream","_final","finalcb","bind","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { Readable, Writable } = require('stream');\n\nconst StreamSearch = require('streamsearch');\n\nconst {\n  basename,\n  convertToUTF8,\n  getDecoder,\n  parseContentType,\n  parseDisposition,\n} = require('../utils.js');\n\nconst BUF_CRLF = Buffer.from('\\r\\n');\nconst BUF_CR = Buffer.from('\\r');\nconst BUF_DASH = Buffer.from('-');\n\nfunction noop() {}\n\nconst MAX_HEADER_PAIRS = 2000; // From node\nconst MAX_HEADER_SIZE = 16 * 1024; // From node (its default value)\n\nconst HPARSER_NAME = 0;\nconst HPARSER_PRE_OWS = 1;\nconst HPARSER_VALUE = 2;\nclass HeaderParser {\n  constructor(cb) {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n    this.cb = cb;\n  }\n\n  reset() {\n    this.header = Object.create(null);\n    this.pairCount = 0;\n    this.byteCount = 0;\n    this.state = HPARSER_NAME;\n    this.name = '';\n    this.value = '';\n    this.crlf = 0;\n  }\n\n  push(chunk, pos, end) {\n    let start = pos;\n    while (pos < end) {\n      switch (this.state) {\n        case HPARSER_NAME: {\n          let done = false;\n          for (; pos < end; ++pos) {\n            if (this.byteCount === MAX_HEADER_SIZE)\n              return -1;\n            ++this.byteCount;\n            const code = chunk[pos];\n            if (TOKEN[code] !== 1) {\n              if (code !== 58/* ':' */)\n                return -1;\n              this.name += chunk.latin1Slice(start, pos);\n              if (this.name.length === 0)\n                return -1;\n              ++pos;\n              done = true;\n              this.state = HPARSER_PRE_OWS;\n              break;\n            }\n          }\n          if (!done) {\n            this.name += chunk.latin1Slice(start, pos);\n            break;\n          }\n          // FALLTHROUGH\n        }\n        case HPARSER_PRE_OWS: {\n          // Skip optional whitespace\n          let done = false;\n          for (; pos < end; ++pos) {\n            if (this.byteCount === MAX_HEADER_SIZE)\n              return -1;\n            ++this.byteCount;\n            const code = chunk[pos];\n            if (code !== 32/* ' ' */ && code !== 9/* '\\t' */) {\n              start = pos;\n              done = true;\n              this.state = HPARSER_VALUE;\n              break;\n            }\n          }\n          if (!done)\n            break;\n          // FALLTHROUGH\n        }\n        case HPARSER_VALUE:\n          switch (this.crlf) {\n            case 0: // Nothing yet\n              for (; pos < end; ++pos) {\n                if (this.byteCount === MAX_HEADER_SIZE)\n                  return -1;\n                ++this.byteCount;\n                const code = chunk[pos];\n                if (FIELD_VCHAR[code] !== 1) {\n                  if (code !== 13/* '\\r' */)\n                    return -1;\n                  ++this.crlf;\n                  break;\n                }\n              }\n              this.value += chunk.latin1Slice(start, pos++);\n              break;\n            case 1: // Received CR\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10/* '\\n' */)\n                return -1;\n              ++this.crlf;\n              break;\n            case 2: { // Received CR LF\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              const code = chunk[pos];\n              if (code === 32/* ' ' */ || code === 9/* '\\t' */) {\n                // Folded value\n                start = pos;\n                this.crlf = 0;\n              } else {\n                if (++this.pairCount < MAX_HEADER_PAIRS) {\n                  this.name = this.name.toLowerCase();\n                  if (this.header[this.name] === undefined)\n                    this.header[this.name] = [this.value];\n                  else\n                    this.header[this.name].push(this.value);\n                }\n                if (code === 13/* '\\r' */) {\n                  ++this.crlf;\n                  ++pos;\n                } else {\n                  // Assume start of next header field name\n                  start = pos;\n                  this.crlf = 0;\n                  this.state = HPARSER_NAME;\n                  this.name = '';\n                  this.value = '';\n                }\n              }\n              break;\n            }\n            case 3: { // Received CR LF CR\n              if (this.byteCount === MAX_HEADER_SIZE)\n                return -1;\n              ++this.byteCount;\n              if (chunk[pos++] !== 10/* '\\n' */)\n                return -1;\n              // End of header\n              const header = this.header;\n              this.reset();\n              this.cb(header);\n              return pos;\n            }\n          }\n          break;\n      }\n    }\n\n    return pos;\n  }\n}\n\nclass FileStream extends Readable {\n  constructor(opts, owner) {\n    super(opts);\n    this.truncated = false;\n    this._readcb = null;\n    this.once('end', () => {\n      // We need to make sure that we call any outstanding _writecb() that is\n      // associated with this file so that processing of the rest of the form\n      // can continue. This may not happen if the file stream ends right after\n      // backpressure kicks in, so we force it here.\n      this._read();\n      if (--owner._fileEndsLeft === 0 && owner._finalcb) {\n        const cb = owner._finalcb;\n        owner._finalcb = null;\n        // Make sure other 'end' event handlers get a chance to be executed\n        // before busboy's 'finish' event is emitted\n        process.nextTick(cb);\n      }\n    });\n  }\n  _read(n) {\n    const cb = this._readcb;\n    if (cb) {\n      this._readcb = null;\n      cb();\n    }\n  }\n}\n\nconst ignoreData = {\n  push: (chunk, pos) => {},\n  destroy: () => {},\n};\n\nfunction callAndUnsetCb(self, err) {\n  const cb = self._writecb;\n  self._writecb = null;\n  if (err)\n    self.destroy(err);\n  else if (cb)\n    cb();\n}\n\nfunction nullDecoder(val, hint) {\n  return val;\n}\n\nclass Multipart extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.highWaterMark === 'number'\n                      ? cfg.highWaterMark\n                      : undefined),\n    };\n    super(streamOpts);\n\n    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== 'string')\n      throw new Error('Multipart: Boundary not found');\n\n    const boundary = cfg.conType.params.boundary;\n    const paramDecoder = (typeof cfg.defParamCharset === 'string'\n                            && cfg.defParamCharset\n                          ? getDecoder(cfg.defParamCharset)\n                          : nullDecoder);\n    const defCharset = (cfg.defCharset || 'utf8');\n    const preservePath = cfg.preservePath;\n    const fileOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: (typeof cfg.fileHwm === 'number'\n                      ? cfg.fileHwm\n                      : undefined),\n    };\n\n    const limits = cfg.limits;\n    const fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\n                            ? limits.fieldSize\n                            : 1 * 1024 * 1024);\n    const fileSizeLimit = (limits && typeof limits.fileSize === 'number'\n                           ? limits.fileSize\n                           : Infinity);\n    const filesLimit = (limits && typeof limits.files === 'number'\n                        ? limits.files\n                        : Infinity);\n    const fieldsLimit = (limits && typeof limits.fields === 'number'\n                         ? limits.fields\n                         : Infinity);\n    const partsLimit = (limits && typeof limits.parts === 'number'\n                        ? limits.parts\n                        : Infinity);\n\n    let parts = -1; // Account for initial boundary\n    let fields = 0;\n    let files = 0;\n    let skipPart = false;\n\n    this._fileEndsLeft = 0;\n    this._fileStream = undefined;\n    this._complete = false;\n    let fileSize = 0;\n\n    let field;\n    let fieldSize = 0;\n    let partCharset;\n    let partEncoding;\n    let partType;\n    let partName;\n    let partTruncated = false;\n\n    let hitFilesLimit = false;\n    let hitFieldsLimit = false;\n\n    this._hparser = null;\n    const hparser = new HeaderParser((header) => {\n      this._hparser = null;\n      skipPart = false;\n\n      partType = 'text/plain';\n      partCharset = defCharset;\n      partEncoding = '7bit';\n      partName = undefined;\n      partTruncated = false;\n\n      let filename;\n      if (!header['content-disposition']) {\n        skipPart = true;\n        return;\n      }\n\n      const disp = parseDisposition(header['content-disposition'][0],\n                                    paramDecoder);\n      if (!disp || disp.type !== 'form-data') {\n        skipPart = true;\n        return;\n      }\n\n      if (disp.params) {\n        if (disp.params.name)\n          partName = disp.params.name;\n\n        if (disp.params['filename*'])\n          filename = disp.params['filename*'];\n        else if (disp.params.filename)\n          filename = disp.params.filename;\n\n        if (filename !== undefined && !preservePath)\n          filename = basename(filename);\n      }\n\n      if (header['content-type']) {\n        const conType = parseContentType(header['content-type'][0]);\n        if (conType) {\n          partType = `${conType.type}/${conType.subtype}`;\n          if (conType.params && typeof conType.params.charset === 'string')\n            partCharset = conType.params.charset.toLowerCase();\n        }\n      }\n\n      if (header['content-transfer-encoding'])\n        partEncoding = header['content-transfer-encoding'][0].toLowerCase();\n\n      if (partType === 'application/octet-stream' || filename !== undefined) {\n        // File\n\n        if (files === filesLimit) {\n          if (!hitFilesLimit) {\n            hitFilesLimit = true;\n            this.emit('filesLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++files;\n\n        if (this.listenerCount('file') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        fileSize = 0;\n        this._fileStream = new FileStream(fileOpts, this);\n        ++this._fileEndsLeft;\n        this.emit(\n          'file',\n          partName,\n          this._fileStream,\n          { filename,\n            encoding: partEncoding,\n            mimeType: partType }\n        );\n      } else {\n        // Non-file\n\n        if (fields === fieldsLimit) {\n          if (!hitFieldsLimit) {\n            hitFieldsLimit = true;\n            this.emit('fieldsLimit');\n          }\n          skipPart = true;\n          return;\n        }\n        ++fields;\n\n        if (this.listenerCount('field') === 0) {\n          skipPart = true;\n          return;\n        }\n\n        field = [];\n        fieldSize = 0;\n      }\n    });\n\n    let matchPostBoundary = 0;\n    const ssCb = (isMatch, data, start, end, isDataSafe) => {\nretrydata:\n      while (data) {\n        if (this._hparser !== null) {\n          const ret = this._hparser.push(data, start, end);\n          if (ret === -1) {\n            this._hparser = null;\n            hparser.reset();\n            this.emit('error', new Error('Malformed part header'));\n            break;\n          }\n          start = ret;\n        }\n\n        if (start === end)\n          break;\n\n        if (matchPostBoundary !== 0) {\n          if (matchPostBoundary === 1) {\n            switch (data[start]) {\n              case 45: // '-'\n                // Try matching '--' after boundary\n                matchPostBoundary = 2;\n                ++start;\n                break;\n              case 13: // '\\r'\n                // Try matching CR LF before header\n                matchPostBoundary = 3;\n                ++start;\n                break;\n              default:\n                matchPostBoundary = 0;\n            }\n            if (start === end)\n              return;\n          }\n\n          if (matchPostBoundary === 2) {\n            matchPostBoundary = 0;\n            if (data[start] === 45/* '-' */) {\n              // End of multipart data\n              this._complete = true;\n              this._bparser = ignoreData;\n              return;\n            }\n            // We saw something other than '-', so put the dash we consumed\n            // \"back\"\n            const writecb = this._writecb;\n            this._writecb = noop;\n            ssCb(false, BUF_DASH, 0, 1, false);\n            this._writecb = writecb;\n          } else if (matchPostBoundary === 3) {\n            matchPostBoundary = 0;\n            if (data[start] === 10/* '\\n' */) {\n              ++start;\n              if (parts >= partsLimit)\n                break;\n              // Prepare the header parser\n              this._hparser = hparser;\n              if (start === end)\n                break;\n              // Process the remaining data as a header\n              continue retrydata;\n            } else {\n              // We saw something other than LF, so put the CR we consumed\n              // \"back\"\n              const writecb = this._writecb;\n              this._writecb = noop;\n              ssCb(false, BUF_CR, 0, 1, false);\n              this._writecb = writecb;\n            }\n          }\n        }\n\n        if (!skipPart) {\n          if (this._fileStream) {\n            let chunk;\n            const actualLen = Math.min(end - start, fileSizeLimit - fileSize);\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fileSize += chunk.length;\n            if (fileSize === fileSizeLimit) {\n              if (chunk.length > 0)\n                this._fileStream.push(chunk);\n              this._fileStream.emit('limit');\n              this._fileStream.truncated = true;\n              skipPart = true;\n            } else if (!this._fileStream.push(chunk)) {\n              if (this._writecb)\n                this._fileStream._readcb = this._writecb;\n              this._writecb = null;\n            }\n          } else if (field !== undefined) {\n            let chunk;\n            const actualLen = Math.min(\n              end - start,\n              fieldSizeLimit - fieldSize\n            );\n            if (!isDataSafe) {\n              chunk = Buffer.allocUnsafe(actualLen);\n              data.copy(chunk, 0, start, start + actualLen);\n            } else {\n              chunk = data.slice(start, start + actualLen);\n            }\n\n            fieldSize += actualLen;\n            field.push(chunk);\n            if (fieldSize === fieldSizeLimit) {\n              skipPart = true;\n              partTruncated = true;\n            }\n          }\n        }\n\n        break;\n      }\n\n      if (isMatch) {\n        matchPostBoundary = 1;\n\n        if (this._fileStream) {\n          // End the active file stream if the previous part was a file\n          this._fileStream.push(null);\n          this._fileStream = null;\n        } else if (field !== undefined) {\n          let data;\n          switch (field.length) {\n            case 0:\n              data = '';\n              break;\n            case 1:\n              data = convertToUTF8(field[0], partCharset, 0);\n              break;\n            default:\n              data = convertToUTF8(\n                Buffer.concat(field, fieldSize),\n                partCharset,\n                0\n              );\n          }\n          field = undefined;\n          fieldSize = 0;\n          this.emit(\n            'field',\n            partName,\n            data,\n            { nameTruncated: false,\n              valueTruncated: partTruncated,\n              encoding: partEncoding,\n              mimeType: partType }\n          );\n        }\n\n        if (++parts === partsLimit)\n          this.emit('partsLimit');\n      }\n    };\n    this._bparser = new StreamSearch(`\\r\\n--${boundary}`, ssCb);\n\n    this._writecb = null;\n    this._finalcb = null;\n\n    // Just in case there is no preamble\n    this.write(BUF_CRLF);\n  }\n\n  static detect(conType) {\n    return (conType.type === 'multipart' && conType.subtype === 'form-data');\n  }\n\n  _write(chunk, enc, cb) {\n    this._writecb = cb;\n    this._bparser.push(chunk, 0);\n    if (this._writecb)\n      callAndUnsetCb(this);\n  }\n\n  _destroy(err, cb) {\n    this._hparser = null;\n    this._bparser = ignoreData;\n    if (!err)\n      err = checkEndState(this);\n    const fileStream = this._fileStream;\n    if (fileStream) {\n      this._fileStream = null;\n      fileStream.destroy(err);\n    }\n    cb(err);\n  }\n\n  _final(cb) {\n    this._bparser.destroy();\n    if (!this._complete)\n      return cb(new Error('Unexpected end of form'));\n    if (this._fileEndsLeft)\n      this._finalcb = finalcb.bind(null, this, cb);\n    else\n      finalcb(this, cb);\n  }\n}\n\nfunction finalcb(self, cb, err) {\n  if (err)\n    return cb(err);\n  err = checkEndState(self);\n  cb(err);\n}\n\nfunction checkEndState(self) {\n  if (self._hparser)\n    return new Error('Malformed part header');\n  const fileStream = self._fileStream;\n  if (fileStream) {\n    self._fileStream = null;\n    fileStream.destroy(new Error('Unexpected end of file'));\n  }\n  if (!self._complete)\n    return new Error('Unexpected end of form');\n}\n\nconst TOKEN = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n\nconst FIELD_VCHAR = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n];\n\nmodule.exports = Multipart;\n"]},"metadata":{},"sourceType":"script"}